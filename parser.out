Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start_program
Rule 1     start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body
Rule 2     start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body
Rule 3     start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body
Rule 4     start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body
Rule 5     cuadruploMain -> empty
Rule 6     multiple_funcs -> dec_func
Rule 7     multiple_funcs -> dec_func multiple_funcs
Rule 8     main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body
Rule 9     crearTablaMain -> empty
Rule 10    gotoMain -> empty
Rule 11    vars -> VAR varss
Rule 12    varss -> type guardarTipo mvar SEMICOLON varss
Rule 13    varss -> type guardarTipo mvar SEMICOLON
Rule 14    guardarTipo -> empty
Rule 15    mvar -> ID COLON mvar
Rule 16    mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
Rule 17    mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
Rule 18    mvar -> ID
Rule 19    mvar -> ID BRACEOPEN CTEINT BRACECLOSE
Rule 20    mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE
Rule 21    dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
Rule 22    dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
Rule 23    crearSymbolTable -> empty
Rule 24    exitFunc -> empty
Rule 25    param -> type variable
Rule 26    param -> type variable COLON param
Rule 27    param -> empty
Rule 28    type -> INT
Rule 29    type -> FLOAT
Rule 30    type -> CHAR
Rule 31    body -> BRACKETOPEN bodyy BRACKETCLOSE
Rule 32    bodyy -> statement
Rule 33    bodyy -> statement bodyy
Rule 34    bodyy -> empty
Rule 35    statement -> dec_variables
Rule 36    statement -> assignment
Rule 37    statement -> condition
Rule 38    statement -> writing
Rule 39    statement -> reading
Rule 40    statement -> call_func
Rule 41    statement -> graph
Rule 42    statement -> return
Rule 43    statement -> while_loop
Rule 44    statement -> for_loop
Rule 45    statement -> max
Rule 46    statement -> min
Rule 47    statement -> sum
Rule 48    statement -> normal
Rule 49    statement -> uniforme
Rule 50    statement -> poisson
Rule 51    statement -> binomial
Rule 52    dec_variables -> dec_variabless
Rule 53    dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless
Rule 54    dec_variabless -> type guardarTipo dec_mvar SEMICOLON
Rule 55    dec_mvar -> ID COLON dec_mvar
Rule 56    dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
Rule 57    dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
Rule 58    dec_mvar -> ID
Rule 59    dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE
Rule 60    dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE
Rule 61    assignment -> variable EQUAL exp SEMICOLON
Rule 62    call_func -> ID PARENOPEN call_funcc PARENCLOSE
Rule 63    call_funcc -> exp
Rule 64    call_funcc -> exp COLON call_funcc
Rule 65    call_funcc -> empty
Rule 66    graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON
Rule 67    exp -> exp GREATHERTHAN exp
Rule 68    exp -> exp LESSTHAN exp
Rule 69    exp -> exp GREATHEREQUAL exp
Rule 70    exp -> exp LESSEQUAL exp
Rule 71    exp -> exp DIFFERENT exp
Rule 72    exp -> exp SAME exp
Rule 73    exp -> exp AND exp
Rule 74    exp -> exp OR exp
Rule 75    exp -> m_exp
Rule 76    m_exp -> t m_expp
Rule 77    m_expp -> PLUS appendPLUS m_exp
Rule 78    m_expp -> MINUS appendMINUS m_exp
Rule 79    m_expp -> empty
Rule 80    appendPLUS -> empty
Rule 81    appendMINUS -> empty
Rule 82    appendMULTIPLY -> empty
Rule 83    appendDIVIDE -> empty
Rule 84    t -> f termino
Rule 85    termino -> MULTIPLY appendMULTIPLY t
Rule 86    termino -> DIVIDE appendDIVIDE t
Rule 87    termino -> empty
Rule 88    f -> PARENOPEN exp PARENCLOSE
Rule 89    f -> ID
Rule 90    f -> CTEINT
Rule 91    f -> CTFLOAT
Rule 92    f -> variable
Rule 93    f -> call_func
Rule 94    variable -> ID
Rule 95    variable -> ID BRACEOPEN exp BRACECLOSE
Rule 96    variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
Rule 97    condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
Rule 98    condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
Rule 99    cuadruploIF -> empty
Rule 100   ifEnd -> empty
Rule 101   cuadruploElse -> empty
Rule 102   ifEndElse -> empty
Rule 103   writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
Rule 104   writingg -> exp
Rule 105   writingg -> exp COLON writingg
Rule 106   writingg -> auxString
Rule 107   writingg -> auxString COLON writingg
Rule 108   auxString -> CTESTRING
Rule 109   reading -> READ multivariables SEMICOLON
Rule 110   multivariables -> variable
Rule 111   multivariables -> variable COLON multivariables
Rule 112   while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
Rule 113   whileMigaja -> empty
Rule 114   whileEval -> empty
Rule 115   whileEnd -> empty
Rule 116   for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd
Rule 117   guardarValorFor -> empty
Rule 118   forEnd -> empty
Rule 119   return -> RETURN exp SEMICOLON
Rule 120   max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON
Rule 121   min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON
Rule 122   sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON
Rule 123   param_dist -> variable
Rule 124   param_dist -> variable COLON param_dist
Rule 125   binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 126   poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 127   uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 128   normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 129   empty -> <empty>

Terminals, with rules where they appear

AND                  : 73
BINOMIAL             : 125
BRACECLOSE           : 16 17 17 19 20 20 56 57 57 59 60 60 95 96 96
BRACEOPEN            : 16 17 17 19 20 20 56 57 57 59 60 60 95 96 96
BRACKETCLOSE         : 31
BRACKETOPEN          : 31
CHAR                 : 30
COLON                : 15 16 17 26 55 56 57 64 105 107 111 124
CTEINT               : 16 17 17 19 20 20 56 57 57 59 60 60 90
CTESTRING            : 108
CTFLOAT              : 91
DIFFERENT            : 71
DIVIDE               : 86
ELSE                 : 98
EQUAL                : 61 116
FLOAT                : 29
FOR                  : 116
FUNCTION             : 21 22
GREATHEREQUAL        : 69
GREATHERTHAN         : 67
ID                   : 1 2 3 4 15 16 17 18 19 20 21 22 55 56 57 58 59 60 62 89 94 95 96
IF                   : 97 98
INT                  : 28
LESSEQUAL            : 70
LESSTHAN             : 68
MAIN                 : 8
MAX                  : 120
MIN                  : 121
MINUS                : 78
MULTIPLY             : 85
NORMAL               : 128
OR                   : 74
PARENCLOSE           : 8 21 22 62 66 88 97 98 103 112 116 120 121 122 125 126 127 128
PARENOPEN            : 8 21 22 62 66 88 97 98 103 112 116 120 121 122 125 126 127 128
PLOT                 : 66
PLUS                 : 77
POISSON              : 126
PRINT                : 103
PROGRAM              : 1 2 3 4
READ                 : 109
RETURN               : 119
SAME                 : 72
SEMICOLON            : 1 2 3 4 12 13 53 54 61 66 103 109 119 120 121 122 125 126 127 128
SUM                  : 122
TO                   : 116
UNIFORME             : 127
VAR                  : 11
VOID                 : 22
WHILE                : 112
error                : 

Nonterminals, with rules where they appear

appendDIVIDE         : 86
appendMINUS          : 78
appendMULTIPLY       : 85
appendPLUS           : 77
assignment           : 36
auxString            : 106 107
binomial             : 51
body                 : 8 21 22 97 98 98 112 116
bodyy                : 31 33
call_func            : 40 93
call_funcc           : 62 64
condition            : 37
crearSymbolTable     : 21 22
crearTablaMain       : 8
cuadruploElse        : 98
cuadruploIF          : 97 98
cuadruploMain        : 1 2 3 4
dec_func             : 6 7
dec_mvar             : 53 54 55 56 57
dec_variables        : 35
dec_variabless       : 52 53
empty                : 5 9 10 14 23 24 27 34 65 79 80 81 82 83 87 99 100 101 102 113 114 115 117 118
exitFunc             : 21 22
exp                  : 61 63 64 66 67 67 68 68 69 69 70 70 71 71 72 72 73 73 74 74 88 95 96 96 97 98 104 105 112 116 116 119 120 121 122
f                    : 84
forEnd               : 116
for_loop             : 44
gotoMain             : 8
graph                : 41
guardarTipo          : 12 13 53 54
guardarValorFor      : 116
ifEnd                : 97
ifEndElse            : 98
m_exp                : 75 77 78
m_expp               : 76
main_body            : 1 2 3 4
max                  : 45
min                  : 46
multiple_funcs       : 1 3 7
multivariables       : 109 111
mvar                 : 12 13 15 16 17
normal               : 48
param                : 21 22 26
param_dist           : 124 125 126 127 128
poisson              : 50
reading              : 39
return               : 42
start_program        : 0
statement            : 32 33
sum                  : 47
t                    : 76 85 86
termino              : 84
type                 : 12 13 21 25 26 53 54
uniforme             : 49
variable             : 25 26 61 92 110 111 116 123 124
vars                 : 1 2
varss                : 11 12
whileEnd             : 112
whileEval            : 112
whileMigaja          : 112
while_loop           : 43
writing              : 38
writingg             : 103 105 107

Parsing method: LALR

state 0

    (0) S' -> . start_program
    (1) start_program -> . cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body
    (2) start_program -> . cuadruploMain PROGRAM ID SEMICOLON vars main_body
    (3) start_program -> . cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body
    (4) start_program -> . cuadruploMain PROGRAM ID SEMICOLON main_body
    (5) cuadruploMain -> . empty
    (129) empty -> .

    PROGRAM         reduce using rule 129 (empty -> .)

    start_program                  shift and go to state 1
    cuadruploMain                  shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> start_program .



state 2

    (1) start_program -> cuadruploMain . PROGRAM ID SEMICOLON vars multiple_funcs main_body
    (2) start_program -> cuadruploMain . PROGRAM ID SEMICOLON vars main_body
    (3) start_program -> cuadruploMain . PROGRAM ID SEMICOLON multiple_funcs main_body
    (4) start_program -> cuadruploMain . PROGRAM ID SEMICOLON main_body

    PROGRAM         shift and go to state 4


state 3

    (5) cuadruploMain -> empty .

    PROGRAM         reduce using rule 5 (cuadruploMain -> empty .)


state 4

    (1) start_program -> cuadruploMain PROGRAM . ID SEMICOLON vars multiple_funcs main_body
    (2) start_program -> cuadruploMain PROGRAM . ID SEMICOLON vars main_body
    (3) start_program -> cuadruploMain PROGRAM . ID SEMICOLON multiple_funcs main_body
    (4) start_program -> cuadruploMain PROGRAM . ID SEMICOLON main_body

    ID              shift and go to state 5


state 5

    (1) start_program -> cuadruploMain PROGRAM ID . SEMICOLON vars multiple_funcs main_body
    (2) start_program -> cuadruploMain PROGRAM ID . SEMICOLON vars main_body
    (3) start_program -> cuadruploMain PROGRAM ID . SEMICOLON multiple_funcs main_body
    (4) start_program -> cuadruploMain PROGRAM ID . SEMICOLON main_body

    SEMICOLON       shift and go to state 6


state 6

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON . vars multiple_funcs main_body
    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON . vars main_body
    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON . multiple_funcs main_body
    (4) start_program -> cuadruploMain PROGRAM ID SEMICOLON . main_body
    (11) vars -> . VAR varss
    (6) multiple_funcs -> . dec_func
    (7) multiple_funcs -> . dec_func multiple_funcs
    (8) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body
    (21) dec_func -> . FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (22) dec_func -> . FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc

    VAR             shift and go to state 10
    MAIN            shift and go to state 12
    FUNCTION        shift and go to state 13

    vars                           shift and go to state 7
    multiple_funcs                 shift and go to state 8
    main_body                      shift and go to state 9
    dec_func                       shift and go to state 11

state 7

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars . multiple_funcs main_body
    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars . main_body
    (6) multiple_funcs -> . dec_func
    (7) multiple_funcs -> . dec_func multiple_funcs
    (8) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body
    (21) dec_func -> . FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (22) dec_func -> . FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc

    MAIN            shift and go to state 12
    FUNCTION        shift and go to state 13

    multiple_funcs                 shift and go to state 14
    main_body                      shift and go to state 15
    dec_func                       shift and go to state 11

state 8

    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs . main_body
    (8) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body

    MAIN            shift and go to state 12

    main_body                      shift and go to state 16

state 9

    (4) start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body .

    $end            reduce using rule 4 (start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body .)


state 10

    (11) vars -> VAR . varss
    (12) varss -> . type guardarTipo mvar SEMICOLON varss
    (13) varss -> . type guardarTipo mvar SEMICOLON
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . CHAR

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    varss                          shift and go to state 17
    type                           shift and go to state 18

state 11

    (6) multiple_funcs -> dec_func .
    (7) multiple_funcs -> dec_func . multiple_funcs
    (6) multiple_funcs -> . dec_func
    (7) multiple_funcs -> . dec_func multiple_funcs
    (21) dec_func -> . FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (22) dec_func -> . FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc

    MAIN            reduce using rule 6 (multiple_funcs -> dec_func .)
    FUNCTION        shift and go to state 13

    dec_func                       shift and go to state 11
    multiple_funcs                 shift and go to state 22

state 12

    (8) main_body -> MAIN . crearTablaMain PARENOPEN PARENCLOSE gotoMain body
    (9) crearTablaMain -> . empty
    (129) empty -> .

    PARENOPEN       reduce using rule 129 (empty -> .)

    crearTablaMain                 shift and go to state 23
    empty                          shift and go to state 24

state 13

    (21) dec_func -> FUNCTION . type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (22) dec_func -> FUNCTION . VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . CHAR

    VOID            shift and go to state 26
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    type                           shift and go to state 25

state 14

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs . main_body
    (8) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body

    MAIN            shift and go to state 12

    main_body                      shift and go to state 27

state 15

    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body .

    $end            reduce using rule 2 (start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body .)


state 16

    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body .

    $end            reduce using rule 3 (start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body .)


state 17

    (11) vars -> VAR varss .

    MAIN            reduce using rule 11 (vars -> VAR varss .)
    FUNCTION        reduce using rule 11 (vars -> VAR varss .)


state 18

    (12) varss -> type . guardarTipo mvar SEMICOLON varss
    (13) varss -> type . guardarTipo mvar SEMICOLON
    (14) guardarTipo -> . empty
    (129) empty -> .

    ID              reduce using rule 129 (empty -> .)

    guardarTipo                    shift and go to state 28
    empty                          shift and go to state 29

state 19

    (28) type -> INT .

    ID              reduce using rule 28 (type -> INT .)


state 20

    (29) type -> FLOAT .

    ID              reduce using rule 29 (type -> FLOAT .)


state 21

    (30) type -> CHAR .

    ID              reduce using rule 30 (type -> CHAR .)


state 22

    (7) multiple_funcs -> dec_func multiple_funcs .

    MAIN            reduce using rule 7 (multiple_funcs -> dec_func multiple_funcs .)


state 23

    (8) main_body -> MAIN crearTablaMain . PARENOPEN PARENCLOSE gotoMain body

    PARENOPEN       shift and go to state 30


state 24

    (9) crearTablaMain -> empty .

    PARENOPEN       reduce using rule 9 (crearTablaMain -> empty .)


state 25

    (21) dec_func -> FUNCTION type . ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc

    ID              shift and go to state 31


state 26

    (22) dec_func -> FUNCTION VOID . ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc

    ID              shift and go to state 32


state 27

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body .

    $end            reduce using rule 1 (start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body .)


state 28

    (12) varss -> type guardarTipo . mvar SEMICOLON varss
    (13) varss -> type guardarTipo . mvar SEMICOLON
    (15) mvar -> . ID COLON mvar
    (16) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> . ID
    (19) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (20) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 34

    mvar                           shift and go to state 33

state 29

    (14) guardarTipo -> empty .

    ID              reduce using rule 14 (guardarTipo -> empty .)


state 30

    (8) main_body -> MAIN crearTablaMain PARENOPEN . PARENCLOSE gotoMain body

    PARENCLOSE      shift and go to state 35


state 31

    (21) dec_func -> FUNCTION type ID . crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (23) crearSymbolTable -> . empty
    (129) empty -> .

    PARENOPEN       reduce using rule 129 (empty -> .)

    crearSymbolTable               shift and go to state 36
    empty                          shift and go to state 37

state 32

    (22) dec_func -> FUNCTION VOID ID . crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (23) crearSymbolTable -> . empty
    (129) empty -> .

    PARENOPEN       reduce using rule 129 (empty -> .)

    crearSymbolTable               shift and go to state 38
    empty                          shift and go to state 37

state 33

    (12) varss -> type guardarTipo mvar . SEMICOLON varss
    (13) varss -> type guardarTipo mvar . SEMICOLON

    SEMICOLON       shift and go to state 39


state 34

    (15) mvar -> ID . COLON mvar
    (16) mvar -> ID . BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> ID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> ID .
    (19) mvar -> ID . BRACEOPEN CTEINT BRACECLOSE
    (20) mvar -> ID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 40
    BRACEOPEN       shift and go to state 41
    SEMICOLON       reduce using rule 18 (mvar -> ID .)


state 35

    (8) main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE . gotoMain body
    (10) gotoMain -> . empty
    (129) empty -> .

    BRACKETOPEN     reduce using rule 129 (empty -> .)

    gotoMain                       shift and go to state 42
    empty                          shift and go to state 43

state 36

    (21) dec_func -> FUNCTION type ID crearSymbolTable . PARENOPEN param PARENCLOSE body exitFunc

    PARENOPEN       shift and go to state 44


state 37

    (23) crearSymbolTable -> empty .

    PARENOPEN       reduce using rule 23 (crearSymbolTable -> empty .)


state 38

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable . PARENOPEN param PARENCLOSE body exitFunc

    PARENOPEN       shift and go to state 45


state 39

    (12) varss -> type guardarTipo mvar SEMICOLON . varss
    (13) varss -> type guardarTipo mvar SEMICOLON .
    (12) varss -> . type guardarTipo mvar SEMICOLON varss
    (13) varss -> . type guardarTipo mvar SEMICOLON
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . CHAR

    MAIN            reduce using rule 13 (varss -> type guardarTipo mvar SEMICOLON .)
    FUNCTION        reduce using rule 13 (varss -> type guardarTipo mvar SEMICOLON .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    type                           shift and go to state 18
    varss                          shift and go to state 46

state 40

    (15) mvar -> ID COLON . mvar
    (15) mvar -> . ID COLON mvar
    (16) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> . ID
    (19) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (20) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 34

    mvar                           shift and go to state 47

state 41

    (16) mvar -> ID BRACEOPEN . CTEINT BRACECLOSE COLON mvar
    (17) mvar -> ID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (19) mvar -> ID BRACEOPEN . CTEINT BRACECLOSE
    (20) mvar -> ID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    CTEINT          shift and go to state 48


state 42

    (8) main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain . body
    (31) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 49

state 43

    (10) gotoMain -> empty .

    BRACKETOPEN     reduce using rule 10 (gotoMain -> empty .)


state 44

    (21) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN . param PARENCLOSE body exitFunc
    (25) param -> . type variable
    (26) param -> . type variable COLON param
    (27) param -> . empty
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . CHAR
    (129) empty -> .

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21
    PARENCLOSE      reduce using rule 129 (empty -> .)

    type                           shift and go to state 51
    param                          shift and go to state 52
    empty                          shift and go to state 53

state 45

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN . param PARENCLOSE body exitFunc
    (25) param -> . type variable
    (26) param -> . type variable COLON param
    (27) param -> . empty
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . CHAR
    (129) empty -> .

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21
    PARENCLOSE      reduce using rule 129 (empty -> .)

    param                          shift and go to state 54
    type                           shift and go to state 51
    empty                          shift and go to state 53

state 46

    (12) varss -> type guardarTipo mvar SEMICOLON varss .

    MAIN            reduce using rule 12 (varss -> type guardarTipo mvar SEMICOLON varss .)
    FUNCTION        reduce using rule 12 (varss -> type guardarTipo mvar SEMICOLON varss .)


state 47

    (15) mvar -> ID COLON mvar .

    SEMICOLON       reduce using rule 15 (mvar -> ID COLON mvar .)


state 48

    (16) mvar -> ID BRACEOPEN CTEINT . BRACECLOSE COLON mvar
    (17) mvar -> ID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (19) mvar -> ID BRACEOPEN CTEINT . BRACECLOSE
    (20) mvar -> ID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    BRACECLOSE      shift and go to state 55


state 49

    (8) main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body .

    $end            reduce using rule 8 (main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body .)


state 50

    (31) body -> BRACKETOPEN . bodyy BRACKETCLOSE
    (32) bodyy -> . statement
    (33) bodyy -> . statement bodyy
    (34) bodyy -> . empty
    (35) statement -> . dec_variables
    (36) statement -> . assignment
    (37) statement -> . condition
    (38) statement -> . writing
    (39) statement -> . reading
    (40) statement -> . call_func
    (41) statement -> . graph
    (42) statement -> . return
    (43) statement -> . while_loop
    (44) statement -> . for_loop
    (45) statement -> . max
    (46) statement -> . min
    (47) statement -> . sum
    (48) statement -> . normal
    (49) statement -> . uniforme
    (50) statement -> . poisson
    (51) statement -> . binomial
    (129) empty -> .
    (52) dec_variables -> . dec_variabless
    (61) assignment -> . variable EQUAL exp SEMICOLON
    (97) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
    (98) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (103) writing -> . PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
    (109) reading -> . READ multivariables SEMICOLON
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE
    (66) graph -> . PLOT PARENOPEN exp PARENCLOSE SEMICOLON
    (119) return -> . RETURN exp SEMICOLON
    (112) while_loop -> . WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (116) for_loop -> . FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd
    (120) max -> . MAX PARENOPEN exp PARENCLOSE SEMICOLON
    (121) min -> . MIN PARENOPEN exp PARENCLOSE SEMICOLON
    (122) sum -> . SUM PARENOPEN exp PARENCLOSE SEMICOLON
    (128) normal -> . NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (127) uniforme -> . UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON
    (126) poisson -> . POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON
    (125) binomial -> . BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (53) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON dec_variabless
    (54) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . CHAR

    BRACKETCLOSE    reduce using rule 129 (empty -> .)
    IF              shift and go to state 78
    PRINT           shift and go to state 79
    READ            shift and go to state 80
    ID              shift and go to state 81
    PLOT            shift and go to state 82
    RETURN          shift and go to state 83
    WHILE           shift and go to state 84
    FOR             shift and go to state 85
    MAX             shift and go to state 86
    MIN             shift and go to state 87
    SUM             shift and go to state 88
    NORMAL          shift and go to state 89
    UNIFORME        shift and go to state 90
    POISSON         shift and go to state 91
    BINOMIAL        shift and go to state 92
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    bodyy                          shift and go to state 56
    statement                      shift and go to state 57
    empty                          shift and go to state 58
    dec_variables                  shift and go to state 59
    assignment                     shift and go to state 60
    condition                      shift and go to state 61
    writing                        shift and go to state 62
    reading                        shift and go to state 63
    call_func                      shift and go to state 64
    graph                          shift and go to state 65
    return                         shift and go to state 66
    while_loop                     shift and go to state 67
    for_loop                       shift and go to state 68
    max                            shift and go to state 69
    min                            shift and go to state 70
    sum                            shift and go to state 71
    normal                         shift and go to state 72
    uniforme                       shift and go to state 73
    poisson                        shift and go to state 74
    binomial                       shift and go to state 75
    dec_variabless                 shift and go to state 76
    variable                       shift and go to state 77
    type                           shift and go to state 93

state 51

    (25) param -> type . variable
    (26) param -> type . variable COLON param
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 95

    variable                       shift and go to state 94

state 52

    (21) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param . PARENCLOSE body exitFunc

    PARENCLOSE      shift and go to state 96


state 53

    (27) param -> empty .

    PARENCLOSE      reduce using rule 27 (param -> empty .)


state 54

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param . PARENCLOSE body exitFunc

    PARENCLOSE      shift and go to state 97


state 55

    (16) mvar -> ID BRACEOPEN CTEINT BRACECLOSE . COLON mvar
    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (19) mvar -> ID BRACEOPEN CTEINT BRACECLOSE .
    (20) mvar -> ID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 99
    BRACEOPEN       shift and go to state 98
    SEMICOLON       reduce using rule 19 (mvar -> ID BRACEOPEN CTEINT BRACECLOSE .)


state 56

    (31) body -> BRACKETOPEN bodyy . BRACKETCLOSE

    BRACKETCLOSE    shift and go to state 100


state 57

    (32) bodyy -> statement .
    (33) bodyy -> statement . bodyy
    (32) bodyy -> . statement
    (33) bodyy -> . statement bodyy
    (34) bodyy -> . empty
    (35) statement -> . dec_variables
    (36) statement -> . assignment
    (37) statement -> . condition
    (38) statement -> . writing
    (39) statement -> . reading
    (40) statement -> . call_func
    (41) statement -> . graph
    (42) statement -> . return
    (43) statement -> . while_loop
    (44) statement -> . for_loop
    (45) statement -> . max
    (46) statement -> . min
    (47) statement -> . sum
    (48) statement -> . normal
    (49) statement -> . uniforme
    (50) statement -> . poisson
    (51) statement -> . binomial
    (129) empty -> .
    (52) dec_variables -> . dec_variabless
    (61) assignment -> . variable EQUAL exp SEMICOLON
    (97) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
    (98) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (103) writing -> . PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
    (109) reading -> . READ multivariables SEMICOLON
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE
    (66) graph -> . PLOT PARENOPEN exp PARENCLOSE SEMICOLON
    (119) return -> . RETURN exp SEMICOLON
    (112) while_loop -> . WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (116) for_loop -> . FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd
    (120) max -> . MAX PARENOPEN exp PARENCLOSE SEMICOLON
    (121) min -> . MIN PARENOPEN exp PARENCLOSE SEMICOLON
    (122) sum -> . SUM PARENOPEN exp PARENCLOSE SEMICOLON
    (128) normal -> . NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (127) uniforme -> . UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON
    (126) poisson -> . POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON
    (125) binomial -> . BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (53) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON dec_variabless
    (54) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . CHAR

  ! reduce/reduce conflict for BRACKETCLOSE resolved using rule 32 (bodyy -> statement .)
    BRACKETCLOSE    reduce using rule 32 (bodyy -> statement .)
    IF              shift and go to state 78
    PRINT           shift and go to state 79
    READ            shift and go to state 80
    ID              shift and go to state 81
    PLOT            shift and go to state 82
    RETURN          shift and go to state 83
    WHILE           shift and go to state 84
    FOR             shift and go to state 85
    MAX             shift and go to state 86
    MIN             shift and go to state 87
    SUM             shift and go to state 88
    NORMAL          shift and go to state 89
    UNIFORME        shift and go to state 90
    POISSON         shift and go to state 91
    BINOMIAL        shift and go to state 92
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

  ! BRACKETCLOSE    [ reduce using rule 129 (empty -> .) ]

    statement                      shift and go to state 57
    bodyy                          shift and go to state 101
    empty                          shift and go to state 58
    dec_variables                  shift and go to state 59
    assignment                     shift and go to state 60
    condition                      shift and go to state 61
    writing                        shift and go to state 62
    reading                        shift and go to state 63
    call_func                      shift and go to state 64
    graph                          shift and go to state 65
    return                         shift and go to state 66
    while_loop                     shift and go to state 67
    for_loop                       shift and go to state 68
    max                            shift and go to state 69
    min                            shift and go to state 70
    sum                            shift and go to state 71
    normal                         shift and go to state 72
    uniforme                       shift and go to state 73
    poisson                        shift and go to state 74
    binomial                       shift and go to state 75
    dec_variabless                 shift and go to state 76
    variable                       shift and go to state 77
    type                           shift and go to state 93

state 58

    (34) bodyy -> empty .

    BRACKETCLOSE    reduce using rule 34 (bodyy -> empty .)


state 59

    (35) statement -> dec_variables .

    IF              reduce using rule 35 (statement -> dec_variables .)
    PRINT           reduce using rule 35 (statement -> dec_variables .)
    READ            reduce using rule 35 (statement -> dec_variables .)
    ID              reduce using rule 35 (statement -> dec_variables .)
    PLOT            reduce using rule 35 (statement -> dec_variables .)
    RETURN          reduce using rule 35 (statement -> dec_variables .)
    WHILE           reduce using rule 35 (statement -> dec_variables .)
    FOR             reduce using rule 35 (statement -> dec_variables .)
    MAX             reduce using rule 35 (statement -> dec_variables .)
    MIN             reduce using rule 35 (statement -> dec_variables .)
    SUM             reduce using rule 35 (statement -> dec_variables .)
    NORMAL          reduce using rule 35 (statement -> dec_variables .)
    UNIFORME        reduce using rule 35 (statement -> dec_variables .)
    POISSON         reduce using rule 35 (statement -> dec_variables .)
    BINOMIAL        reduce using rule 35 (statement -> dec_variables .)
    INT             reduce using rule 35 (statement -> dec_variables .)
    FLOAT           reduce using rule 35 (statement -> dec_variables .)
    CHAR            reduce using rule 35 (statement -> dec_variables .)
    BRACKETCLOSE    reduce using rule 35 (statement -> dec_variables .)


state 60

    (36) statement -> assignment .

    IF              reduce using rule 36 (statement -> assignment .)
    PRINT           reduce using rule 36 (statement -> assignment .)
    READ            reduce using rule 36 (statement -> assignment .)
    ID              reduce using rule 36 (statement -> assignment .)
    PLOT            reduce using rule 36 (statement -> assignment .)
    RETURN          reduce using rule 36 (statement -> assignment .)
    WHILE           reduce using rule 36 (statement -> assignment .)
    FOR             reduce using rule 36 (statement -> assignment .)
    MAX             reduce using rule 36 (statement -> assignment .)
    MIN             reduce using rule 36 (statement -> assignment .)
    SUM             reduce using rule 36 (statement -> assignment .)
    NORMAL          reduce using rule 36 (statement -> assignment .)
    UNIFORME        reduce using rule 36 (statement -> assignment .)
    POISSON         reduce using rule 36 (statement -> assignment .)
    BINOMIAL        reduce using rule 36 (statement -> assignment .)
    INT             reduce using rule 36 (statement -> assignment .)
    FLOAT           reduce using rule 36 (statement -> assignment .)
    CHAR            reduce using rule 36 (statement -> assignment .)
    BRACKETCLOSE    reduce using rule 36 (statement -> assignment .)


state 61

    (37) statement -> condition .

    IF              reduce using rule 37 (statement -> condition .)
    PRINT           reduce using rule 37 (statement -> condition .)
    READ            reduce using rule 37 (statement -> condition .)
    ID              reduce using rule 37 (statement -> condition .)
    PLOT            reduce using rule 37 (statement -> condition .)
    RETURN          reduce using rule 37 (statement -> condition .)
    WHILE           reduce using rule 37 (statement -> condition .)
    FOR             reduce using rule 37 (statement -> condition .)
    MAX             reduce using rule 37 (statement -> condition .)
    MIN             reduce using rule 37 (statement -> condition .)
    SUM             reduce using rule 37 (statement -> condition .)
    NORMAL          reduce using rule 37 (statement -> condition .)
    UNIFORME        reduce using rule 37 (statement -> condition .)
    POISSON         reduce using rule 37 (statement -> condition .)
    BINOMIAL        reduce using rule 37 (statement -> condition .)
    INT             reduce using rule 37 (statement -> condition .)
    FLOAT           reduce using rule 37 (statement -> condition .)
    CHAR            reduce using rule 37 (statement -> condition .)
    BRACKETCLOSE    reduce using rule 37 (statement -> condition .)


state 62

    (38) statement -> writing .

    IF              reduce using rule 38 (statement -> writing .)
    PRINT           reduce using rule 38 (statement -> writing .)
    READ            reduce using rule 38 (statement -> writing .)
    ID              reduce using rule 38 (statement -> writing .)
    PLOT            reduce using rule 38 (statement -> writing .)
    RETURN          reduce using rule 38 (statement -> writing .)
    WHILE           reduce using rule 38 (statement -> writing .)
    FOR             reduce using rule 38 (statement -> writing .)
    MAX             reduce using rule 38 (statement -> writing .)
    MIN             reduce using rule 38 (statement -> writing .)
    SUM             reduce using rule 38 (statement -> writing .)
    NORMAL          reduce using rule 38 (statement -> writing .)
    UNIFORME        reduce using rule 38 (statement -> writing .)
    POISSON         reduce using rule 38 (statement -> writing .)
    BINOMIAL        reduce using rule 38 (statement -> writing .)
    INT             reduce using rule 38 (statement -> writing .)
    FLOAT           reduce using rule 38 (statement -> writing .)
    CHAR            reduce using rule 38 (statement -> writing .)
    BRACKETCLOSE    reduce using rule 38 (statement -> writing .)


state 63

    (39) statement -> reading .

    IF              reduce using rule 39 (statement -> reading .)
    PRINT           reduce using rule 39 (statement -> reading .)
    READ            reduce using rule 39 (statement -> reading .)
    ID              reduce using rule 39 (statement -> reading .)
    PLOT            reduce using rule 39 (statement -> reading .)
    RETURN          reduce using rule 39 (statement -> reading .)
    WHILE           reduce using rule 39 (statement -> reading .)
    FOR             reduce using rule 39 (statement -> reading .)
    MAX             reduce using rule 39 (statement -> reading .)
    MIN             reduce using rule 39 (statement -> reading .)
    SUM             reduce using rule 39 (statement -> reading .)
    NORMAL          reduce using rule 39 (statement -> reading .)
    UNIFORME        reduce using rule 39 (statement -> reading .)
    POISSON         reduce using rule 39 (statement -> reading .)
    BINOMIAL        reduce using rule 39 (statement -> reading .)
    INT             reduce using rule 39 (statement -> reading .)
    FLOAT           reduce using rule 39 (statement -> reading .)
    CHAR            reduce using rule 39 (statement -> reading .)
    BRACKETCLOSE    reduce using rule 39 (statement -> reading .)


state 64

    (40) statement -> call_func .

    IF              reduce using rule 40 (statement -> call_func .)
    PRINT           reduce using rule 40 (statement -> call_func .)
    READ            reduce using rule 40 (statement -> call_func .)
    ID              reduce using rule 40 (statement -> call_func .)
    PLOT            reduce using rule 40 (statement -> call_func .)
    RETURN          reduce using rule 40 (statement -> call_func .)
    WHILE           reduce using rule 40 (statement -> call_func .)
    FOR             reduce using rule 40 (statement -> call_func .)
    MAX             reduce using rule 40 (statement -> call_func .)
    MIN             reduce using rule 40 (statement -> call_func .)
    SUM             reduce using rule 40 (statement -> call_func .)
    NORMAL          reduce using rule 40 (statement -> call_func .)
    UNIFORME        reduce using rule 40 (statement -> call_func .)
    POISSON         reduce using rule 40 (statement -> call_func .)
    BINOMIAL        reduce using rule 40 (statement -> call_func .)
    INT             reduce using rule 40 (statement -> call_func .)
    FLOAT           reduce using rule 40 (statement -> call_func .)
    CHAR            reduce using rule 40 (statement -> call_func .)
    BRACKETCLOSE    reduce using rule 40 (statement -> call_func .)


state 65

    (41) statement -> graph .

    IF              reduce using rule 41 (statement -> graph .)
    PRINT           reduce using rule 41 (statement -> graph .)
    READ            reduce using rule 41 (statement -> graph .)
    ID              reduce using rule 41 (statement -> graph .)
    PLOT            reduce using rule 41 (statement -> graph .)
    RETURN          reduce using rule 41 (statement -> graph .)
    WHILE           reduce using rule 41 (statement -> graph .)
    FOR             reduce using rule 41 (statement -> graph .)
    MAX             reduce using rule 41 (statement -> graph .)
    MIN             reduce using rule 41 (statement -> graph .)
    SUM             reduce using rule 41 (statement -> graph .)
    NORMAL          reduce using rule 41 (statement -> graph .)
    UNIFORME        reduce using rule 41 (statement -> graph .)
    POISSON         reduce using rule 41 (statement -> graph .)
    BINOMIAL        reduce using rule 41 (statement -> graph .)
    INT             reduce using rule 41 (statement -> graph .)
    FLOAT           reduce using rule 41 (statement -> graph .)
    CHAR            reduce using rule 41 (statement -> graph .)
    BRACKETCLOSE    reduce using rule 41 (statement -> graph .)


state 66

    (42) statement -> return .

    IF              reduce using rule 42 (statement -> return .)
    PRINT           reduce using rule 42 (statement -> return .)
    READ            reduce using rule 42 (statement -> return .)
    ID              reduce using rule 42 (statement -> return .)
    PLOT            reduce using rule 42 (statement -> return .)
    RETURN          reduce using rule 42 (statement -> return .)
    WHILE           reduce using rule 42 (statement -> return .)
    FOR             reduce using rule 42 (statement -> return .)
    MAX             reduce using rule 42 (statement -> return .)
    MIN             reduce using rule 42 (statement -> return .)
    SUM             reduce using rule 42 (statement -> return .)
    NORMAL          reduce using rule 42 (statement -> return .)
    UNIFORME        reduce using rule 42 (statement -> return .)
    POISSON         reduce using rule 42 (statement -> return .)
    BINOMIAL        reduce using rule 42 (statement -> return .)
    INT             reduce using rule 42 (statement -> return .)
    FLOAT           reduce using rule 42 (statement -> return .)
    CHAR            reduce using rule 42 (statement -> return .)
    BRACKETCLOSE    reduce using rule 42 (statement -> return .)


state 67

    (43) statement -> while_loop .

    IF              reduce using rule 43 (statement -> while_loop .)
    PRINT           reduce using rule 43 (statement -> while_loop .)
    READ            reduce using rule 43 (statement -> while_loop .)
    ID              reduce using rule 43 (statement -> while_loop .)
    PLOT            reduce using rule 43 (statement -> while_loop .)
    RETURN          reduce using rule 43 (statement -> while_loop .)
    WHILE           reduce using rule 43 (statement -> while_loop .)
    FOR             reduce using rule 43 (statement -> while_loop .)
    MAX             reduce using rule 43 (statement -> while_loop .)
    MIN             reduce using rule 43 (statement -> while_loop .)
    SUM             reduce using rule 43 (statement -> while_loop .)
    NORMAL          reduce using rule 43 (statement -> while_loop .)
    UNIFORME        reduce using rule 43 (statement -> while_loop .)
    POISSON         reduce using rule 43 (statement -> while_loop .)
    BINOMIAL        reduce using rule 43 (statement -> while_loop .)
    INT             reduce using rule 43 (statement -> while_loop .)
    FLOAT           reduce using rule 43 (statement -> while_loop .)
    CHAR            reduce using rule 43 (statement -> while_loop .)
    BRACKETCLOSE    reduce using rule 43 (statement -> while_loop .)


state 68

    (44) statement -> for_loop .

    IF              reduce using rule 44 (statement -> for_loop .)
    PRINT           reduce using rule 44 (statement -> for_loop .)
    READ            reduce using rule 44 (statement -> for_loop .)
    ID              reduce using rule 44 (statement -> for_loop .)
    PLOT            reduce using rule 44 (statement -> for_loop .)
    RETURN          reduce using rule 44 (statement -> for_loop .)
    WHILE           reduce using rule 44 (statement -> for_loop .)
    FOR             reduce using rule 44 (statement -> for_loop .)
    MAX             reduce using rule 44 (statement -> for_loop .)
    MIN             reduce using rule 44 (statement -> for_loop .)
    SUM             reduce using rule 44 (statement -> for_loop .)
    NORMAL          reduce using rule 44 (statement -> for_loop .)
    UNIFORME        reduce using rule 44 (statement -> for_loop .)
    POISSON         reduce using rule 44 (statement -> for_loop .)
    BINOMIAL        reduce using rule 44 (statement -> for_loop .)
    INT             reduce using rule 44 (statement -> for_loop .)
    FLOAT           reduce using rule 44 (statement -> for_loop .)
    CHAR            reduce using rule 44 (statement -> for_loop .)
    BRACKETCLOSE    reduce using rule 44 (statement -> for_loop .)


state 69

    (45) statement -> max .

    IF              reduce using rule 45 (statement -> max .)
    PRINT           reduce using rule 45 (statement -> max .)
    READ            reduce using rule 45 (statement -> max .)
    ID              reduce using rule 45 (statement -> max .)
    PLOT            reduce using rule 45 (statement -> max .)
    RETURN          reduce using rule 45 (statement -> max .)
    WHILE           reduce using rule 45 (statement -> max .)
    FOR             reduce using rule 45 (statement -> max .)
    MAX             reduce using rule 45 (statement -> max .)
    MIN             reduce using rule 45 (statement -> max .)
    SUM             reduce using rule 45 (statement -> max .)
    NORMAL          reduce using rule 45 (statement -> max .)
    UNIFORME        reduce using rule 45 (statement -> max .)
    POISSON         reduce using rule 45 (statement -> max .)
    BINOMIAL        reduce using rule 45 (statement -> max .)
    INT             reduce using rule 45 (statement -> max .)
    FLOAT           reduce using rule 45 (statement -> max .)
    CHAR            reduce using rule 45 (statement -> max .)
    BRACKETCLOSE    reduce using rule 45 (statement -> max .)


state 70

    (46) statement -> min .

    IF              reduce using rule 46 (statement -> min .)
    PRINT           reduce using rule 46 (statement -> min .)
    READ            reduce using rule 46 (statement -> min .)
    ID              reduce using rule 46 (statement -> min .)
    PLOT            reduce using rule 46 (statement -> min .)
    RETURN          reduce using rule 46 (statement -> min .)
    WHILE           reduce using rule 46 (statement -> min .)
    FOR             reduce using rule 46 (statement -> min .)
    MAX             reduce using rule 46 (statement -> min .)
    MIN             reduce using rule 46 (statement -> min .)
    SUM             reduce using rule 46 (statement -> min .)
    NORMAL          reduce using rule 46 (statement -> min .)
    UNIFORME        reduce using rule 46 (statement -> min .)
    POISSON         reduce using rule 46 (statement -> min .)
    BINOMIAL        reduce using rule 46 (statement -> min .)
    INT             reduce using rule 46 (statement -> min .)
    FLOAT           reduce using rule 46 (statement -> min .)
    CHAR            reduce using rule 46 (statement -> min .)
    BRACKETCLOSE    reduce using rule 46 (statement -> min .)


state 71

    (47) statement -> sum .

    IF              reduce using rule 47 (statement -> sum .)
    PRINT           reduce using rule 47 (statement -> sum .)
    READ            reduce using rule 47 (statement -> sum .)
    ID              reduce using rule 47 (statement -> sum .)
    PLOT            reduce using rule 47 (statement -> sum .)
    RETURN          reduce using rule 47 (statement -> sum .)
    WHILE           reduce using rule 47 (statement -> sum .)
    FOR             reduce using rule 47 (statement -> sum .)
    MAX             reduce using rule 47 (statement -> sum .)
    MIN             reduce using rule 47 (statement -> sum .)
    SUM             reduce using rule 47 (statement -> sum .)
    NORMAL          reduce using rule 47 (statement -> sum .)
    UNIFORME        reduce using rule 47 (statement -> sum .)
    POISSON         reduce using rule 47 (statement -> sum .)
    BINOMIAL        reduce using rule 47 (statement -> sum .)
    INT             reduce using rule 47 (statement -> sum .)
    FLOAT           reduce using rule 47 (statement -> sum .)
    CHAR            reduce using rule 47 (statement -> sum .)
    BRACKETCLOSE    reduce using rule 47 (statement -> sum .)


state 72

    (48) statement -> normal .

    IF              reduce using rule 48 (statement -> normal .)
    PRINT           reduce using rule 48 (statement -> normal .)
    READ            reduce using rule 48 (statement -> normal .)
    ID              reduce using rule 48 (statement -> normal .)
    PLOT            reduce using rule 48 (statement -> normal .)
    RETURN          reduce using rule 48 (statement -> normal .)
    WHILE           reduce using rule 48 (statement -> normal .)
    FOR             reduce using rule 48 (statement -> normal .)
    MAX             reduce using rule 48 (statement -> normal .)
    MIN             reduce using rule 48 (statement -> normal .)
    SUM             reduce using rule 48 (statement -> normal .)
    NORMAL          reduce using rule 48 (statement -> normal .)
    UNIFORME        reduce using rule 48 (statement -> normal .)
    POISSON         reduce using rule 48 (statement -> normal .)
    BINOMIAL        reduce using rule 48 (statement -> normal .)
    INT             reduce using rule 48 (statement -> normal .)
    FLOAT           reduce using rule 48 (statement -> normal .)
    CHAR            reduce using rule 48 (statement -> normal .)
    BRACKETCLOSE    reduce using rule 48 (statement -> normal .)


state 73

    (49) statement -> uniforme .

    IF              reduce using rule 49 (statement -> uniforme .)
    PRINT           reduce using rule 49 (statement -> uniforme .)
    READ            reduce using rule 49 (statement -> uniforme .)
    ID              reduce using rule 49 (statement -> uniforme .)
    PLOT            reduce using rule 49 (statement -> uniforme .)
    RETURN          reduce using rule 49 (statement -> uniforme .)
    WHILE           reduce using rule 49 (statement -> uniforme .)
    FOR             reduce using rule 49 (statement -> uniforme .)
    MAX             reduce using rule 49 (statement -> uniforme .)
    MIN             reduce using rule 49 (statement -> uniforme .)
    SUM             reduce using rule 49 (statement -> uniforme .)
    NORMAL          reduce using rule 49 (statement -> uniforme .)
    UNIFORME        reduce using rule 49 (statement -> uniforme .)
    POISSON         reduce using rule 49 (statement -> uniforme .)
    BINOMIAL        reduce using rule 49 (statement -> uniforme .)
    INT             reduce using rule 49 (statement -> uniforme .)
    FLOAT           reduce using rule 49 (statement -> uniforme .)
    CHAR            reduce using rule 49 (statement -> uniforme .)
    BRACKETCLOSE    reduce using rule 49 (statement -> uniforme .)


state 74

    (50) statement -> poisson .

    IF              reduce using rule 50 (statement -> poisson .)
    PRINT           reduce using rule 50 (statement -> poisson .)
    READ            reduce using rule 50 (statement -> poisson .)
    ID              reduce using rule 50 (statement -> poisson .)
    PLOT            reduce using rule 50 (statement -> poisson .)
    RETURN          reduce using rule 50 (statement -> poisson .)
    WHILE           reduce using rule 50 (statement -> poisson .)
    FOR             reduce using rule 50 (statement -> poisson .)
    MAX             reduce using rule 50 (statement -> poisson .)
    MIN             reduce using rule 50 (statement -> poisson .)
    SUM             reduce using rule 50 (statement -> poisson .)
    NORMAL          reduce using rule 50 (statement -> poisson .)
    UNIFORME        reduce using rule 50 (statement -> poisson .)
    POISSON         reduce using rule 50 (statement -> poisson .)
    BINOMIAL        reduce using rule 50 (statement -> poisson .)
    INT             reduce using rule 50 (statement -> poisson .)
    FLOAT           reduce using rule 50 (statement -> poisson .)
    CHAR            reduce using rule 50 (statement -> poisson .)
    BRACKETCLOSE    reduce using rule 50 (statement -> poisson .)


state 75

    (51) statement -> binomial .

    IF              reduce using rule 51 (statement -> binomial .)
    PRINT           reduce using rule 51 (statement -> binomial .)
    READ            reduce using rule 51 (statement -> binomial .)
    ID              reduce using rule 51 (statement -> binomial .)
    PLOT            reduce using rule 51 (statement -> binomial .)
    RETURN          reduce using rule 51 (statement -> binomial .)
    WHILE           reduce using rule 51 (statement -> binomial .)
    FOR             reduce using rule 51 (statement -> binomial .)
    MAX             reduce using rule 51 (statement -> binomial .)
    MIN             reduce using rule 51 (statement -> binomial .)
    SUM             reduce using rule 51 (statement -> binomial .)
    NORMAL          reduce using rule 51 (statement -> binomial .)
    UNIFORME        reduce using rule 51 (statement -> binomial .)
    POISSON         reduce using rule 51 (statement -> binomial .)
    BINOMIAL        reduce using rule 51 (statement -> binomial .)
    INT             reduce using rule 51 (statement -> binomial .)
    FLOAT           reduce using rule 51 (statement -> binomial .)
    CHAR            reduce using rule 51 (statement -> binomial .)
    BRACKETCLOSE    reduce using rule 51 (statement -> binomial .)


state 76

    (52) dec_variables -> dec_variabless .

    IF              reduce using rule 52 (dec_variables -> dec_variabless .)
    PRINT           reduce using rule 52 (dec_variables -> dec_variabless .)
    READ            reduce using rule 52 (dec_variables -> dec_variabless .)
    ID              reduce using rule 52 (dec_variables -> dec_variabless .)
    PLOT            reduce using rule 52 (dec_variables -> dec_variabless .)
    RETURN          reduce using rule 52 (dec_variables -> dec_variabless .)
    WHILE           reduce using rule 52 (dec_variables -> dec_variabless .)
    FOR             reduce using rule 52 (dec_variables -> dec_variabless .)
    MAX             reduce using rule 52 (dec_variables -> dec_variabless .)
    MIN             reduce using rule 52 (dec_variables -> dec_variabless .)
    SUM             reduce using rule 52 (dec_variables -> dec_variabless .)
    NORMAL          reduce using rule 52 (dec_variables -> dec_variabless .)
    UNIFORME        reduce using rule 52 (dec_variables -> dec_variabless .)
    POISSON         reduce using rule 52 (dec_variables -> dec_variabless .)
    BINOMIAL        reduce using rule 52 (dec_variables -> dec_variabless .)
    INT             reduce using rule 52 (dec_variables -> dec_variabless .)
    FLOAT           reduce using rule 52 (dec_variables -> dec_variabless .)
    CHAR            reduce using rule 52 (dec_variables -> dec_variabless .)
    BRACKETCLOSE    reduce using rule 52 (dec_variables -> dec_variabless .)


state 77

    (61) assignment -> variable . EQUAL exp SEMICOLON

    EQUAL           shift and go to state 102


state 78

    (97) condition -> IF . PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
    (98) condition -> IF . PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse

    PARENOPEN       shift and go to state 103


state 79

    (103) writing -> PRINT . PARENOPEN writingg PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 104


state 80

    (109) reading -> READ . multivariables SEMICOLON
    (110) multivariables -> . variable
    (111) multivariables -> . variable COLON multivariables
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 95

    multivariables                 shift and go to state 105
    variable                       shift and go to state 106

state 81

    (62) call_func -> ID . PARENOPEN call_funcc PARENCLOSE
    (94) variable -> ID .
    (95) variable -> ID . BRACEOPEN exp BRACECLOSE
    (96) variable -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    PARENOPEN       shift and go to state 107
    EQUAL           reduce using rule 94 (variable -> ID .)
    BRACEOPEN       shift and go to state 108


state 82

    (66) graph -> PLOT . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 109


state 83

    (119) return -> RETURN . exp SEMICOLON
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 110
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 84

    (112) while_loop -> WHILE . whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (113) whileMigaja -> . empty
    (129) empty -> .

    PARENOPEN       reduce using rule 129 (empty -> .)

    whileMigaja                    shift and go to state 120
    empty                          shift and go to state 121

state 85

    (116) for_loop -> FOR . PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd

    PARENOPEN       shift and go to state 122


state 86

    (120) max -> MAX . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 123


state 87

    (121) min -> MIN . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 124


state 88

    (122) sum -> SUM . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 125


state 89

    (128) normal -> NORMAL . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 126


state 90

    (127) uniforme -> UNIFORME . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 127


state 91

    (126) poisson -> POISSON . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 128


state 92

    (125) binomial -> BINOMIAL . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 129


state 93

    (53) dec_variabless -> type . guardarTipo dec_mvar SEMICOLON dec_variabless
    (54) dec_variabless -> type . guardarTipo dec_mvar SEMICOLON
    (14) guardarTipo -> . empty
    (129) empty -> .

    ID              reduce using rule 129 (empty -> .)

    guardarTipo                    shift and go to state 130
    empty                          shift and go to state 29

state 94

    (25) param -> type variable .
    (26) param -> type variable . COLON param

    PARENCLOSE      reduce using rule 25 (param -> type variable .)
    COLON           shift and go to state 131


state 95

    (94) variable -> ID .
    (95) variable -> ID . BRACEOPEN exp BRACECLOSE
    (96) variable -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    COLON           reduce using rule 94 (variable -> ID .)
    PARENCLOSE      reduce using rule 94 (variable -> ID .)
    SEMICOLON       reduce using rule 94 (variable -> ID .)
    EQUAL           reduce using rule 94 (variable -> ID .)
    BRACEOPEN       shift and go to state 108


state 96

    (21) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE . body exitFunc
    (31) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 132

state 97

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE . body exitFunc
    (31) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 133

state 98

    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE COLON mvar
    (20) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE

    CTEINT          shift and go to state 134


state 99

    (16) mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON . mvar
    (15) mvar -> . ID COLON mvar
    (16) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> . ID
    (19) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (20) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 34

    mvar                           shift and go to state 135

state 100

    (31) body -> BRACKETOPEN bodyy BRACKETCLOSE .

    $end            reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FUNCTION        reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MAIN            reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    ELSE            reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    IF              reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    PRINT           reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    READ            reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    ID              reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    PLOT            reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    RETURN          reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    WHILE           reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FOR             reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MAX             reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MIN             reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    SUM             reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    NORMAL          reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    UNIFORME        reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    POISSON         reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    BINOMIAL        reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    INT             reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FLOAT           reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    CHAR            reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    BRACKETCLOSE    reduce using rule 31 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)


state 101

    (33) bodyy -> statement bodyy .

    BRACKETCLOSE    reduce using rule 33 (bodyy -> statement bodyy .)


state 102

    (61) assignment -> variable EQUAL . exp SEMICOLON
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    variable                       shift and go to state 118
    exp                            shift and go to state 136
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    call_func                      shift and go to state 119

state 103

    (97) condition -> IF PARENOPEN . exp PARENCLOSE cuadruploIF body ifEnd
    (98) condition -> IF PARENOPEN . exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 137
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 104

    (103) writing -> PRINT PARENOPEN . writingg PARENCLOSE SEMICOLON
    (104) writingg -> . exp
    (105) writingg -> . exp COLON writingg
    (106) writingg -> . auxString
    (107) writingg -> . auxString COLON writingg
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (108) auxString -> . CTESTRING
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 141
    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    writingg                       shift and go to state 138
    exp                            shift and go to state 139
    auxString                      shift and go to state 140
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 105

    (109) reading -> READ multivariables . SEMICOLON

    SEMICOLON       shift and go to state 142


state 106

    (110) multivariables -> variable .
    (111) multivariables -> variable . COLON multivariables

    SEMICOLON       reduce using rule 110 (multivariables -> variable .)
    COLON           shift and go to state 143


state 107

    (62) call_func -> ID PARENOPEN . call_funcc PARENCLOSE
    (63) call_funcc -> . exp
    (64) call_funcc -> . exp COLON call_funcc
    (65) call_funcc -> . empty
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (129) empty -> .
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENCLOSE      reduce using rule 129 (empty -> .)
    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    call_funcc                     shift and go to state 144
    exp                            shift and go to state 145
    empty                          shift and go to state 146
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 108

    (95) variable -> ID BRACEOPEN . exp BRACECLOSE
    (96) variable -> ID BRACEOPEN . exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 147
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 109

    (66) graph -> PLOT PARENOPEN . exp PARENCLOSE SEMICOLON
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 148
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 110

    (119) return -> RETURN exp . SEMICOLON
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

    SEMICOLON       shift and go to state 149
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157


state 111

    (75) exp -> m_exp .

    SEMICOLON       reduce using rule 75 (exp -> m_exp .)
    GREATHERTHAN    reduce using rule 75 (exp -> m_exp .)
    LESSTHAN        reduce using rule 75 (exp -> m_exp .)
    GREATHEREQUAL   reduce using rule 75 (exp -> m_exp .)
    LESSEQUAL       reduce using rule 75 (exp -> m_exp .)
    DIFFERENT       reduce using rule 75 (exp -> m_exp .)
    SAME            reduce using rule 75 (exp -> m_exp .)
    AND             reduce using rule 75 (exp -> m_exp .)
    OR              reduce using rule 75 (exp -> m_exp .)
    PARENCLOSE      reduce using rule 75 (exp -> m_exp .)
    COLON           reduce using rule 75 (exp -> m_exp .)
    BRACECLOSE      reduce using rule 75 (exp -> m_exp .)
    TO              reduce using rule 75 (exp -> m_exp .)


state 112

    (76) m_exp -> t . m_expp
    (77) m_expp -> . PLUS appendPLUS m_exp
    (78) m_expp -> . MINUS appendMINUS m_exp
    (79) m_expp -> . empty
    (129) empty -> .

    PLUS            shift and go to state 159
    MINUS           shift and go to state 160
    SEMICOLON       reduce using rule 129 (empty -> .)
    GREATHERTHAN    reduce using rule 129 (empty -> .)
    LESSTHAN        reduce using rule 129 (empty -> .)
    GREATHEREQUAL   reduce using rule 129 (empty -> .)
    LESSEQUAL       reduce using rule 129 (empty -> .)
    DIFFERENT       reduce using rule 129 (empty -> .)
    SAME            reduce using rule 129 (empty -> .)
    AND             reduce using rule 129 (empty -> .)
    OR              reduce using rule 129 (empty -> .)
    PARENCLOSE      reduce using rule 129 (empty -> .)
    COLON           reduce using rule 129 (empty -> .)
    BRACECLOSE      reduce using rule 129 (empty -> .)
    TO              reduce using rule 129 (empty -> .)

    m_expp                         shift and go to state 158
    empty                          shift and go to state 161

state 113

    (84) t -> f . termino
    (85) termino -> . MULTIPLY appendMULTIPLY t
    (86) termino -> . DIVIDE appendDIVIDE t
    (87) termino -> . empty
    (129) empty -> .

    MULTIPLY        shift and go to state 163
    DIVIDE          shift and go to state 164
    PLUS            reduce using rule 129 (empty -> .)
    MINUS           reduce using rule 129 (empty -> .)
    SEMICOLON       reduce using rule 129 (empty -> .)
    GREATHERTHAN    reduce using rule 129 (empty -> .)
    LESSTHAN        reduce using rule 129 (empty -> .)
    GREATHEREQUAL   reduce using rule 129 (empty -> .)
    LESSEQUAL       reduce using rule 129 (empty -> .)
    DIFFERENT       reduce using rule 129 (empty -> .)
    SAME            reduce using rule 129 (empty -> .)
    AND             reduce using rule 129 (empty -> .)
    OR              reduce using rule 129 (empty -> .)
    PARENCLOSE      reduce using rule 129 (empty -> .)
    COLON           reduce using rule 129 (empty -> .)
    BRACECLOSE      reduce using rule 129 (empty -> .)
    TO              reduce using rule 129 (empty -> .)

    termino                        shift and go to state 162
    empty                          shift and go to state 165

state 114

    (88) f -> PARENOPEN . exp PARENCLOSE
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 166
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 115

    (89) f -> ID .
    (94) variable -> ID .
    (95) variable -> ID . BRACEOPEN exp BRACECLOSE
    (96) variable -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> ID . PARENOPEN call_funcc PARENCLOSE

  ! reduce/reduce conflict for MULTIPLY resolved using rule 89 (f -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 89 (f -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 89 (f -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 89 (f -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 89 (f -> ID .)
  ! reduce/reduce conflict for GREATHERTHAN resolved using rule 89 (f -> ID .)
  ! reduce/reduce conflict for LESSTHAN resolved using rule 89 (f -> ID .)
  ! reduce/reduce conflict for GREATHEREQUAL resolved using rule 89 (f -> ID .)
  ! reduce/reduce conflict for LESSEQUAL resolved using rule 89 (f -> ID .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 89 (f -> ID .)
  ! reduce/reduce conflict for SAME resolved using rule 89 (f -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 89 (f -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 89 (f -> ID .)
  ! reduce/reduce conflict for PARENCLOSE resolved using rule 89 (f -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 89 (f -> ID .)
  ! reduce/reduce conflict for BRACECLOSE resolved using rule 89 (f -> ID .)
  ! reduce/reduce conflict for TO resolved using rule 89 (f -> ID .)
    MULTIPLY        reduce using rule 89 (f -> ID .)
    DIVIDE          reduce using rule 89 (f -> ID .)
    PLUS            reduce using rule 89 (f -> ID .)
    MINUS           reduce using rule 89 (f -> ID .)
    SEMICOLON       reduce using rule 89 (f -> ID .)
    GREATHERTHAN    reduce using rule 89 (f -> ID .)
    LESSTHAN        reduce using rule 89 (f -> ID .)
    GREATHEREQUAL   reduce using rule 89 (f -> ID .)
    LESSEQUAL       reduce using rule 89 (f -> ID .)
    DIFFERENT       reduce using rule 89 (f -> ID .)
    SAME            reduce using rule 89 (f -> ID .)
    AND             reduce using rule 89 (f -> ID .)
    OR              reduce using rule 89 (f -> ID .)
    PARENCLOSE      reduce using rule 89 (f -> ID .)
    COLON           reduce using rule 89 (f -> ID .)
    BRACECLOSE      reduce using rule 89 (f -> ID .)
    TO              reduce using rule 89 (f -> ID .)
    BRACEOPEN       shift and go to state 108
    PARENOPEN       shift and go to state 107

  ! MULTIPLY        [ reduce using rule 94 (variable -> ID .) ]
  ! DIVIDE          [ reduce using rule 94 (variable -> ID .) ]
  ! PLUS            [ reduce using rule 94 (variable -> ID .) ]
  ! MINUS           [ reduce using rule 94 (variable -> ID .) ]
  ! SEMICOLON       [ reduce using rule 94 (variable -> ID .) ]
  ! GREATHERTHAN    [ reduce using rule 94 (variable -> ID .) ]
  ! LESSTHAN        [ reduce using rule 94 (variable -> ID .) ]
  ! GREATHEREQUAL   [ reduce using rule 94 (variable -> ID .) ]
  ! LESSEQUAL       [ reduce using rule 94 (variable -> ID .) ]
  ! DIFFERENT       [ reduce using rule 94 (variable -> ID .) ]
  ! SAME            [ reduce using rule 94 (variable -> ID .) ]
  ! AND             [ reduce using rule 94 (variable -> ID .) ]
  ! OR              [ reduce using rule 94 (variable -> ID .) ]
  ! PARENCLOSE      [ reduce using rule 94 (variable -> ID .) ]
  ! COLON           [ reduce using rule 94 (variable -> ID .) ]
  ! BRACECLOSE      [ reduce using rule 94 (variable -> ID .) ]
  ! TO              [ reduce using rule 94 (variable -> ID .) ]


state 116

    (90) f -> CTEINT .

    MULTIPLY        reduce using rule 90 (f -> CTEINT .)
    DIVIDE          reduce using rule 90 (f -> CTEINT .)
    PLUS            reduce using rule 90 (f -> CTEINT .)
    MINUS           reduce using rule 90 (f -> CTEINT .)
    SEMICOLON       reduce using rule 90 (f -> CTEINT .)
    GREATHERTHAN    reduce using rule 90 (f -> CTEINT .)
    LESSTHAN        reduce using rule 90 (f -> CTEINT .)
    GREATHEREQUAL   reduce using rule 90 (f -> CTEINT .)
    LESSEQUAL       reduce using rule 90 (f -> CTEINT .)
    DIFFERENT       reduce using rule 90 (f -> CTEINT .)
    SAME            reduce using rule 90 (f -> CTEINT .)
    AND             reduce using rule 90 (f -> CTEINT .)
    OR              reduce using rule 90 (f -> CTEINT .)
    PARENCLOSE      reduce using rule 90 (f -> CTEINT .)
    COLON           reduce using rule 90 (f -> CTEINT .)
    BRACECLOSE      reduce using rule 90 (f -> CTEINT .)
    TO              reduce using rule 90 (f -> CTEINT .)


state 117

    (91) f -> CTFLOAT .

    MULTIPLY        reduce using rule 91 (f -> CTFLOAT .)
    DIVIDE          reduce using rule 91 (f -> CTFLOAT .)
    PLUS            reduce using rule 91 (f -> CTFLOAT .)
    MINUS           reduce using rule 91 (f -> CTFLOAT .)
    SEMICOLON       reduce using rule 91 (f -> CTFLOAT .)
    GREATHERTHAN    reduce using rule 91 (f -> CTFLOAT .)
    LESSTHAN        reduce using rule 91 (f -> CTFLOAT .)
    GREATHEREQUAL   reduce using rule 91 (f -> CTFLOAT .)
    LESSEQUAL       reduce using rule 91 (f -> CTFLOAT .)
    DIFFERENT       reduce using rule 91 (f -> CTFLOAT .)
    SAME            reduce using rule 91 (f -> CTFLOAT .)
    AND             reduce using rule 91 (f -> CTFLOAT .)
    OR              reduce using rule 91 (f -> CTFLOAT .)
    PARENCLOSE      reduce using rule 91 (f -> CTFLOAT .)
    COLON           reduce using rule 91 (f -> CTFLOAT .)
    BRACECLOSE      reduce using rule 91 (f -> CTFLOAT .)
    TO              reduce using rule 91 (f -> CTFLOAT .)


state 118

    (92) f -> variable .

    MULTIPLY        reduce using rule 92 (f -> variable .)
    DIVIDE          reduce using rule 92 (f -> variable .)
    PLUS            reduce using rule 92 (f -> variable .)
    MINUS           reduce using rule 92 (f -> variable .)
    SEMICOLON       reduce using rule 92 (f -> variable .)
    GREATHERTHAN    reduce using rule 92 (f -> variable .)
    LESSTHAN        reduce using rule 92 (f -> variable .)
    GREATHEREQUAL   reduce using rule 92 (f -> variable .)
    LESSEQUAL       reduce using rule 92 (f -> variable .)
    DIFFERENT       reduce using rule 92 (f -> variable .)
    SAME            reduce using rule 92 (f -> variable .)
    AND             reduce using rule 92 (f -> variable .)
    OR              reduce using rule 92 (f -> variable .)
    PARENCLOSE      reduce using rule 92 (f -> variable .)
    COLON           reduce using rule 92 (f -> variable .)
    BRACECLOSE      reduce using rule 92 (f -> variable .)
    TO              reduce using rule 92 (f -> variable .)


state 119

    (93) f -> call_func .

    MULTIPLY        reduce using rule 93 (f -> call_func .)
    DIVIDE          reduce using rule 93 (f -> call_func .)
    PLUS            reduce using rule 93 (f -> call_func .)
    MINUS           reduce using rule 93 (f -> call_func .)
    SEMICOLON       reduce using rule 93 (f -> call_func .)
    GREATHERTHAN    reduce using rule 93 (f -> call_func .)
    LESSTHAN        reduce using rule 93 (f -> call_func .)
    GREATHEREQUAL   reduce using rule 93 (f -> call_func .)
    LESSEQUAL       reduce using rule 93 (f -> call_func .)
    DIFFERENT       reduce using rule 93 (f -> call_func .)
    SAME            reduce using rule 93 (f -> call_func .)
    AND             reduce using rule 93 (f -> call_func .)
    OR              reduce using rule 93 (f -> call_func .)
    PARENCLOSE      reduce using rule 93 (f -> call_func .)
    COLON           reduce using rule 93 (f -> call_func .)
    BRACECLOSE      reduce using rule 93 (f -> call_func .)
    TO              reduce using rule 93 (f -> call_func .)


state 120

    (112) while_loop -> WHILE whileMigaja . PARENOPEN exp PARENCLOSE whileEval body whileEnd

    PARENOPEN       shift and go to state 167


state 121

    (113) whileMigaja -> empty .

    PARENOPEN       reduce using rule 113 (whileMigaja -> empty .)


state 122

    (116) for_loop -> FOR PARENOPEN . variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 95

    variable                       shift and go to state 168

state 123

    (120) max -> MAX PARENOPEN . exp PARENCLOSE SEMICOLON
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 169
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 124

    (121) min -> MIN PARENOPEN . exp PARENCLOSE SEMICOLON
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 170
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 125

    (122) sum -> SUM PARENOPEN . exp PARENCLOSE SEMICOLON
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 171
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 126

    (128) normal -> NORMAL PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (123) param_dist -> . variable
    (124) param_dist -> . variable COLON param_dist
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 95

    param_dist                     shift and go to state 172
    variable                       shift and go to state 173

state 127

    (127) uniforme -> UNIFORME PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (123) param_dist -> . variable
    (124) param_dist -> . variable COLON param_dist
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 95

    param_dist                     shift and go to state 174
    variable                       shift and go to state 173

state 128

    (126) poisson -> POISSON PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (123) param_dist -> . variable
    (124) param_dist -> . variable COLON param_dist
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 95

    param_dist                     shift and go to state 175
    variable                       shift and go to state 173

state 129

    (125) binomial -> BINOMIAL PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (123) param_dist -> . variable
    (124) param_dist -> . variable COLON param_dist
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 95

    param_dist                     shift and go to state 176
    variable                       shift and go to state 173

state 130

    (53) dec_variabless -> type guardarTipo . dec_mvar SEMICOLON dec_variabless
    (54) dec_variabless -> type guardarTipo . dec_mvar SEMICOLON
    (55) dec_mvar -> . ID COLON dec_mvar
    (56) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (57) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (58) dec_mvar -> . ID
    (59) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (60) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 178

    dec_mvar                       shift and go to state 177

state 131

    (26) param -> type variable COLON . param
    (25) param -> . type variable
    (26) param -> . type variable COLON param
    (27) param -> . empty
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . CHAR
    (129) empty -> .

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21
    PARENCLOSE      reduce using rule 129 (empty -> .)

    type                           shift and go to state 51
    param                          shift and go to state 179
    empty                          shift and go to state 53

state 132

    (21) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body . exitFunc
    (24) exitFunc -> . empty
    (129) empty -> .

    FUNCTION        reduce using rule 129 (empty -> .)
    MAIN            reduce using rule 129 (empty -> .)

    exitFunc                       shift and go to state 180
    empty                          shift and go to state 181

state 133

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body . exitFunc
    (24) exitFunc -> . empty
    (129) empty -> .

    FUNCTION        reduce using rule 129 (empty -> .)
    MAIN            reduce using rule 129 (empty -> .)

    exitFunc                       shift and go to state 182
    empty                          shift and go to state 181

state 134

    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE COLON mvar
    (20) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE

    BRACECLOSE      shift and go to state 183


state 135

    (16) mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON mvar .

    SEMICOLON       reduce using rule 16 (mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON mvar .)


state 136

    (61) assignment -> variable EQUAL exp . SEMICOLON
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

    SEMICOLON       shift and go to state 184
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157


state 137

    (97) condition -> IF PARENOPEN exp . PARENCLOSE cuadruploIF body ifEnd
    (98) condition -> IF PARENOPEN exp . PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

    PARENCLOSE      shift and go to state 185
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157


state 138

    (103) writing -> PRINT PARENOPEN writingg . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 186


state 139

    (104) writingg -> exp .
    (105) writingg -> exp . COLON writingg
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

    PARENCLOSE      reduce using rule 104 (writingg -> exp .)
    COLON           shift and go to state 187
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157


state 140

    (106) writingg -> auxString .
    (107) writingg -> auxString . COLON writingg

    PARENCLOSE      reduce using rule 106 (writingg -> auxString .)
    COLON           shift and go to state 188


state 141

    (108) auxString -> CTESTRING .

    COLON           reduce using rule 108 (auxString -> CTESTRING .)
    PARENCLOSE      reduce using rule 108 (auxString -> CTESTRING .)


state 142

    (109) reading -> READ multivariables SEMICOLON .

    IF              reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    PRINT           reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    READ            reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    ID              reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    PLOT            reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    RETURN          reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    WHILE           reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    FOR             reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    MAX             reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    MIN             reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    SUM             reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    NORMAL          reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    UNIFORME        reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    POISSON         reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    BINOMIAL        reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    INT             reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    FLOAT           reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    CHAR            reduce using rule 109 (reading -> READ multivariables SEMICOLON .)
    BRACKETCLOSE    reduce using rule 109 (reading -> READ multivariables SEMICOLON .)


state 143

    (111) multivariables -> variable COLON . multivariables
    (110) multivariables -> . variable
    (111) multivariables -> . variable COLON multivariables
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 95

    variable                       shift and go to state 106
    multivariables                 shift and go to state 189

state 144

    (62) call_func -> ID PARENOPEN call_funcc . PARENCLOSE

    PARENCLOSE      shift and go to state 190


state 145

    (63) call_funcc -> exp .
    (64) call_funcc -> exp . COLON call_funcc
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

    PARENCLOSE      reduce using rule 63 (call_funcc -> exp .)
    COLON           shift and go to state 191
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157


state 146

    (65) call_funcc -> empty .

    PARENCLOSE      reduce using rule 65 (call_funcc -> empty .)


state 147

    (95) variable -> ID BRACEOPEN exp . BRACECLOSE
    (96) variable -> ID BRACEOPEN exp . BRACECLOSE BRACEOPEN exp BRACECLOSE
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

    BRACECLOSE      shift and go to state 192
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157


state 148

    (66) graph -> PLOT PARENOPEN exp . PARENCLOSE SEMICOLON
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

    PARENCLOSE      shift and go to state 193
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157


state 149

    (119) return -> RETURN exp SEMICOLON .

    IF              reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    PRINT           reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    READ            reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    ID              reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    PLOT            reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    RETURN          reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    WHILE           reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    FOR             reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    MAX             reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    MIN             reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    SUM             reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    NORMAL          reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    UNIFORME        reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    POISSON         reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    BINOMIAL        reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    INT             reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    FLOAT           reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    CHAR            reduce using rule 119 (return -> RETURN exp SEMICOLON .)
    BRACKETCLOSE    reduce using rule 119 (return -> RETURN exp SEMICOLON .)


state 150

    (67) exp -> exp GREATHERTHAN . exp
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 194
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 151

    (68) exp -> exp LESSTHAN . exp
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 195
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 152

    (69) exp -> exp GREATHEREQUAL . exp
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 196
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 153

    (70) exp -> exp LESSEQUAL . exp
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 197
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 154

    (71) exp -> exp DIFFERENT . exp
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 198
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 155

    (72) exp -> exp SAME . exp
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 199
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 156

    (73) exp -> exp AND . exp
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 200
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 157

    (74) exp -> exp OR . exp
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 201
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 158

    (76) m_exp -> t m_expp .

    SEMICOLON       reduce using rule 76 (m_exp -> t m_expp .)
    GREATHERTHAN    reduce using rule 76 (m_exp -> t m_expp .)
    LESSTHAN        reduce using rule 76 (m_exp -> t m_expp .)
    GREATHEREQUAL   reduce using rule 76 (m_exp -> t m_expp .)
    LESSEQUAL       reduce using rule 76 (m_exp -> t m_expp .)
    DIFFERENT       reduce using rule 76 (m_exp -> t m_expp .)
    SAME            reduce using rule 76 (m_exp -> t m_expp .)
    AND             reduce using rule 76 (m_exp -> t m_expp .)
    OR              reduce using rule 76 (m_exp -> t m_expp .)
    PARENCLOSE      reduce using rule 76 (m_exp -> t m_expp .)
    COLON           reduce using rule 76 (m_exp -> t m_expp .)
    BRACECLOSE      reduce using rule 76 (m_exp -> t m_expp .)
    TO              reduce using rule 76 (m_exp -> t m_expp .)


state 159

    (77) m_expp -> PLUS . appendPLUS m_exp
    (80) appendPLUS -> . empty
    (129) empty -> .

    PARENOPEN       reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    CTEINT          reduce using rule 129 (empty -> .)
    CTFLOAT         reduce using rule 129 (empty -> .)

    appendPLUS                     shift and go to state 202
    empty                          shift and go to state 203

state 160

    (78) m_expp -> MINUS . appendMINUS m_exp
    (81) appendMINUS -> . empty
    (129) empty -> .

    PARENOPEN       reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    CTEINT          reduce using rule 129 (empty -> .)
    CTFLOAT         reduce using rule 129 (empty -> .)

    appendMINUS                    shift and go to state 204
    empty                          shift and go to state 205

state 161

    (79) m_expp -> empty .

    SEMICOLON       reduce using rule 79 (m_expp -> empty .)
    GREATHERTHAN    reduce using rule 79 (m_expp -> empty .)
    LESSTHAN        reduce using rule 79 (m_expp -> empty .)
    GREATHEREQUAL   reduce using rule 79 (m_expp -> empty .)
    LESSEQUAL       reduce using rule 79 (m_expp -> empty .)
    DIFFERENT       reduce using rule 79 (m_expp -> empty .)
    SAME            reduce using rule 79 (m_expp -> empty .)
    AND             reduce using rule 79 (m_expp -> empty .)
    OR              reduce using rule 79 (m_expp -> empty .)
    PARENCLOSE      reduce using rule 79 (m_expp -> empty .)
    COLON           reduce using rule 79 (m_expp -> empty .)
    BRACECLOSE      reduce using rule 79 (m_expp -> empty .)
    TO              reduce using rule 79 (m_expp -> empty .)


state 162

    (84) t -> f termino .

    PLUS            reduce using rule 84 (t -> f termino .)
    MINUS           reduce using rule 84 (t -> f termino .)
    SEMICOLON       reduce using rule 84 (t -> f termino .)
    GREATHERTHAN    reduce using rule 84 (t -> f termino .)
    LESSTHAN        reduce using rule 84 (t -> f termino .)
    GREATHEREQUAL   reduce using rule 84 (t -> f termino .)
    LESSEQUAL       reduce using rule 84 (t -> f termino .)
    DIFFERENT       reduce using rule 84 (t -> f termino .)
    SAME            reduce using rule 84 (t -> f termino .)
    AND             reduce using rule 84 (t -> f termino .)
    OR              reduce using rule 84 (t -> f termino .)
    PARENCLOSE      reduce using rule 84 (t -> f termino .)
    COLON           reduce using rule 84 (t -> f termino .)
    BRACECLOSE      reduce using rule 84 (t -> f termino .)
    TO              reduce using rule 84 (t -> f termino .)


state 163

    (85) termino -> MULTIPLY . appendMULTIPLY t
    (82) appendMULTIPLY -> . empty
    (129) empty -> .

    PARENOPEN       reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    CTEINT          reduce using rule 129 (empty -> .)
    CTFLOAT         reduce using rule 129 (empty -> .)

    appendMULTIPLY                 shift and go to state 206
    empty                          shift and go to state 207

state 164

    (86) termino -> DIVIDE . appendDIVIDE t
    (83) appendDIVIDE -> . empty
    (129) empty -> .

    PARENOPEN       reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    CTEINT          reduce using rule 129 (empty -> .)
    CTFLOAT         reduce using rule 129 (empty -> .)

    appendDIVIDE                   shift and go to state 208
    empty                          shift and go to state 209

state 165

    (87) termino -> empty .

    PLUS            reduce using rule 87 (termino -> empty .)
    MINUS           reduce using rule 87 (termino -> empty .)
    SEMICOLON       reduce using rule 87 (termino -> empty .)
    GREATHERTHAN    reduce using rule 87 (termino -> empty .)
    LESSTHAN        reduce using rule 87 (termino -> empty .)
    GREATHEREQUAL   reduce using rule 87 (termino -> empty .)
    LESSEQUAL       reduce using rule 87 (termino -> empty .)
    DIFFERENT       reduce using rule 87 (termino -> empty .)
    SAME            reduce using rule 87 (termino -> empty .)
    AND             reduce using rule 87 (termino -> empty .)
    OR              reduce using rule 87 (termino -> empty .)
    PARENCLOSE      reduce using rule 87 (termino -> empty .)
    COLON           reduce using rule 87 (termino -> empty .)
    BRACECLOSE      reduce using rule 87 (termino -> empty .)
    TO              reduce using rule 87 (termino -> empty .)


state 166

    (88) f -> PARENOPEN exp . PARENCLOSE
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

    PARENCLOSE      shift and go to state 210
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157


state 167

    (112) while_loop -> WHILE whileMigaja PARENOPEN . exp PARENCLOSE whileEval body whileEnd
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 211
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 168

    (116) for_loop -> FOR PARENOPEN variable . EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd

    EQUAL           shift and go to state 212


state 169

    (120) max -> MAX PARENOPEN exp . PARENCLOSE SEMICOLON
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

    PARENCLOSE      shift and go to state 213
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157


state 170

    (121) min -> MIN PARENOPEN exp . PARENCLOSE SEMICOLON
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

    PARENCLOSE      shift and go to state 214
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157


state 171

    (122) sum -> SUM PARENOPEN exp . PARENCLOSE SEMICOLON
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

    PARENCLOSE      shift and go to state 215
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157


state 172

    (128) normal -> NORMAL PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 216


state 173

    (123) param_dist -> variable .
    (124) param_dist -> variable . COLON param_dist

    PARENCLOSE      reduce using rule 123 (param_dist -> variable .)
    COLON           shift and go to state 217


state 174

    (127) uniforme -> UNIFORME PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 218


state 175

    (126) poisson -> POISSON PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 219


state 176

    (125) binomial -> BINOMIAL PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 220


state 177

    (53) dec_variabless -> type guardarTipo dec_mvar . SEMICOLON dec_variabless
    (54) dec_variabless -> type guardarTipo dec_mvar . SEMICOLON

    SEMICOLON       shift and go to state 221


state 178

    (55) dec_mvar -> ID . COLON dec_mvar
    (56) dec_mvar -> ID . BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (57) dec_mvar -> ID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (58) dec_mvar -> ID .
    (59) dec_mvar -> ID . BRACEOPEN CTEINT BRACECLOSE
    (60) dec_mvar -> ID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 222
    BRACEOPEN       shift and go to state 223
    SEMICOLON       reduce using rule 58 (dec_mvar -> ID .)


state 179

    (26) param -> type variable COLON param .

    PARENCLOSE      reduce using rule 26 (param -> type variable COLON param .)


state 180

    (21) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .

    FUNCTION        reduce using rule 21 (dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .)
    MAIN            reduce using rule 21 (dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .)


state 181

    (24) exitFunc -> empty .

    FUNCTION        reduce using rule 24 (exitFunc -> empty .)
    MAIN            reduce using rule 24 (exitFunc -> empty .)


state 182

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .

    FUNCTION        reduce using rule 22 (dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .)
    MAIN            reduce using rule 22 (dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .)


state 183

    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE . COLON mvar
    (20) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .

    COLON           shift and go to state 224
    SEMICOLON       reduce using rule 20 (mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .)


state 184

    (61) assignment -> variable EQUAL exp SEMICOLON .

    IF              reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    PRINT           reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    READ            reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    ID              reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    PLOT            reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    RETURN          reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    WHILE           reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    FOR             reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    MAX             reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    MIN             reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    SUM             reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    NORMAL          reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    UNIFORME        reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    POISSON         reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    BINOMIAL        reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    INT             reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    FLOAT           reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    CHAR            reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)
    BRACKETCLOSE    reduce using rule 61 (assignment -> variable EQUAL exp SEMICOLON .)


state 185

    (97) condition -> IF PARENOPEN exp PARENCLOSE . cuadruploIF body ifEnd
    (98) condition -> IF PARENOPEN exp PARENCLOSE . cuadruploIF body cuadruploElse ELSE body ifEndElse
    (99) cuadruploIF -> . empty
    (129) empty -> .

    BRACKETOPEN     reduce using rule 129 (empty -> .)

    cuadruploIF                    shift and go to state 225
    empty                          shift and go to state 226

state 186

    (103) writing -> PRINT PARENOPEN writingg PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 227


state 187

    (105) writingg -> exp COLON . writingg
    (104) writingg -> . exp
    (105) writingg -> . exp COLON writingg
    (106) writingg -> . auxString
    (107) writingg -> . auxString COLON writingg
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (108) auxString -> . CTESTRING
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 141
    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 139
    writingg                       shift and go to state 228
    auxString                      shift and go to state 140
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 188

    (107) writingg -> auxString COLON . writingg
    (104) writingg -> . exp
    (105) writingg -> . exp COLON writingg
    (106) writingg -> . auxString
    (107) writingg -> . auxString COLON writingg
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (108) auxString -> . CTESTRING
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 141
    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    auxString                      shift and go to state 140
    writingg                       shift and go to state 229
    exp                            shift and go to state 139
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 189

    (111) multivariables -> variable COLON multivariables .

    SEMICOLON       reduce using rule 111 (multivariables -> variable COLON multivariables .)


state 190

    (62) call_func -> ID PARENOPEN call_funcc PARENCLOSE .

    IF              reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    PRINT           reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    READ            reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    ID              reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    PLOT            reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    RETURN          reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    WHILE           reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    FOR             reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    MAX             reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    MIN             reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    SUM             reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    NORMAL          reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    UNIFORME        reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    POISSON         reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    BINOMIAL        reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    INT             reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    FLOAT           reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    CHAR            reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    BRACKETCLOSE    reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    MULTIPLY        reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    DIVIDE          reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    PLUS            reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    MINUS           reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    SEMICOLON       reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    GREATHERTHAN    reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    LESSTHAN        reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    GREATHEREQUAL   reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    LESSEQUAL       reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    DIFFERENT       reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    SAME            reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    AND             reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    OR              reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    PARENCLOSE      reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    COLON           reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    BRACECLOSE      reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    TO              reduce using rule 62 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)


state 191

    (64) call_funcc -> exp COLON . call_funcc
    (63) call_funcc -> . exp
    (64) call_funcc -> . exp COLON call_funcc
    (65) call_funcc -> . empty
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (129) empty -> .
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENCLOSE      reduce using rule 129 (empty -> .)
    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 145
    call_funcc                     shift and go to state 230
    empty                          shift and go to state 146
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 192

    (95) variable -> ID BRACEOPEN exp BRACECLOSE .
    (96) variable -> ID BRACEOPEN exp BRACECLOSE . BRACEOPEN exp BRACECLOSE

    EQUAL           reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    COLON           reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    PARENCLOSE      reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    SEMICOLON       reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    MULTIPLY        reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    DIVIDE          reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    PLUS            reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    MINUS           reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    GREATHERTHAN    reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    LESSTHAN        reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    GREATHEREQUAL   reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    LESSEQUAL       reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    DIFFERENT       reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    SAME            reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    AND             reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    OR              reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    BRACECLOSE      reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    TO              reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    BRACEOPEN       shift and go to state 231


state 193

    (66) graph -> PLOT PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 232


state 194

    (67) exp -> exp GREATHERTHAN exp .
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

  ! shift/reduce conflict for GREATHERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for LESSEQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 67 (exp -> exp GREATHERTHAN exp .)
    PARENCLOSE      reduce using rule 67 (exp -> exp GREATHERTHAN exp .)
    COLON           reduce using rule 67 (exp -> exp GREATHERTHAN exp .)
    BRACECLOSE      reduce using rule 67 (exp -> exp GREATHERTHAN exp .)
    TO              reduce using rule 67 (exp -> exp GREATHERTHAN exp .)
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157

  ! GREATHERTHAN    [ reduce using rule 67 (exp -> exp GREATHERTHAN exp .) ]
  ! LESSTHAN        [ reduce using rule 67 (exp -> exp GREATHERTHAN exp .) ]
  ! GREATHEREQUAL   [ reduce using rule 67 (exp -> exp GREATHERTHAN exp .) ]
  ! LESSEQUAL       [ reduce using rule 67 (exp -> exp GREATHERTHAN exp .) ]
  ! DIFFERENT       [ reduce using rule 67 (exp -> exp GREATHERTHAN exp .) ]
  ! SAME            [ reduce using rule 67 (exp -> exp GREATHERTHAN exp .) ]
  ! AND             [ reduce using rule 67 (exp -> exp GREATHERTHAN exp .) ]
  ! OR              [ reduce using rule 67 (exp -> exp GREATHERTHAN exp .) ]


state 195

    (68) exp -> exp LESSTHAN exp .
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

  ! shift/reduce conflict for GREATHERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for LESSEQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 68 (exp -> exp LESSTHAN exp .)
    PARENCLOSE      reduce using rule 68 (exp -> exp LESSTHAN exp .)
    COLON           reduce using rule 68 (exp -> exp LESSTHAN exp .)
    BRACECLOSE      reduce using rule 68 (exp -> exp LESSTHAN exp .)
    TO              reduce using rule 68 (exp -> exp LESSTHAN exp .)
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157

  ! GREATHERTHAN    [ reduce using rule 68 (exp -> exp LESSTHAN exp .) ]
  ! LESSTHAN        [ reduce using rule 68 (exp -> exp LESSTHAN exp .) ]
  ! GREATHEREQUAL   [ reduce using rule 68 (exp -> exp LESSTHAN exp .) ]
  ! LESSEQUAL       [ reduce using rule 68 (exp -> exp LESSTHAN exp .) ]
  ! DIFFERENT       [ reduce using rule 68 (exp -> exp LESSTHAN exp .) ]
  ! SAME            [ reduce using rule 68 (exp -> exp LESSTHAN exp .) ]
  ! AND             [ reduce using rule 68 (exp -> exp LESSTHAN exp .) ]
  ! OR              [ reduce using rule 68 (exp -> exp LESSTHAN exp .) ]


state 196

    (69) exp -> exp GREATHEREQUAL exp .
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

  ! shift/reduce conflict for GREATHERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for LESSEQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 69 (exp -> exp GREATHEREQUAL exp .)
    PARENCLOSE      reduce using rule 69 (exp -> exp GREATHEREQUAL exp .)
    COLON           reduce using rule 69 (exp -> exp GREATHEREQUAL exp .)
    BRACECLOSE      reduce using rule 69 (exp -> exp GREATHEREQUAL exp .)
    TO              reduce using rule 69 (exp -> exp GREATHEREQUAL exp .)
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157

  ! GREATHERTHAN    [ reduce using rule 69 (exp -> exp GREATHEREQUAL exp .) ]
  ! LESSTHAN        [ reduce using rule 69 (exp -> exp GREATHEREQUAL exp .) ]
  ! GREATHEREQUAL   [ reduce using rule 69 (exp -> exp GREATHEREQUAL exp .) ]
  ! LESSEQUAL       [ reduce using rule 69 (exp -> exp GREATHEREQUAL exp .) ]
  ! DIFFERENT       [ reduce using rule 69 (exp -> exp GREATHEREQUAL exp .) ]
  ! SAME            [ reduce using rule 69 (exp -> exp GREATHEREQUAL exp .) ]
  ! AND             [ reduce using rule 69 (exp -> exp GREATHEREQUAL exp .) ]
  ! OR              [ reduce using rule 69 (exp -> exp GREATHEREQUAL exp .) ]


state 197

    (70) exp -> exp LESSEQUAL exp .
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

  ! shift/reduce conflict for GREATHERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for LESSEQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 70 (exp -> exp LESSEQUAL exp .)
    PARENCLOSE      reduce using rule 70 (exp -> exp LESSEQUAL exp .)
    COLON           reduce using rule 70 (exp -> exp LESSEQUAL exp .)
    BRACECLOSE      reduce using rule 70 (exp -> exp LESSEQUAL exp .)
    TO              reduce using rule 70 (exp -> exp LESSEQUAL exp .)
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157

  ! GREATHERTHAN    [ reduce using rule 70 (exp -> exp LESSEQUAL exp .) ]
  ! LESSTHAN        [ reduce using rule 70 (exp -> exp LESSEQUAL exp .) ]
  ! GREATHEREQUAL   [ reduce using rule 70 (exp -> exp LESSEQUAL exp .) ]
  ! LESSEQUAL       [ reduce using rule 70 (exp -> exp LESSEQUAL exp .) ]
  ! DIFFERENT       [ reduce using rule 70 (exp -> exp LESSEQUAL exp .) ]
  ! SAME            [ reduce using rule 70 (exp -> exp LESSEQUAL exp .) ]
  ! AND             [ reduce using rule 70 (exp -> exp LESSEQUAL exp .) ]
  ! OR              [ reduce using rule 70 (exp -> exp LESSEQUAL exp .) ]


state 198

    (71) exp -> exp DIFFERENT exp .
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

  ! shift/reduce conflict for GREATHERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for LESSEQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 71 (exp -> exp DIFFERENT exp .)
    PARENCLOSE      reduce using rule 71 (exp -> exp DIFFERENT exp .)
    COLON           reduce using rule 71 (exp -> exp DIFFERENT exp .)
    BRACECLOSE      reduce using rule 71 (exp -> exp DIFFERENT exp .)
    TO              reduce using rule 71 (exp -> exp DIFFERENT exp .)
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157

  ! GREATHERTHAN    [ reduce using rule 71 (exp -> exp DIFFERENT exp .) ]
  ! LESSTHAN        [ reduce using rule 71 (exp -> exp DIFFERENT exp .) ]
  ! GREATHEREQUAL   [ reduce using rule 71 (exp -> exp DIFFERENT exp .) ]
  ! LESSEQUAL       [ reduce using rule 71 (exp -> exp DIFFERENT exp .) ]
  ! DIFFERENT       [ reduce using rule 71 (exp -> exp DIFFERENT exp .) ]
  ! SAME            [ reduce using rule 71 (exp -> exp DIFFERENT exp .) ]
  ! AND             [ reduce using rule 71 (exp -> exp DIFFERENT exp .) ]
  ! OR              [ reduce using rule 71 (exp -> exp DIFFERENT exp .) ]


state 199

    (72) exp -> exp SAME exp .
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

  ! shift/reduce conflict for GREATHERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for LESSEQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 72 (exp -> exp SAME exp .)
    PARENCLOSE      reduce using rule 72 (exp -> exp SAME exp .)
    COLON           reduce using rule 72 (exp -> exp SAME exp .)
    BRACECLOSE      reduce using rule 72 (exp -> exp SAME exp .)
    TO              reduce using rule 72 (exp -> exp SAME exp .)
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157

  ! GREATHERTHAN    [ reduce using rule 72 (exp -> exp SAME exp .) ]
  ! LESSTHAN        [ reduce using rule 72 (exp -> exp SAME exp .) ]
  ! GREATHEREQUAL   [ reduce using rule 72 (exp -> exp SAME exp .) ]
  ! LESSEQUAL       [ reduce using rule 72 (exp -> exp SAME exp .) ]
  ! DIFFERENT       [ reduce using rule 72 (exp -> exp SAME exp .) ]
  ! SAME            [ reduce using rule 72 (exp -> exp SAME exp .) ]
  ! AND             [ reduce using rule 72 (exp -> exp SAME exp .) ]
  ! OR              [ reduce using rule 72 (exp -> exp SAME exp .) ]


state 200

    (73) exp -> exp AND exp .
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

  ! shift/reduce conflict for GREATHERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for LESSEQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 73 (exp -> exp AND exp .)
    PARENCLOSE      reduce using rule 73 (exp -> exp AND exp .)
    COLON           reduce using rule 73 (exp -> exp AND exp .)
    BRACECLOSE      reduce using rule 73 (exp -> exp AND exp .)
    TO              reduce using rule 73 (exp -> exp AND exp .)
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157

  ! GREATHERTHAN    [ reduce using rule 73 (exp -> exp AND exp .) ]
  ! LESSTHAN        [ reduce using rule 73 (exp -> exp AND exp .) ]
  ! GREATHEREQUAL   [ reduce using rule 73 (exp -> exp AND exp .) ]
  ! LESSEQUAL       [ reduce using rule 73 (exp -> exp AND exp .) ]
  ! DIFFERENT       [ reduce using rule 73 (exp -> exp AND exp .) ]
  ! SAME            [ reduce using rule 73 (exp -> exp AND exp .) ]
  ! AND             [ reduce using rule 73 (exp -> exp AND exp .) ]
  ! OR              [ reduce using rule 73 (exp -> exp AND exp .) ]


state 201

    (74) exp -> exp OR exp .
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

  ! shift/reduce conflict for GREATHERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for LESSEQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 74 (exp -> exp OR exp .)
    PARENCLOSE      reduce using rule 74 (exp -> exp OR exp .)
    COLON           reduce using rule 74 (exp -> exp OR exp .)
    BRACECLOSE      reduce using rule 74 (exp -> exp OR exp .)
    TO              reduce using rule 74 (exp -> exp OR exp .)
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157

  ! GREATHERTHAN    [ reduce using rule 74 (exp -> exp OR exp .) ]
  ! LESSTHAN        [ reduce using rule 74 (exp -> exp OR exp .) ]
  ! GREATHEREQUAL   [ reduce using rule 74 (exp -> exp OR exp .) ]
  ! LESSEQUAL       [ reduce using rule 74 (exp -> exp OR exp .) ]
  ! DIFFERENT       [ reduce using rule 74 (exp -> exp OR exp .) ]
  ! SAME            [ reduce using rule 74 (exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 74 (exp -> exp OR exp .) ]
  ! OR              [ reduce using rule 74 (exp -> exp OR exp .) ]


state 202

    (77) m_expp -> PLUS appendPLUS . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    m_exp                          shift and go to state 233
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 203

    (80) appendPLUS -> empty .

    PARENOPEN       reduce using rule 80 (appendPLUS -> empty .)
    ID              reduce using rule 80 (appendPLUS -> empty .)
    CTEINT          reduce using rule 80 (appendPLUS -> empty .)
    CTFLOAT         reduce using rule 80 (appendPLUS -> empty .)


state 204

    (78) m_expp -> MINUS appendMINUS . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    m_exp                          shift and go to state 234
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 205

    (81) appendMINUS -> empty .

    PARENOPEN       reduce using rule 81 (appendMINUS -> empty .)
    ID              reduce using rule 81 (appendMINUS -> empty .)
    CTEINT          reduce using rule 81 (appendMINUS -> empty .)
    CTFLOAT         reduce using rule 81 (appendMINUS -> empty .)


state 206

    (85) termino -> MULTIPLY appendMULTIPLY . t
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    t                              shift and go to state 235
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 207

    (82) appendMULTIPLY -> empty .

    PARENOPEN       reduce using rule 82 (appendMULTIPLY -> empty .)
    ID              reduce using rule 82 (appendMULTIPLY -> empty .)
    CTEINT          reduce using rule 82 (appendMULTIPLY -> empty .)
    CTFLOAT         reduce using rule 82 (appendMULTIPLY -> empty .)


state 208

    (86) termino -> DIVIDE appendDIVIDE . t
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    t                              shift and go to state 236
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 209

    (83) appendDIVIDE -> empty .

    PARENOPEN       reduce using rule 83 (appendDIVIDE -> empty .)
    ID              reduce using rule 83 (appendDIVIDE -> empty .)
    CTEINT          reduce using rule 83 (appendDIVIDE -> empty .)
    CTFLOAT         reduce using rule 83 (appendDIVIDE -> empty .)


state 210

    (88) f -> PARENOPEN exp PARENCLOSE .

    MULTIPLY        reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)
    DIVIDE          reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)
    PLUS            reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)
    MINUS           reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)
    SEMICOLON       reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)
    GREATHERTHAN    reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)
    LESSTHAN        reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)
    GREATHEREQUAL   reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)
    LESSEQUAL       reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)
    DIFFERENT       reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)
    SAME            reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)
    AND             reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)
    OR              reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)
    PARENCLOSE      reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)
    COLON           reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)
    BRACECLOSE      reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)
    TO              reduce using rule 88 (f -> PARENOPEN exp PARENCLOSE .)


state 211

    (112) while_loop -> WHILE whileMigaja PARENOPEN exp . PARENCLOSE whileEval body whileEnd
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

    PARENCLOSE      shift and go to state 237
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157


state 212

    (116) for_loop -> FOR PARENOPEN variable EQUAL . exp guardarValorFor TO exp PARENCLOSE body forEnd
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    variable                       shift and go to state 118
    exp                            shift and go to state 238
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    call_func                      shift and go to state 119

state 213

    (120) max -> MAX PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 239


state 214

    (121) min -> MIN PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 240


state 215

    (122) sum -> SUM PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 241


state 216

    (128) normal -> NORMAL PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 242


state 217

    (124) param_dist -> variable COLON . param_dist
    (123) param_dist -> . variable
    (124) param_dist -> . variable COLON param_dist
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 95

    variable                       shift and go to state 173
    param_dist                     shift and go to state 243

state 218

    (127) uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 244


state 219

    (126) poisson -> POISSON PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 245


state 220

    (125) binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 246


state 221

    (53) dec_variabless -> type guardarTipo dec_mvar SEMICOLON . dec_variabless
    (54) dec_variabless -> type guardarTipo dec_mvar SEMICOLON .
    (53) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON dec_variabless
    (54) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . CHAR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    IF              reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    PRINT           reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    READ            reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    ID              reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    PLOT            reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    RETURN          reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    WHILE           reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    FOR             reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    MAX             reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    MIN             reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    SUM             reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    NORMAL          reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    UNIFORME        reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    POISSON         reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    BINOMIAL        reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    BRACKETCLOSE    reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

  ! INT             [ reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .) ]
  ! CHAR            [ reduce using rule 54 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .) ]

    type                           shift and go to state 93
    dec_variabless                 shift and go to state 247

state 222

    (55) dec_mvar -> ID COLON . dec_mvar
    (55) dec_mvar -> . ID COLON dec_mvar
    (56) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (57) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (58) dec_mvar -> . ID
    (59) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (60) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 178

    dec_mvar                       shift and go to state 248

state 223

    (56) dec_mvar -> ID BRACEOPEN . CTEINT BRACECLOSE COLON dec_mvar
    (57) dec_mvar -> ID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (59) dec_mvar -> ID BRACEOPEN . CTEINT BRACECLOSE
    (60) dec_mvar -> ID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    CTEINT          shift and go to state 249


state 224

    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON . mvar
    (15) mvar -> . ID COLON mvar
    (16) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> . ID
    (19) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (20) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 34

    mvar                           shift and go to state 250

state 225

    (97) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF . body ifEnd
    (98) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF . body cuadruploElse ELSE body ifEndElse
    (31) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 251

state 226

    (99) cuadruploIF -> empty .

    BRACKETOPEN     reduce using rule 99 (cuadruploIF -> empty .)


state 227

    (103) writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .

    IF              reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    READ            reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    ID              reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    INT             reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 103 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)


state 228

    (105) writingg -> exp COLON writingg .

    PARENCLOSE      reduce using rule 105 (writingg -> exp COLON writingg .)


state 229

    (107) writingg -> auxString COLON writingg .

    PARENCLOSE      reduce using rule 107 (writingg -> auxString COLON writingg .)


state 230

    (64) call_funcc -> exp COLON call_funcc .

    PARENCLOSE      reduce using rule 64 (call_funcc -> exp COLON call_funcc .)


state 231

    (96) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN . exp BRACECLOSE
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    exp                            shift and go to state 252
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    variable                       shift and go to state 118
    call_func                      shift and go to state 119

state 232

    (66) graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 66 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)


state 233

    (77) m_expp -> PLUS appendPLUS m_exp .

    SEMICOLON       reduce using rule 77 (m_expp -> PLUS appendPLUS m_exp .)
    GREATHERTHAN    reduce using rule 77 (m_expp -> PLUS appendPLUS m_exp .)
    LESSTHAN        reduce using rule 77 (m_expp -> PLUS appendPLUS m_exp .)
    GREATHEREQUAL   reduce using rule 77 (m_expp -> PLUS appendPLUS m_exp .)
    LESSEQUAL       reduce using rule 77 (m_expp -> PLUS appendPLUS m_exp .)
    DIFFERENT       reduce using rule 77 (m_expp -> PLUS appendPLUS m_exp .)
    SAME            reduce using rule 77 (m_expp -> PLUS appendPLUS m_exp .)
    AND             reduce using rule 77 (m_expp -> PLUS appendPLUS m_exp .)
    OR              reduce using rule 77 (m_expp -> PLUS appendPLUS m_exp .)
    PARENCLOSE      reduce using rule 77 (m_expp -> PLUS appendPLUS m_exp .)
    COLON           reduce using rule 77 (m_expp -> PLUS appendPLUS m_exp .)
    BRACECLOSE      reduce using rule 77 (m_expp -> PLUS appendPLUS m_exp .)
    TO              reduce using rule 77 (m_expp -> PLUS appendPLUS m_exp .)


state 234

    (78) m_expp -> MINUS appendMINUS m_exp .

    SEMICOLON       reduce using rule 78 (m_expp -> MINUS appendMINUS m_exp .)
    GREATHERTHAN    reduce using rule 78 (m_expp -> MINUS appendMINUS m_exp .)
    LESSTHAN        reduce using rule 78 (m_expp -> MINUS appendMINUS m_exp .)
    GREATHEREQUAL   reduce using rule 78 (m_expp -> MINUS appendMINUS m_exp .)
    LESSEQUAL       reduce using rule 78 (m_expp -> MINUS appendMINUS m_exp .)
    DIFFERENT       reduce using rule 78 (m_expp -> MINUS appendMINUS m_exp .)
    SAME            reduce using rule 78 (m_expp -> MINUS appendMINUS m_exp .)
    AND             reduce using rule 78 (m_expp -> MINUS appendMINUS m_exp .)
    OR              reduce using rule 78 (m_expp -> MINUS appendMINUS m_exp .)
    PARENCLOSE      reduce using rule 78 (m_expp -> MINUS appendMINUS m_exp .)
    COLON           reduce using rule 78 (m_expp -> MINUS appendMINUS m_exp .)
    BRACECLOSE      reduce using rule 78 (m_expp -> MINUS appendMINUS m_exp .)
    TO              reduce using rule 78 (m_expp -> MINUS appendMINUS m_exp .)


state 235

    (85) termino -> MULTIPLY appendMULTIPLY t .

    PLUS            reduce using rule 85 (termino -> MULTIPLY appendMULTIPLY t .)
    MINUS           reduce using rule 85 (termino -> MULTIPLY appendMULTIPLY t .)
    SEMICOLON       reduce using rule 85 (termino -> MULTIPLY appendMULTIPLY t .)
    GREATHERTHAN    reduce using rule 85 (termino -> MULTIPLY appendMULTIPLY t .)
    LESSTHAN        reduce using rule 85 (termino -> MULTIPLY appendMULTIPLY t .)
    GREATHEREQUAL   reduce using rule 85 (termino -> MULTIPLY appendMULTIPLY t .)
    LESSEQUAL       reduce using rule 85 (termino -> MULTIPLY appendMULTIPLY t .)
    DIFFERENT       reduce using rule 85 (termino -> MULTIPLY appendMULTIPLY t .)
    SAME            reduce using rule 85 (termino -> MULTIPLY appendMULTIPLY t .)
    AND             reduce using rule 85 (termino -> MULTIPLY appendMULTIPLY t .)
    OR              reduce using rule 85 (termino -> MULTIPLY appendMULTIPLY t .)
    PARENCLOSE      reduce using rule 85 (termino -> MULTIPLY appendMULTIPLY t .)
    COLON           reduce using rule 85 (termino -> MULTIPLY appendMULTIPLY t .)
    BRACECLOSE      reduce using rule 85 (termino -> MULTIPLY appendMULTIPLY t .)
    TO              reduce using rule 85 (termino -> MULTIPLY appendMULTIPLY t .)


state 236

    (86) termino -> DIVIDE appendDIVIDE t .

    PLUS            reduce using rule 86 (termino -> DIVIDE appendDIVIDE t .)
    MINUS           reduce using rule 86 (termino -> DIVIDE appendDIVIDE t .)
    SEMICOLON       reduce using rule 86 (termino -> DIVIDE appendDIVIDE t .)
    GREATHERTHAN    reduce using rule 86 (termino -> DIVIDE appendDIVIDE t .)
    LESSTHAN        reduce using rule 86 (termino -> DIVIDE appendDIVIDE t .)
    GREATHEREQUAL   reduce using rule 86 (termino -> DIVIDE appendDIVIDE t .)
    LESSEQUAL       reduce using rule 86 (termino -> DIVIDE appendDIVIDE t .)
    DIFFERENT       reduce using rule 86 (termino -> DIVIDE appendDIVIDE t .)
    SAME            reduce using rule 86 (termino -> DIVIDE appendDIVIDE t .)
    AND             reduce using rule 86 (termino -> DIVIDE appendDIVIDE t .)
    OR              reduce using rule 86 (termino -> DIVIDE appendDIVIDE t .)
    PARENCLOSE      reduce using rule 86 (termino -> DIVIDE appendDIVIDE t .)
    COLON           reduce using rule 86 (termino -> DIVIDE appendDIVIDE t .)
    BRACECLOSE      reduce using rule 86 (termino -> DIVIDE appendDIVIDE t .)
    TO              reduce using rule 86 (termino -> DIVIDE appendDIVIDE t .)


state 237

    (112) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE . whileEval body whileEnd
    (114) whileEval -> . empty
    (129) empty -> .

    BRACKETOPEN     reduce using rule 129 (empty -> .)

    whileEval                      shift and go to state 253
    empty                          shift and go to state 254

state 238

    (116) for_loop -> FOR PARENOPEN variable EQUAL exp . guardarValorFor TO exp PARENCLOSE body forEnd
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp
    (117) guardarValorFor -> . empty
    (129) empty -> .

    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157
    TO              reduce using rule 129 (empty -> .)

    guardarValorFor                shift and go to state 255
    empty                          shift and go to state 256

state 239

    (120) max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 120 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)


state 240

    (121) min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 121 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)


state 241

    (122) sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 122 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)


state 242

    (128) normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 128 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 243

    (124) param_dist -> variable COLON param_dist .

    PARENCLOSE      reduce using rule 124 (param_dist -> variable COLON param_dist .)


state 244

    (127) uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 127 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 245

    (126) poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 126 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 246

    (125) binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 125 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 247

    (53) dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .

    IF              reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    PRINT           reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    READ            reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    ID              reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    PLOT            reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    RETURN          reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    WHILE           reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    FOR             reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    MAX             reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    MIN             reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    SUM             reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    NORMAL          reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    UNIFORME        reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    POISSON         reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    BINOMIAL        reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    INT             reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    FLOAT           reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    CHAR            reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    BRACKETCLOSE    reduce using rule 53 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)


state 248

    (55) dec_mvar -> ID COLON dec_mvar .

    SEMICOLON       reduce using rule 55 (dec_mvar -> ID COLON dec_mvar .)


state 249

    (56) dec_mvar -> ID BRACEOPEN CTEINT . BRACECLOSE COLON dec_mvar
    (57) dec_mvar -> ID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (59) dec_mvar -> ID BRACEOPEN CTEINT . BRACECLOSE
    (60) dec_mvar -> ID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    BRACECLOSE      shift and go to state 257


state 250

    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar .

    SEMICOLON       reduce using rule 17 (mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar .)


state 251

    (97) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body . ifEnd
    (98) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body . cuadruploElse ELSE body ifEndElse
    (100) ifEnd -> . empty
    (101) cuadruploElse -> . empty
    (129) empty -> .

    IF              reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    READ            reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    PLOT            reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    FOR             reduce using rule 129 (empty -> .)
    MAX             reduce using rule 129 (empty -> .)
    MIN             reduce using rule 129 (empty -> .)
    SUM             reduce using rule 129 (empty -> .)
    NORMAL          reduce using rule 129 (empty -> .)
    UNIFORME        reduce using rule 129 (empty -> .)
    POISSON         reduce using rule 129 (empty -> .)
    BINOMIAL        reduce using rule 129 (empty -> .)
    INT             reduce using rule 129 (empty -> .)
    FLOAT           reduce using rule 129 (empty -> .)
    CHAR            reduce using rule 129 (empty -> .)
    BRACKETCLOSE    reduce using rule 129 (empty -> .)
    ELSE            reduce using rule 129 (empty -> .)

    ifEnd                          shift and go to state 258
    cuadruploElse                  shift and go to state 259
    empty                          shift and go to state 260

state 252

    (96) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp . BRACECLOSE
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

    BRACECLOSE      shift and go to state 261
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157


state 253

    (112) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval . body whileEnd
    (31) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 262

state 254

    (114) whileEval -> empty .

    BRACKETOPEN     reduce using rule 114 (whileEval -> empty .)


state 255

    (116) for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor . TO exp PARENCLOSE body forEnd

    TO              shift and go to state 263


state 256

    (117) guardarValorFor -> empty .

    TO              reduce using rule 117 (guardarValorFor -> empty .)


state 257

    (56) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE . COLON dec_mvar
    (57) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (59) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE .
    (60) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 265
    BRACEOPEN       shift and go to state 264
    SEMICOLON       reduce using rule 59 (dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE .)


state 258

    (97) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .

    IF              reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    PRINT           reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    READ            reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    ID              reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    PLOT            reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    RETURN          reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    WHILE           reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    FOR             reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    MAX             reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    MIN             reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    SUM             reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    NORMAL          reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    UNIFORME        reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    POISSON         reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    BINOMIAL        reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    INT             reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    FLOAT           reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    CHAR            reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    BRACKETCLOSE    reduce using rule 97 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)


state 259

    (98) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse . ELSE body ifEndElse

    ELSE            shift and go to state 266


state 260

    (100) ifEnd -> empty .
    (101) cuadruploElse -> empty .

    IF              reduce using rule 100 (ifEnd -> empty .)
    PRINT           reduce using rule 100 (ifEnd -> empty .)
    READ            reduce using rule 100 (ifEnd -> empty .)
    ID              reduce using rule 100 (ifEnd -> empty .)
    PLOT            reduce using rule 100 (ifEnd -> empty .)
    RETURN          reduce using rule 100 (ifEnd -> empty .)
    WHILE           reduce using rule 100 (ifEnd -> empty .)
    FOR             reduce using rule 100 (ifEnd -> empty .)
    MAX             reduce using rule 100 (ifEnd -> empty .)
    MIN             reduce using rule 100 (ifEnd -> empty .)
    SUM             reduce using rule 100 (ifEnd -> empty .)
    NORMAL          reduce using rule 100 (ifEnd -> empty .)
    UNIFORME        reduce using rule 100 (ifEnd -> empty .)
    POISSON         reduce using rule 100 (ifEnd -> empty .)
    BINOMIAL        reduce using rule 100 (ifEnd -> empty .)
    INT             reduce using rule 100 (ifEnd -> empty .)
    FLOAT           reduce using rule 100 (ifEnd -> empty .)
    CHAR            reduce using rule 100 (ifEnd -> empty .)
    BRACKETCLOSE    reduce using rule 100 (ifEnd -> empty .)
    ELSE            reduce using rule 101 (cuadruploElse -> empty .)


state 261

    (96) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .

    EQUAL           reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    COLON           reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    PARENCLOSE      reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    SEMICOLON       reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    MULTIPLY        reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    DIVIDE          reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    PLUS            reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    MINUS           reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    GREATHERTHAN    reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    LESSTHAN        reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    GREATHEREQUAL   reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    LESSEQUAL       reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    DIFFERENT       reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    SAME            reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    AND             reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    OR              reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    BRACECLOSE      reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    TO              reduce using rule 96 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)


state 262

    (112) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body . whileEnd
    (115) whileEnd -> . empty
    (129) empty -> .

    IF              reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    READ            reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    PLOT            reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    FOR             reduce using rule 129 (empty -> .)
    MAX             reduce using rule 129 (empty -> .)
    MIN             reduce using rule 129 (empty -> .)
    SUM             reduce using rule 129 (empty -> .)
    NORMAL          reduce using rule 129 (empty -> .)
    UNIFORME        reduce using rule 129 (empty -> .)
    POISSON         reduce using rule 129 (empty -> .)
    BINOMIAL        reduce using rule 129 (empty -> .)
    INT             reduce using rule 129 (empty -> .)
    FLOAT           reduce using rule 129 (empty -> .)
    CHAR            reduce using rule 129 (empty -> .)
    BRACKETCLOSE    reduce using rule 129 (empty -> .)

    whileEnd                       shift and go to state 267
    empty                          shift and go to state 268

state 263

    (116) for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO . exp PARENCLOSE body forEnd
    (67) exp -> . exp GREATHERTHAN exp
    (68) exp -> . exp LESSTHAN exp
    (69) exp -> . exp GREATHEREQUAL exp
    (70) exp -> . exp LESSEQUAL exp
    (71) exp -> . exp DIFFERENT exp
    (72) exp -> . exp SAME exp
    (73) exp -> . exp AND exp
    (74) exp -> . exp OR exp
    (75) exp -> . m_exp
    (76) m_exp -> . t m_expp
    (84) t -> . f termino
    (88) f -> . PARENOPEN exp PARENCLOSE
    (89) f -> . ID
    (90) f -> . CTEINT
    (91) f -> . CTFLOAT
    (92) f -> . variable
    (93) f -> . call_func
    (94) variable -> . ID
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE
    (96) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (62) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 114
    ID              shift and go to state 115
    CTEINT          shift and go to state 116
    CTFLOAT         shift and go to state 117

    variable                       shift and go to state 118
    exp                            shift and go to state 269
    m_exp                          shift and go to state 111
    t                              shift and go to state 112
    f                              shift and go to state 113
    call_func                      shift and go to state 119

state 264

    (57) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE COLON dec_mvar
    (60) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE

    CTEINT          shift and go to state 270


state 265

    (56) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON . dec_mvar
    (55) dec_mvar -> . ID COLON dec_mvar
    (56) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (57) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (58) dec_mvar -> . ID
    (59) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (60) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 178

    dec_mvar                       shift and go to state 271

state 266

    (98) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE . body ifEndElse
    (31) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 272

state 267

    (112) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .

    IF              reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    PRINT           reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    READ            reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    ID              reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    PLOT            reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    RETURN          reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    WHILE           reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    FOR             reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    MAX             reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    MIN             reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    SUM             reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    NORMAL          reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    UNIFORME        reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    POISSON         reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    BINOMIAL        reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    INT             reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    FLOAT           reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    CHAR            reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    BRACKETCLOSE    reduce using rule 112 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)


state 268

    (115) whileEnd -> empty .

    IF              reduce using rule 115 (whileEnd -> empty .)
    PRINT           reduce using rule 115 (whileEnd -> empty .)
    READ            reduce using rule 115 (whileEnd -> empty .)
    ID              reduce using rule 115 (whileEnd -> empty .)
    PLOT            reduce using rule 115 (whileEnd -> empty .)
    RETURN          reduce using rule 115 (whileEnd -> empty .)
    WHILE           reduce using rule 115 (whileEnd -> empty .)
    FOR             reduce using rule 115 (whileEnd -> empty .)
    MAX             reduce using rule 115 (whileEnd -> empty .)
    MIN             reduce using rule 115 (whileEnd -> empty .)
    SUM             reduce using rule 115 (whileEnd -> empty .)
    NORMAL          reduce using rule 115 (whileEnd -> empty .)
    UNIFORME        reduce using rule 115 (whileEnd -> empty .)
    POISSON         reduce using rule 115 (whileEnd -> empty .)
    BINOMIAL        reduce using rule 115 (whileEnd -> empty .)
    INT             reduce using rule 115 (whileEnd -> empty .)
    FLOAT           reduce using rule 115 (whileEnd -> empty .)
    CHAR            reduce using rule 115 (whileEnd -> empty .)
    BRACKETCLOSE    reduce using rule 115 (whileEnd -> empty .)


state 269

    (116) for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp . PARENCLOSE body forEnd
    (67) exp -> exp . GREATHERTHAN exp
    (68) exp -> exp . LESSTHAN exp
    (69) exp -> exp . GREATHEREQUAL exp
    (70) exp -> exp . LESSEQUAL exp
    (71) exp -> exp . DIFFERENT exp
    (72) exp -> exp . SAME exp
    (73) exp -> exp . AND exp
    (74) exp -> exp . OR exp

    PARENCLOSE      shift and go to state 273
    GREATHERTHAN    shift and go to state 150
    LESSTHAN        shift and go to state 151
    GREATHEREQUAL   shift and go to state 152
    LESSEQUAL       shift and go to state 153
    DIFFERENT       shift and go to state 154
    SAME            shift and go to state 155
    AND             shift and go to state 156
    OR              shift and go to state 157


state 270

    (57) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE COLON dec_mvar
    (60) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE

    BRACECLOSE      shift and go to state 274


state 271

    (56) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .

    SEMICOLON       reduce using rule 56 (dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .)


state 272

    (98) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body . ifEndElse
    (102) ifEndElse -> . empty
    (129) empty -> .

    IF              reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    READ            reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    PLOT            reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    FOR             reduce using rule 129 (empty -> .)
    MAX             reduce using rule 129 (empty -> .)
    MIN             reduce using rule 129 (empty -> .)
    SUM             reduce using rule 129 (empty -> .)
    NORMAL          reduce using rule 129 (empty -> .)
    UNIFORME        reduce using rule 129 (empty -> .)
    POISSON         reduce using rule 129 (empty -> .)
    BINOMIAL        reduce using rule 129 (empty -> .)
    INT             reduce using rule 129 (empty -> .)
    FLOAT           reduce using rule 129 (empty -> .)
    CHAR            reduce using rule 129 (empty -> .)
    BRACKETCLOSE    reduce using rule 129 (empty -> .)

    ifEndElse                      shift and go to state 275
    empty                          shift and go to state 276

state 273

    (116) for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE . body forEnd
    (31) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 277

state 274

    (57) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE . COLON dec_mvar
    (60) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .

    COLON           shift and go to state 278
    SEMICOLON       reduce using rule 60 (dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .)


state 275

    (98) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .

    IF              reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    PRINT           reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    READ            reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    ID              reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    PLOT            reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    RETURN          reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    WHILE           reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    FOR             reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    MAX             reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    MIN             reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    SUM             reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    NORMAL          reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    UNIFORME        reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    POISSON         reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    BINOMIAL        reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    INT             reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    FLOAT           reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    CHAR            reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    BRACKETCLOSE    reduce using rule 98 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)


state 276

    (102) ifEndElse -> empty .

    IF              reduce using rule 102 (ifEndElse -> empty .)
    PRINT           reduce using rule 102 (ifEndElse -> empty .)
    READ            reduce using rule 102 (ifEndElse -> empty .)
    ID              reduce using rule 102 (ifEndElse -> empty .)
    PLOT            reduce using rule 102 (ifEndElse -> empty .)
    RETURN          reduce using rule 102 (ifEndElse -> empty .)
    WHILE           reduce using rule 102 (ifEndElse -> empty .)
    FOR             reduce using rule 102 (ifEndElse -> empty .)
    MAX             reduce using rule 102 (ifEndElse -> empty .)
    MIN             reduce using rule 102 (ifEndElse -> empty .)
    SUM             reduce using rule 102 (ifEndElse -> empty .)
    NORMAL          reduce using rule 102 (ifEndElse -> empty .)
    UNIFORME        reduce using rule 102 (ifEndElse -> empty .)
    POISSON         reduce using rule 102 (ifEndElse -> empty .)
    BINOMIAL        reduce using rule 102 (ifEndElse -> empty .)
    INT             reduce using rule 102 (ifEndElse -> empty .)
    FLOAT           reduce using rule 102 (ifEndElse -> empty .)
    CHAR            reduce using rule 102 (ifEndElse -> empty .)
    BRACKETCLOSE    reduce using rule 102 (ifEndElse -> empty .)


state 277

    (116) for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body . forEnd
    (118) forEnd -> . empty
    (129) empty -> .

    IF              reduce using rule 129 (empty -> .)
    PRINT           reduce using rule 129 (empty -> .)
    READ            reduce using rule 129 (empty -> .)
    ID              reduce using rule 129 (empty -> .)
    PLOT            reduce using rule 129 (empty -> .)
    RETURN          reduce using rule 129 (empty -> .)
    WHILE           reduce using rule 129 (empty -> .)
    FOR             reduce using rule 129 (empty -> .)
    MAX             reduce using rule 129 (empty -> .)
    MIN             reduce using rule 129 (empty -> .)
    SUM             reduce using rule 129 (empty -> .)
    NORMAL          reduce using rule 129 (empty -> .)
    UNIFORME        reduce using rule 129 (empty -> .)
    POISSON         reduce using rule 129 (empty -> .)
    BINOMIAL        reduce using rule 129 (empty -> .)
    INT             reduce using rule 129 (empty -> .)
    FLOAT           reduce using rule 129 (empty -> .)
    CHAR            reduce using rule 129 (empty -> .)
    BRACKETCLOSE    reduce using rule 129 (empty -> .)

    forEnd                         shift and go to state 279
    empty                          shift and go to state 280

state 278

    (57) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON . dec_mvar
    (55) dec_mvar -> . ID COLON dec_mvar
    (56) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (57) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (58) dec_mvar -> . ID
    (59) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (60) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 178

    dec_mvar                       shift and go to state 281

state 279

    (116) for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .

    IF              reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    PRINT           reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    READ            reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    ID              reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    PLOT            reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    RETURN          reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    WHILE           reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    FOR             reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    MAX             reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    MIN             reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    SUM             reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    NORMAL          reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    UNIFORME        reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    POISSON         reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    BINOMIAL        reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    INT             reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    FLOAT           reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    CHAR            reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    BRACKETCLOSE    reduce using rule 116 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)


state 280

    (118) forEnd -> empty .

    IF              reduce using rule 118 (forEnd -> empty .)
    PRINT           reduce using rule 118 (forEnd -> empty .)
    READ            reduce using rule 118 (forEnd -> empty .)
    ID              reduce using rule 118 (forEnd -> empty .)
    PLOT            reduce using rule 118 (forEnd -> empty .)
    RETURN          reduce using rule 118 (forEnd -> empty .)
    WHILE           reduce using rule 118 (forEnd -> empty .)
    FOR             reduce using rule 118 (forEnd -> empty .)
    MAX             reduce using rule 118 (forEnd -> empty .)
    MIN             reduce using rule 118 (forEnd -> empty .)
    SUM             reduce using rule 118 (forEnd -> empty .)
    NORMAL          reduce using rule 118 (forEnd -> empty .)
    UNIFORME        reduce using rule 118 (forEnd -> empty .)
    POISSON         reduce using rule 118 (forEnd -> empty .)
    BINOMIAL        reduce using rule 118 (forEnd -> empty .)
    INT             reduce using rule 118 (forEnd -> empty .)
    FLOAT           reduce using rule 118 (forEnd -> empty .)
    CHAR            reduce using rule 118 (forEnd -> empty .)
    BRACKETCLOSE    reduce using rule 118 (forEnd -> empty .)


state 281

    (57) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .

    SEMICOLON       reduce using rule 57 (dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for GREATHERTHAN in state 194 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 194 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 194 resolved as shift
WARNING: shift/reduce conflict for LESSEQUAL in state 194 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 194 resolved as shift
WARNING: shift/reduce conflict for SAME in state 194 resolved as shift
WARNING: shift/reduce conflict for AND in state 194 resolved as shift
WARNING: shift/reduce conflict for OR in state 194 resolved as shift
WARNING: shift/reduce conflict for GREATHERTHAN in state 195 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 195 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 195 resolved as shift
WARNING: shift/reduce conflict for LESSEQUAL in state 195 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 195 resolved as shift
WARNING: shift/reduce conflict for SAME in state 195 resolved as shift
WARNING: shift/reduce conflict for AND in state 195 resolved as shift
WARNING: shift/reduce conflict for OR in state 195 resolved as shift
WARNING: shift/reduce conflict for GREATHERTHAN in state 196 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 196 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 196 resolved as shift
WARNING: shift/reduce conflict for LESSEQUAL in state 196 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 196 resolved as shift
WARNING: shift/reduce conflict for SAME in state 196 resolved as shift
WARNING: shift/reduce conflict for AND in state 196 resolved as shift
WARNING: shift/reduce conflict for OR in state 196 resolved as shift
WARNING: shift/reduce conflict for GREATHERTHAN in state 197 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 197 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 197 resolved as shift
WARNING: shift/reduce conflict for LESSEQUAL in state 197 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 197 resolved as shift
WARNING: shift/reduce conflict for SAME in state 197 resolved as shift
WARNING: shift/reduce conflict for AND in state 197 resolved as shift
WARNING: shift/reduce conflict for OR in state 197 resolved as shift
WARNING: shift/reduce conflict for GREATHERTHAN in state 198 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 198 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 198 resolved as shift
WARNING: shift/reduce conflict for LESSEQUAL in state 198 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 198 resolved as shift
WARNING: shift/reduce conflict for SAME in state 198 resolved as shift
WARNING: shift/reduce conflict for AND in state 198 resolved as shift
WARNING: shift/reduce conflict for OR in state 198 resolved as shift
WARNING: shift/reduce conflict for GREATHERTHAN in state 199 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 199 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 199 resolved as shift
WARNING: shift/reduce conflict for LESSEQUAL in state 199 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 199 resolved as shift
WARNING: shift/reduce conflict for SAME in state 199 resolved as shift
WARNING: shift/reduce conflict for AND in state 199 resolved as shift
WARNING: shift/reduce conflict for OR in state 199 resolved as shift
WARNING: shift/reduce conflict for GREATHERTHAN in state 200 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 200 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 200 resolved as shift
WARNING: shift/reduce conflict for LESSEQUAL in state 200 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 200 resolved as shift
WARNING: shift/reduce conflict for SAME in state 200 resolved as shift
WARNING: shift/reduce conflict for AND in state 200 resolved as shift
WARNING: shift/reduce conflict for OR in state 200 resolved as shift
WARNING: shift/reduce conflict for GREATHERTHAN in state 201 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 201 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 201 resolved as shift
WARNING: shift/reduce conflict for LESSEQUAL in state 201 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 201 resolved as shift
WARNING: shift/reduce conflict for SAME in state 201 resolved as shift
WARNING: shift/reduce conflict for AND in state 201 resolved as shift
WARNING: shift/reduce conflict for OR in state 201 resolved as shift
WARNING: shift/reduce conflict for INT in state 221 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 221 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 221 resolved as shift
WARNING: reduce/reduce conflict in state 57 resolved using rule (bodyy -> statement)
WARNING: rejected rule (empty -> <empty>) in state 57
WARNING: reduce/reduce conflict in state 115 resolved using rule (f -> ID)
WARNING: rejected rule (variable -> ID) in state 115
