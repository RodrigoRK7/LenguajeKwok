Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start_program
Rule 1     start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body
Rule 2     start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body
Rule 3     start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body
Rule 4     start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body
Rule 5     cuadruploMain -> empty
Rule 6     multiple_funcs -> dec_func
Rule 7     multiple_funcs -> dec_func multiple_funcs
Rule 8     main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body
Rule 9     crearTablaMain -> empty
Rule 10    gotoMain -> empty
Rule 11    vars -> VAR varss
Rule 12    varss -> type guardarTipo mvar SEMICOLON varss
Rule 13    varss -> type guardarTipo mvar SEMICOLON
Rule 14    guardarTipo -> empty
Rule 15    mvar -> ID COLON mvar
Rule 16    mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
Rule 17    mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
Rule 18    mvar -> ID
Rule 19    mvar -> ID BRACEOPEN CTEINT BRACECLOSE
Rule 20    mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE
Rule 21    dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
Rule 22    dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
Rule 23    crearSymbolTable -> empty
Rule 24    exitFunc -> empty
Rule 25    param -> typeParam ID
Rule 26    param -> typeParam ID COLON param
Rule 27    param -> empty
Rule 28    typeParam -> INT
Rule 29    typeParam -> FLOAT
Rule 30    typeParam -> CHAR
Rule 31    type -> INT
Rule 32    type -> FLOAT
Rule 33    type -> CHAR
Rule 34    body -> BRACKETOPEN bodyy BRACKETCLOSE
Rule 35    bodyy -> statement
Rule 36    bodyy -> statement bodyy
Rule 37    bodyy -> empty
Rule 38    statement -> dec_variables
Rule 39    statement -> assignment
Rule 40    statement -> condition
Rule 41    statement -> writing
Rule 42    statement -> reading
Rule 43    statement -> call_func
Rule 44    statement -> graph
Rule 45    statement -> return
Rule 46    statement -> while_loop
Rule 47    statement -> for_loop
Rule 48    statement -> max
Rule 49    statement -> min
Rule 50    statement -> sum
Rule 51    statement -> normal
Rule 52    statement -> uniforme
Rule 53    statement -> poisson
Rule 54    statement -> binomial
Rule 55    dec_variables -> dec_variabless
Rule 56    dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless
Rule 57    dec_variabless -> type guardarTipo dec_mvar SEMICOLON
Rule 58    dec_mvar -> ID COLON dec_mvar
Rule 59    dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
Rule 60    dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
Rule 61    dec_mvar -> ID
Rule 62    dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE
Rule 63    dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE
Rule 64    assignment -> variableAssignment EQUAL exp SEMICOLON
Rule 65    call_func -> ID PARENOPEN call_funcc PARENCLOSE
Rule 66    call_funcc -> exp
Rule 67    call_funcc -> exp COLON call_funcc
Rule 68    call_funcc -> empty
Rule 69    graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON
Rule 70    exp -> expp
Rule 71    exp -> exp AND expp
Rule 72    exp -> exp OR expp
Rule 73    expp -> m_exp
Rule 74    expp -> expp GREATHERTHAN m_exp
Rule 75    expp -> expp LESSTHAN m_exp
Rule 76    expp -> expp GREATHEREQUAL m_exp
Rule 77    expp -> expp LESSEQUAL m_exp
Rule 78    expp -> expp DIFFERENT m_exp
Rule 79    expp -> expp SAME m_exp
Rule 80    m_exp -> termino
Rule 81    m_exp -> m_exp PLUS termino
Rule 82    m_exp -> m_exp MINUS termino
Rule 83    termino -> factor
Rule 84    termino -> termino MULTIPLY factor
Rule 85    termino -> termino DIVIDE factor
Rule 86    factor -> ID
Rule 87    factor -> PARENOPEN exp PARENCLOSE
Rule 88    factor -> CTEINT guardarConstante
Rule 89    factor -> CTFLOAT guardarConstante
Rule 90    factor -> variable
Rule 91    factor -> call_func
Rule 92    guardarConstante -> empty
Rule 93    variable -> ID
Rule 94    variable -> ID BRACEOPEN exp BRACECLOSE
Rule 95    variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
Rule 96    variableAssignment -> ID
Rule 97    variableAssignment -> ID BRACEOPEN exp BRACECLOSE
Rule 98    variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
Rule 99    condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
Rule 100   condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
Rule 101   cuadruploIF -> empty
Rule 102   ifEnd -> empty
Rule 103   cuadruploElse -> empty
Rule 104   ifEndElse -> empty
Rule 105   writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
Rule 106   writingg -> exp
Rule 107   writingg -> exp COLON writingg
Rule 108   writingg -> auxString
Rule 109   writingg -> auxString COLON writingg
Rule 110   auxString -> CTESTRING
Rule 111   reading -> READ multivariables SEMICOLON
Rule 112   multivariables -> variable
Rule 113   multivariables -> variable COLON multivariables
Rule 114   while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
Rule 115   whileMigaja -> empty
Rule 116   whileEval -> empty
Rule 117   whileEnd -> empty
Rule 118   for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd
Rule 119   guardarValorFor -> empty
Rule 120   forEnd -> empty
Rule 121   return -> RETURN exp SEMICOLON
Rule 122   max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON
Rule 123   min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON
Rule 124   sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON
Rule 125   param_dist -> variable
Rule 126   param_dist -> variable COLON param_dist
Rule 127   binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 128   poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 129   uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 130   normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 131   empty -> <empty>

Terminals, with rules where they appear

AND                  : 71
BINOMIAL             : 127
BRACECLOSE           : 16 17 17 19 20 20 59 60 60 62 63 63 94 95 95 97 98 98
BRACEOPEN            : 16 17 17 19 20 20 59 60 60 62 63 63 94 95 95 97 98 98
BRACKETCLOSE         : 34
BRACKETOPEN          : 34
CHAR                 : 30 33
COLON                : 15 16 17 26 58 59 60 67 107 109 113 126
CTEINT               : 16 17 17 19 20 20 59 60 60 62 63 63 88
CTESTRING            : 110
CTFLOAT              : 89
DIFFERENT            : 78
DIVIDE               : 85
ELSE                 : 100
EQUAL                : 64 118
FLOAT                : 29 32
FOR                  : 118
FUNCTION             : 21 22
GREATHEREQUAL        : 76
GREATHERTHAN         : 74
ID                   : 1 2 3 4 15 16 17 18 19 20 21 22 25 26 58 59 60 61 62 63 65 86 93 94 95 96 97 98
IF                   : 99 100
INT                  : 28 31
LESSEQUAL            : 77
LESSTHAN             : 75
MAIN                 : 8
MAX                  : 122
MIN                  : 123
MINUS                : 82
MULTIPLY             : 84
NORMAL               : 130
OR                   : 72
PARENCLOSE           : 8 21 22 65 69 87 99 100 105 114 118 122 123 124 127 128 129 130
PARENOPEN            : 8 21 22 65 69 87 99 100 105 114 118 122 123 124 127 128 129 130
PLOT                 : 69
PLUS                 : 81
POISSON              : 128
PRINT                : 105
PROGRAM              : 1 2 3 4
READ                 : 111
RETURN               : 121
SAME                 : 79
SEMICOLON            : 1 2 3 4 12 13 56 57 64 69 105 111 121 122 123 124 127 128 129 130
SUM                  : 124
TO                   : 118
UNIFORME             : 129
VAR                  : 11
VOID                 : 22
WHILE                : 114
error                : 

Nonterminals, with rules where they appear

assignment           : 39
auxString            : 108 109
binomial             : 54
body                 : 8 21 22 99 100 100 114 118
bodyy                : 34 36
call_func            : 43 91
call_funcc           : 65 67
condition            : 40
crearSymbolTable     : 21 22
crearTablaMain       : 8
cuadruploElse        : 100
cuadruploIF          : 99 100
cuadruploMain        : 1 2 3 4
dec_func             : 6 7
dec_mvar             : 56 57 58 59 60
dec_variables        : 38
dec_variabless       : 55 56
empty                : 5 9 10 14 23 24 27 37 68 92 101 102 103 104 115 116 117 119 120
exitFunc             : 21 22
exp                  : 64 66 67 69 71 72 87 94 95 95 97 98 98 99 100 106 107 114 118 118 121 122 123 124
expp                 : 70 71 72 74 75 76 77 78 79
factor               : 83 84 85
forEnd               : 118
for_loop             : 47
gotoMain             : 8
graph                : 44
guardarConstante     : 88 89
guardarTipo          : 12 13 56 57
guardarValorFor      : 118
ifEnd                : 99
ifEndElse            : 100
m_exp                : 73 74 75 76 77 78 79 81 82
main_body            : 1 2 3 4
max                  : 48
min                  : 49
multiple_funcs       : 1 3 7
multivariables       : 111 113
mvar                 : 12 13 15 16 17
normal               : 51
param                : 21 22 26
param_dist           : 126 127 128 129 130
poisson              : 53
reading              : 42
return               : 45
start_program        : 0
statement            : 35 36
sum                  : 50
termino              : 80 81 82 84 85
type                 : 12 13 21 56 57
typeParam            : 25 26
uniforme             : 52
variable             : 90 112 113 118 125 126
variableAssignment   : 64
vars                 : 1 2
varss                : 11 12
whileEnd             : 114
whileEval            : 114
whileMigaja          : 114
while_loop           : 46
writing              : 41
writingg             : 105 107 109

Parsing method: LALR

state 0

    (0) S' -> . start_program
    (1) start_program -> . cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body
    (2) start_program -> . cuadruploMain PROGRAM ID SEMICOLON vars main_body
    (3) start_program -> . cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body
    (4) start_program -> . cuadruploMain PROGRAM ID SEMICOLON main_body
    (5) cuadruploMain -> . empty
    (131) empty -> .

    PROGRAM         reduce using rule 131 (empty -> .)

    start_program                  shift and go to state 1
    cuadruploMain                  shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> start_program .



state 2

    (1) start_program -> cuadruploMain . PROGRAM ID SEMICOLON vars multiple_funcs main_body
    (2) start_program -> cuadruploMain . PROGRAM ID SEMICOLON vars main_body
    (3) start_program -> cuadruploMain . PROGRAM ID SEMICOLON multiple_funcs main_body
    (4) start_program -> cuadruploMain . PROGRAM ID SEMICOLON main_body

    PROGRAM         shift and go to state 4


state 3

    (5) cuadruploMain -> empty .

    PROGRAM         reduce using rule 5 (cuadruploMain -> empty .)


state 4

    (1) start_program -> cuadruploMain PROGRAM . ID SEMICOLON vars multiple_funcs main_body
    (2) start_program -> cuadruploMain PROGRAM . ID SEMICOLON vars main_body
    (3) start_program -> cuadruploMain PROGRAM . ID SEMICOLON multiple_funcs main_body
    (4) start_program -> cuadruploMain PROGRAM . ID SEMICOLON main_body

    ID              shift and go to state 5


state 5

    (1) start_program -> cuadruploMain PROGRAM ID . SEMICOLON vars multiple_funcs main_body
    (2) start_program -> cuadruploMain PROGRAM ID . SEMICOLON vars main_body
    (3) start_program -> cuadruploMain PROGRAM ID . SEMICOLON multiple_funcs main_body
    (4) start_program -> cuadruploMain PROGRAM ID . SEMICOLON main_body

    SEMICOLON       shift and go to state 6


state 6

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON . vars multiple_funcs main_body
    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON . vars main_body
    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON . multiple_funcs main_body
    (4) start_program -> cuadruploMain PROGRAM ID SEMICOLON . main_body
    (11) vars -> . VAR varss
    (6) multiple_funcs -> . dec_func
    (7) multiple_funcs -> . dec_func multiple_funcs
    (8) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body
    (21) dec_func -> . FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (22) dec_func -> . FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc

    VAR             shift and go to state 10
    MAIN            shift and go to state 12
    FUNCTION        shift and go to state 13

    vars                           shift and go to state 7
    multiple_funcs                 shift and go to state 8
    main_body                      shift and go to state 9
    dec_func                       shift and go to state 11

state 7

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars . multiple_funcs main_body
    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars . main_body
    (6) multiple_funcs -> . dec_func
    (7) multiple_funcs -> . dec_func multiple_funcs
    (8) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body
    (21) dec_func -> . FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (22) dec_func -> . FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc

    MAIN            shift and go to state 12
    FUNCTION        shift and go to state 13

    multiple_funcs                 shift and go to state 14
    main_body                      shift and go to state 15
    dec_func                       shift and go to state 11

state 8

    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs . main_body
    (8) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body

    MAIN            shift and go to state 12

    main_body                      shift and go to state 16

state 9

    (4) start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body .

    $end            reduce using rule 4 (start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body .)


state 10

    (11) vars -> VAR . varss
    (12) varss -> . type guardarTipo mvar SEMICOLON varss
    (13) varss -> . type guardarTipo mvar SEMICOLON
    (31) type -> . INT
    (32) type -> . FLOAT
    (33) type -> . CHAR

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    varss                          shift and go to state 17
    type                           shift and go to state 18

state 11

    (6) multiple_funcs -> dec_func .
    (7) multiple_funcs -> dec_func . multiple_funcs
    (6) multiple_funcs -> . dec_func
    (7) multiple_funcs -> . dec_func multiple_funcs
    (21) dec_func -> . FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (22) dec_func -> . FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc

    MAIN            reduce using rule 6 (multiple_funcs -> dec_func .)
    FUNCTION        shift and go to state 13

    dec_func                       shift and go to state 11
    multiple_funcs                 shift and go to state 22

state 12

    (8) main_body -> MAIN . crearTablaMain PARENOPEN PARENCLOSE gotoMain body
    (9) crearTablaMain -> . empty
    (131) empty -> .

    PARENOPEN       reduce using rule 131 (empty -> .)

    crearTablaMain                 shift and go to state 23
    empty                          shift and go to state 24

state 13

    (21) dec_func -> FUNCTION . type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (22) dec_func -> FUNCTION . VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (31) type -> . INT
    (32) type -> . FLOAT
    (33) type -> . CHAR

    VOID            shift and go to state 26
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    type                           shift and go to state 25

state 14

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs . main_body
    (8) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body

    MAIN            shift and go to state 12

    main_body                      shift and go to state 27

state 15

    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body .

    $end            reduce using rule 2 (start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body .)


state 16

    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body .

    $end            reduce using rule 3 (start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body .)


state 17

    (11) vars -> VAR varss .

    MAIN            reduce using rule 11 (vars -> VAR varss .)
    FUNCTION        reduce using rule 11 (vars -> VAR varss .)


state 18

    (12) varss -> type . guardarTipo mvar SEMICOLON varss
    (13) varss -> type . guardarTipo mvar SEMICOLON
    (14) guardarTipo -> . empty
    (131) empty -> .

    ID              reduce using rule 131 (empty -> .)

    guardarTipo                    shift and go to state 28
    empty                          shift and go to state 29

state 19

    (31) type -> INT .

    ID              reduce using rule 31 (type -> INT .)


state 20

    (32) type -> FLOAT .

    ID              reduce using rule 32 (type -> FLOAT .)


state 21

    (33) type -> CHAR .

    ID              reduce using rule 33 (type -> CHAR .)


state 22

    (7) multiple_funcs -> dec_func multiple_funcs .

    MAIN            reduce using rule 7 (multiple_funcs -> dec_func multiple_funcs .)


state 23

    (8) main_body -> MAIN crearTablaMain . PARENOPEN PARENCLOSE gotoMain body

    PARENOPEN       shift and go to state 30


state 24

    (9) crearTablaMain -> empty .

    PARENOPEN       reduce using rule 9 (crearTablaMain -> empty .)


state 25

    (21) dec_func -> FUNCTION type . ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc

    ID              shift and go to state 31


state 26

    (22) dec_func -> FUNCTION VOID . ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc

    ID              shift and go to state 32


state 27

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body .

    $end            reduce using rule 1 (start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body .)


state 28

    (12) varss -> type guardarTipo . mvar SEMICOLON varss
    (13) varss -> type guardarTipo . mvar SEMICOLON
    (15) mvar -> . ID COLON mvar
    (16) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> . ID
    (19) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (20) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 34

    mvar                           shift and go to state 33

state 29

    (14) guardarTipo -> empty .

    ID              reduce using rule 14 (guardarTipo -> empty .)


state 30

    (8) main_body -> MAIN crearTablaMain PARENOPEN . PARENCLOSE gotoMain body

    PARENCLOSE      shift and go to state 35


state 31

    (21) dec_func -> FUNCTION type ID . crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (23) crearSymbolTable -> . empty
    (131) empty -> .

    PARENOPEN       reduce using rule 131 (empty -> .)

    crearSymbolTable               shift and go to state 36
    empty                          shift and go to state 37

state 32

    (22) dec_func -> FUNCTION VOID ID . crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (23) crearSymbolTable -> . empty
    (131) empty -> .

    PARENOPEN       reduce using rule 131 (empty -> .)

    crearSymbolTable               shift and go to state 38
    empty                          shift and go to state 37

state 33

    (12) varss -> type guardarTipo mvar . SEMICOLON varss
    (13) varss -> type guardarTipo mvar . SEMICOLON

    SEMICOLON       shift and go to state 39


state 34

    (15) mvar -> ID . COLON mvar
    (16) mvar -> ID . BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> ID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> ID .
    (19) mvar -> ID . BRACEOPEN CTEINT BRACECLOSE
    (20) mvar -> ID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 40
    BRACEOPEN       shift and go to state 41
    SEMICOLON       reduce using rule 18 (mvar -> ID .)


state 35

    (8) main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE . gotoMain body
    (10) gotoMain -> . empty
    (131) empty -> .

    BRACKETOPEN     reduce using rule 131 (empty -> .)

    gotoMain                       shift and go to state 42
    empty                          shift and go to state 43

state 36

    (21) dec_func -> FUNCTION type ID crearSymbolTable . PARENOPEN param PARENCLOSE body exitFunc

    PARENOPEN       shift and go to state 44


state 37

    (23) crearSymbolTable -> empty .

    PARENOPEN       reduce using rule 23 (crearSymbolTable -> empty .)


state 38

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable . PARENOPEN param PARENCLOSE body exitFunc

    PARENOPEN       shift and go to state 45


state 39

    (12) varss -> type guardarTipo mvar SEMICOLON . varss
    (13) varss -> type guardarTipo mvar SEMICOLON .
    (12) varss -> . type guardarTipo mvar SEMICOLON varss
    (13) varss -> . type guardarTipo mvar SEMICOLON
    (31) type -> . INT
    (32) type -> . FLOAT
    (33) type -> . CHAR

    MAIN            reduce using rule 13 (varss -> type guardarTipo mvar SEMICOLON .)
    FUNCTION        reduce using rule 13 (varss -> type guardarTipo mvar SEMICOLON .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    type                           shift and go to state 18
    varss                          shift and go to state 46

state 40

    (15) mvar -> ID COLON . mvar
    (15) mvar -> . ID COLON mvar
    (16) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> . ID
    (19) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (20) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 34

    mvar                           shift and go to state 47

state 41

    (16) mvar -> ID BRACEOPEN . CTEINT BRACECLOSE COLON mvar
    (17) mvar -> ID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (19) mvar -> ID BRACEOPEN . CTEINT BRACECLOSE
    (20) mvar -> ID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    CTEINT          shift and go to state 48


state 42

    (8) main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain . body
    (34) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 49

state 43

    (10) gotoMain -> empty .

    BRACKETOPEN     reduce using rule 10 (gotoMain -> empty .)


state 44

    (21) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN . param PARENCLOSE body exitFunc
    (25) param -> . typeParam ID
    (26) param -> . typeParam ID COLON param
    (27) param -> . empty
    (28) typeParam -> . INT
    (29) typeParam -> . FLOAT
    (30) typeParam -> . CHAR
    (131) empty -> .

    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    CHAR            shift and go to state 56
    PARENCLOSE      reduce using rule 131 (empty -> .)

    param                          shift and go to state 51
    typeParam                      shift and go to state 52
    empty                          shift and go to state 53

state 45

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN . param PARENCLOSE body exitFunc
    (25) param -> . typeParam ID
    (26) param -> . typeParam ID COLON param
    (27) param -> . empty
    (28) typeParam -> . INT
    (29) typeParam -> . FLOAT
    (30) typeParam -> . CHAR
    (131) empty -> .

    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    CHAR            shift and go to state 56
    PARENCLOSE      reduce using rule 131 (empty -> .)

    param                          shift and go to state 57
    typeParam                      shift and go to state 52
    empty                          shift and go to state 53

state 46

    (12) varss -> type guardarTipo mvar SEMICOLON varss .

    MAIN            reduce using rule 12 (varss -> type guardarTipo mvar SEMICOLON varss .)
    FUNCTION        reduce using rule 12 (varss -> type guardarTipo mvar SEMICOLON varss .)


state 47

    (15) mvar -> ID COLON mvar .

    SEMICOLON       reduce using rule 15 (mvar -> ID COLON mvar .)


state 48

    (16) mvar -> ID BRACEOPEN CTEINT . BRACECLOSE COLON mvar
    (17) mvar -> ID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (19) mvar -> ID BRACEOPEN CTEINT . BRACECLOSE
    (20) mvar -> ID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    BRACECLOSE      shift and go to state 58


state 49

    (8) main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body .

    $end            reduce using rule 8 (main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body .)


state 50

    (34) body -> BRACKETOPEN . bodyy BRACKETCLOSE
    (35) bodyy -> . statement
    (36) bodyy -> . statement bodyy
    (37) bodyy -> . empty
    (38) statement -> . dec_variables
    (39) statement -> . assignment
    (40) statement -> . condition
    (41) statement -> . writing
    (42) statement -> . reading
    (43) statement -> . call_func
    (44) statement -> . graph
    (45) statement -> . return
    (46) statement -> . while_loop
    (47) statement -> . for_loop
    (48) statement -> . max
    (49) statement -> . min
    (50) statement -> . sum
    (51) statement -> . normal
    (52) statement -> . uniforme
    (53) statement -> . poisson
    (54) statement -> . binomial
    (131) empty -> .
    (55) dec_variables -> . dec_variabless
    (64) assignment -> . variableAssignment EQUAL exp SEMICOLON
    (99) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
    (100) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (105) writing -> . PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
    (111) reading -> . READ multivariables SEMICOLON
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE
    (69) graph -> . PLOT PARENOPEN exp PARENCLOSE SEMICOLON
    (121) return -> . RETURN exp SEMICOLON
    (114) while_loop -> . WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (118) for_loop -> . FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd
    (122) max -> . MAX PARENOPEN exp PARENCLOSE SEMICOLON
    (123) min -> . MIN PARENOPEN exp PARENCLOSE SEMICOLON
    (124) sum -> . SUM PARENOPEN exp PARENCLOSE SEMICOLON
    (130) normal -> . NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (129) uniforme -> . UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON
    (128) poisson -> . POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON
    (127) binomial -> . BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (56) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON dec_variabless
    (57) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON
    (96) variableAssignment -> . ID
    (97) variableAssignment -> . ID BRACEOPEN exp BRACECLOSE
    (98) variableAssignment -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (31) type -> . INT
    (32) type -> . FLOAT
    (33) type -> . CHAR

    BRACKETCLOSE    reduce using rule 131 (empty -> .)
    IF              shift and go to state 81
    PRINT           shift and go to state 82
    READ            shift and go to state 83
    ID              shift and go to state 84
    PLOT            shift and go to state 85
    RETURN          shift and go to state 86
    WHILE           shift and go to state 87
    FOR             shift and go to state 88
    MAX             shift and go to state 89
    MIN             shift and go to state 90
    SUM             shift and go to state 91
    NORMAL          shift and go to state 92
    UNIFORME        shift and go to state 93
    POISSON         shift and go to state 94
    BINOMIAL        shift and go to state 95
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    bodyy                          shift and go to state 59
    statement                      shift and go to state 60
    empty                          shift and go to state 61
    dec_variables                  shift and go to state 62
    assignment                     shift and go to state 63
    condition                      shift and go to state 64
    writing                        shift and go to state 65
    reading                        shift and go to state 66
    call_func                      shift and go to state 67
    graph                          shift and go to state 68
    return                         shift and go to state 69
    while_loop                     shift and go to state 70
    for_loop                       shift and go to state 71
    max                            shift and go to state 72
    min                            shift and go to state 73
    sum                            shift and go to state 74
    normal                         shift and go to state 75
    uniforme                       shift and go to state 76
    poisson                        shift and go to state 77
    binomial                       shift and go to state 78
    dec_variabless                 shift and go to state 79
    variableAssignment             shift and go to state 80
    type                           shift and go to state 96

state 51

    (21) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param . PARENCLOSE body exitFunc

    PARENCLOSE      shift and go to state 97


state 52

    (25) param -> typeParam . ID
    (26) param -> typeParam . ID COLON param

    ID              shift and go to state 98


state 53

    (27) param -> empty .

    PARENCLOSE      reduce using rule 27 (param -> empty .)


state 54

    (28) typeParam -> INT .

    ID              reduce using rule 28 (typeParam -> INT .)


state 55

    (29) typeParam -> FLOAT .

    ID              reduce using rule 29 (typeParam -> FLOAT .)


state 56

    (30) typeParam -> CHAR .

    ID              reduce using rule 30 (typeParam -> CHAR .)


state 57

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param . PARENCLOSE body exitFunc

    PARENCLOSE      shift and go to state 99


state 58

    (16) mvar -> ID BRACEOPEN CTEINT BRACECLOSE . COLON mvar
    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (19) mvar -> ID BRACEOPEN CTEINT BRACECLOSE .
    (20) mvar -> ID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 101
    BRACEOPEN       shift and go to state 100
    SEMICOLON       reduce using rule 19 (mvar -> ID BRACEOPEN CTEINT BRACECLOSE .)


state 59

    (34) body -> BRACKETOPEN bodyy . BRACKETCLOSE

    BRACKETCLOSE    shift and go to state 102


state 60

    (35) bodyy -> statement .
    (36) bodyy -> statement . bodyy
    (35) bodyy -> . statement
    (36) bodyy -> . statement bodyy
    (37) bodyy -> . empty
    (38) statement -> . dec_variables
    (39) statement -> . assignment
    (40) statement -> . condition
    (41) statement -> . writing
    (42) statement -> . reading
    (43) statement -> . call_func
    (44) statement -> . graph
    (45) statement -> . return
    (46) statement -> . while_loop
    (47) statement -> . for_loop
    (48) statement -> . max
    (49) statement -> . min
    (50) statement -> . sum
    (51) statement -> . normal
    (52) statement -> . uniforme
    (53) statement -> . poisson
    (54) statement -> . binomial
    (131) empty -> .
    (55) dec_variables -> . dec_variabless
    (64) assignment -> . variableAssignment EQUAL exp SEMICOLON
    (99) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
    (100) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (105) writing -> . PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
    (111) reading -> . READ multivariables SEMICOLON
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE
    (69) graph -> . PLOT PARENOPEN exp PARENCLOSE SEMICOLON
    (121) return -> . RETURN exp SEMICOLON
    (114) while_loop -> . WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (118) for_loop -> . FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd
    (122) max -> . MAX PARENOPEN exp PARENCLOSE SEMICOLON
    (123) min -> . MIN PARENOPEN exp PARENCLOSE SEMICOLON
    (124) sum -> . SUM PARENOPEN exp PARENCLOSE SEMICOLON
    (130) normal -> . NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (129) uniforme -> . UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON
    (128) poisson -> . POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON
    (127) binomial -> . BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (56) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON dec_variabless
    (57) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON
    (96) variableAssignment -> . ID
    (97) variableAssignment -> . ID BRACEOPEN exp BRACECLOSE
    (98) variableAssignment -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (31) type -> . INT
    (32) type -> . FLOAT
    (33) type -> . CHAR

  ! reduce/reduce conflict for BRACKETCLOSE resolved using rule 35 (bodyy -> statement .)
    BRACKETCLOSE    reduce using rule 35 (bodyy -> statement .)
    IF              shift and go to state 81
    PRINT           shift and go to state 82
    READ            shift and go to state 83
    ID              shift and go to state 84
    PLOT            shift and go to state 85
    RETURN          shift and go to state 86
    WHILE           shift and go to state 87
    FOR             shift and go to state 88
    MAX             shift and go to state 89
    MIN             shift and go to state 90
    SUM             shift and go to state 91
    NORMAL          shift and go to state 92
    UNIFORME        shift and go to state 93
    POISSON         shift and go to state 94
    BINOMIAL        shift and go to state 95
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

  ! BRACKETCLOSE    [ reduce using rule 131 (empty -> .) ]

    statement                      shift and go to state 60
    bodyy                          shift and go to state 103
    empty                          shift and go to state 61
    dec_variables                  shift and go to state 62
    assignment                     shift and go to state 63
    condition                      shift and go to state 64
    writing                        shift and go to state 65
    reading                        shift and go to state 66
    call_func                      shift and go to state 67
    graph                          shift and go to state 68
    return                         shift and go to state 69
    while_loop                     shift and go to state 70
    for_loop                       shift and go to state 71
    max                            shift and go to state 72
    min                            shift and go to state 73
    sum                            shift and go to state 74
    normal                         shift and go to state 75
    uniforme                       shift and go to state 76
    poisson                        shift and go to state 77
    binomial                       shift and go to state 78
    dec_variabless                 shift and go to state 79
    variableAssignment             shift and go to state 80
    type                           shift and go to state 96

state 61

    (37) bodyy -> empty .

    BRACKETCLOSE    reduce using rule 37 (bodyy -> empty .)


state 62

    (38) statement -> dec_variables .

    IF              reduce using rule 38 (statement -> dec_variables .)
    PRINT           reduce using rule 38 (statement -> dec_variables .)
    READ            reduce using rule 38 (statement -> dec_variables .)
    ID              reduce using rule 38 (statement -> dec_variables .)
    PLOT            reduce using rule 38 (statement -> dec_variables .)
    RETURN          reduce using rule 38 (statement -> dec_variables .)
    WHILE           reduce using rule 38 (statement -> dec_variables .)
    FOR             reduce using rule 38 (statement -> dec_variables .)
    MAX             reduce using rule 38 (statement -> dec_variables .)
    MIN             reduce using rule 38 (statement -> dec_variables .)
    SUM             reduce using rule 38 (statement -> dec_variables .)
    NORMAL          reduce using rule 38 (statement -> dec_variables .)
    UNIFORME        reduce using rule 38 (statement -> dec_variables .)
    POISSON         reduce using rule 38 (statement -> dec_variables .)
    BINOMIAL        reduce using rule 38 (statement -> dec_variables .)
    INT             reduce using rule 38 (statement -> dec_variables .)
    FLOAT           reduce using rule 38 (statement -> dec_variables .)
    CHAR            reduce using rule 38 (statement -> dec_variables .)
    BRACKETCLOSE    reduce using rule 38 (statement -> dec_variables .)


state 63

    (39) statement -> assignment .

    IF              reduce using rule 39 (statement -> assignment .)
    PRINT           reduce using rule 39 (statement -> assignment .)
    READ            reduce using rule 39 (statement -> assignment .)
    ID              reduce using rule 39 (statement -> assignment .)
    PLOT            reduce using rule 39 (statement -> assignment .)
    RETURN          reduce using rule 39 (statement -> assignment .)
    WHILE           reduce using rule 39 (statement -> assignment .)
    FOR             reduce using rule 39 (statement -> assignment .)
    MAX             reduce using rule 39 (statement -> assignment .)
    MIN             reduce using rule 39 (statement -> assignment .)
    SUM             reduce using rule 39 (statement -> assignment .)
    NORMAL          reduce using rule 39 (statement -> assignment .)
    UNIFORME        reduce using rule 39 (statement -> assignment .)
    POISSON         reduce using rule 39 (statement -> assignment .)
    BINOMIAL        reduce using rule 39 (statement -> assignment .)
    INT             reduce using rule 39 (statement -> assignment .)
    FLOAT           reduce using rule 39 (statement -> assignment .)
    CHAR            reduce using rule 39 (statement -> assignment .)
    BRACKETCLOSE    reduce using rule 39 (statement -> assignment .)


state 64

    (40) statement -> condition .

    IF              reduce using rule 40 (statement -> condition .)
    PRINT           reduce using rule 40 (statement -> condition .)
    READ            reduce using rule 40 (statement -> condition .)
    ID              reduce using rule 40 (statement -> condition .)
    PLOT            reduce using rule 40 (statement -> condition .)
    RETURN          reduce using rule 40 (statement -> condition .)
    WHILE           reduce using rule 40 (statement -> condition .)
    FOR             reduce using rule 40 (statement -> condition .)
    MAX             reduce using rule 40 (statement -> condition .)
    MIN             reduce using rule 40 (statement -> condition .)
    SUM             reduce using rule 40 (statement -> condition .)
    NORMAL          reduce using rule 40 (statement -> condition .)
    UNIFORME        reduce using rule 40 (statement -> condition .)
    POISSON         reduce using rule 40 (statement -> condition .)
    BINOMIAL        reduce using rule 40 (statement -> condition .)
    INT             reduce using rule 40 (statement -> condition .)
    FLOAT           reduce using rule 40 (statement -> condition .)
    CHAR            reduce using rule 40 (statement -> condition .)
    BRACKETCLOSE    reduce using rule 40 (statement -> condition .)


state 65

    (41) statement -> writing .

    IF              reduce using rule 41 (statement -> writing .)
    PRINT           reduce using rule 41 (statement -> writing .)
    READ            reduce using rule 41 (statement -> writing .)
    ID              reduce using rule 41 (statement -> writing .)
    PLOT            reduce using rule 41 (statement -> writing .)
    RETURN          reduce using rule 41 (statement -> writing .)
    WHILE           reduce using rule 41 (statement -> writing .)
    FOR             reduce using rule 41 (statement -> writing .)
    MAX             reduce using rule 41 (statement -> writing .)
    MIN             reduce using rule 41 (statement -> writing .)
    SUM             reduce using rule 41 (statement -> writing .)
    NORMAL          reduce using rule 41 (statement -> writing .)
    UNIFORME        reduce using rule 41 (statement -> writing .)
    POISSON         reduce using rule 41 (statement -> writing .)
    BINOMIAL        reduce using rule 41 (statement -> writing .)
    INT             reduce using rule 41 (statement -> writing .)
    FLOAT           reduce using rule 41 (statement -> writing .)
    CHAR            reduce using rule 41 (statement -> writing .)
    BRACKETCLOSE    reduce using rule 41 (statement -> writing .)


state 66

    (42) statement -> reading .

    IF              reduce using rule 42 (statement -> reading .)
    PRINT           reduce using rule 42 (statement -> reading .)
    READ            reduce using rule 42 (statement -> reading .)
    ID              reduce using rule 42 (statement -> reading .)
    PLOT            reduce using rule 42 (statement -> reading .)
    RETURN          reduce using rule 42 (statement -> reading .)
    WHILE           reduce using rule 42 (statement -> reading .)
    FOR             reduce using rule 42 (statement -> reading .)
    MAX             reduce using rule 42 (statement -> reading .)
    MIN             reduce using rule 42 (statement -> reading .)
    SUM             reduce using rule 42 (statement -> reading .)
    NORMAL          reduce using rule 42 (statement -> reading .)
    UNIFORME        reduce using rule 42 (statement -> reading .)
    POISSON         reduce using rule 42 (statement -> reading .)
    BINOMIAL        reduce using rule 42 (statement -> reading .)
    INT             reduce using rule 42 (statement -> reading .)
    FLOAT           reduce using rule 42 (statement -> reading .)
    CHAR            reduce using rule 42 (statement -> reading .)
    BRACKETCLOSE    reduce using rule 42 (statement -> reading .)


state 67

    (43) statement -> call_func .

    IF              reduce using rule 43 (statement -> call_func .)
    PRINT           reduce using rule 43 (statement -> call_func .)
    READ            reduce using rule 43 (statement -> call_func .)
    ID              reduce using rule 43 (statement -> call_func .)
    PLOT            reduce using rule 43 (statement -> call_func .)
    RETURN          reduce using rule 43 (statement -> call_func .)
    WHILE           reduce using rule 43 (statement -> call_func .)
    FOR             reduce using rule 43 (statement -> call_func .)
    MAX             reduce using rule 43 (statement -> call_func .)
    MIN             reduce using rule 43 (statement -> call_func .)
    SUM             reduce using rule 43 (statement -> call_func .)
    NORMAL          reduce using rule 43 (statement -> call_func .)
    UNIFORME        reduce using rule 43 (statement -> call_func .)
    POISSON         reduce using rule 43 (statement -> call_func .)
    BINOMIAL        reduce using rule 43 (statement -> call_func .)
    INT             reduce using rule 43 (statement -> call_func .)
    FLOAT           reduce using rule 43 (statement -> call_func .)
    CHAR            reduce using rule 43 (statement -> call_func .)
    BRACKETCLOSE    reduce using rule 43 (statement -> call_func .)


state 68

    (44) statement -> graph .

    IF              reduce using rule 44 (statement -> graph .)
    PRINT           reduce using rule 44 (statement -> graph .)
    READ            reduce using rule 44 (statement -> graph .)
    ID              reduce using rule 44 (statement -> graph .)
    PLOT            reduce using rule 44 (statement -> graph .)
    RETURN          reduce using rule 44 (statement -> graph .)
    WHILE           reduce using rule 44 (statement -> graph .)
    FOR             reduce using rule 44 (statement -> graph .)
    MAX             reduce using rule 44 (statement -> graph .)
    MIN             reduce using rule 44 (statement -> graph .)
    SUM             reduce using rule 44 (statement -> graph .)
    NORMAL          reduce using rule 44 (statement -> graph .)
    UNIFORME        reduce using rule 44 (statement -> graph .)
    POISSON         reduce using rule 44 (statement -> graph .)
    BINOMIAL        reduce using rule 44 (statement -> graph .)
    INT             reduce using rule 44 (statement -> graph .)
    FLOAT           reduce using rule 44 (statement -> graph .)
    CHAR            reduce using rule 44 (statement -> graph .)
    BRACKETCLOSE    reduce using rule 44 (statement -> graph .)


state 69

    (45) statement -> return .

    IF              reduce using rule 45 (statement -> return .)
    PRINT           reduce using rule 45 (statement -> return .)
    READ            reduce using rule 45 (statement -> return .)
    ID              reduce using rule 45 (statement -> return .)
    PLOT            reduce using rule 45 (statement -> return .)
    RETURN          reduce using rule 45 (statement -> return .)
    WHILE           reduce using rule 45 (statement -> return .)
    FOR             reduce using rule 45 (statement -> return .)
    MAX             reduce using rule 45 (statement -> return .)
    MIN             reduce using rule 45 (statement -> return .)
    SUM             reduce using rule 45 (statement -> return .)
    NORMAL          reduce using rule 45 (statement -> return .)
    UNIFORME        reduce using rule 45 (statement -> return .)
    POISSON         reduce using rule 45 (statement -> return .)
    BINOMIAL        reduce using rule 45 (statement -> return .)
    INT             reduce using rule 45 (statement -> return .)
    FLOAT           reduce using rule 45 (statement -> return .)
    CHAR            reduce using rule 45 (statement -> return .)
    BRACKETCLOSE    reduce using rule 45 (statement -> return .)


state 70

    (46) statement -> while_loop .

    IF              reduce using rule 46 (statement -> while_loop .)
    PRINT           reduce using rule 46 (statement -> while_loop .)
    READ            reduce using rule 46 (statement -> while_loop .)
    ID              reduce using rule 46 (statement -> while_loop .)
    PLOT            reduce using rule 46 (statement -> while_loop .)
    RETURN          reduce using rule 46 (statement -> while_loop .)
    WHILE           reduce using rule 46 (statement -> while_loop .)
    FOR             reduce using rule 46 (statement -> while_loop .)
    MAX             reduce using rule 46 (statement -> while_loop .)
    MIN             reduce using rule 46 (statement -> while_loop .)
    SUM             reduce using rule 46 (statement -> while_loop .)
    NORMAL          reduce using rule 46 (statement -> while_loop .)
    UNIFORME        reduce using rule 46 (statement -> while_loop .)
    POISSON         reduce using rule 46 (statement -> while_loop .)
    BINOMIAL        reduce using rule 46 (statement -> while_loop .)
    INT             reduce using rule 46 (statement -> while_loop .)
    FLOAT           reduce using rule 46 (statement -> while_loop .)
    CHAR            reduce using rule 46 (statement -> while_loop .)
    BRACKETCLOSE    reduce using rule 46 (statement -> while_loop .)


state 71

    (47) statement -> for_loop .

    IF              reduce using rule 47 (statement -> for_loop .)
    PRINT           reduce using rule 47 (statement -> for_loop .)
    READ            reduce using rule 47 (statement -> for_loop .)
    ID              reduce using rule 47 (statement -> for_loop .)
    PLOT            reduce using rule 47 (statement -> for_loop .)
    RETURN          reduce using rule 47 (statement -> for_loop .)
    WHILE           reduce using rule 47 (statement -> for_loop .)
    FOR             reduce using rule 47 (statement -> for_loop .)
    MAX             reduce using rule 47 (statement -> for_loop .)
    MIN             reduce using rule 47 (statement -> for_loop .)
    SUM             reduce using rule 47 (statement -> for_loop .)
    NORMAL          reduce using rule 47 (statement -> for_loop .)
    UNIFORME        reduce using rule 47 (statement -> for_loop .)
    POISSON         reduce using rule 47 (statement -> for_loop .)
    BINOMIAL        reduce using rule 47 (statement -> for_loop .)
    INT             reduce using rule 47 (statement -> for_loop .)
    FLOAT           reduce using rule 47 (statement -> for_loop .)
    CHAR            reduce using rule 47 (statement -> for_loop .)
    BRACKETCLOSE    reduce using rule 47 (statement -> for_loop .)


state 72

    (48) statement -> max .

    IF              reduce using rule 48 (statement -> max .)
    PRINT           reduce using rule 48 (statement -> max .)
    READ            reduce using rule 48 (statement -> max .)
    ID              reduce using rule 48 (statement -> max .)
    PLOT            reduce using rule 48 (statement -> max .)
    RETURN          reduce using rule 48 (statement -> max .)
    WHILE           reduce using rule 48 (statement -> max .)
    FOR             reduce using rule 48 (statement -> max .)
    MAX             reduce using rule 48 (statement -> max .)
    MIN             reduce using rule 48 (statement -> max .)
    SUM             reduce using rule 48 (statement -> max .)
    NORMAL          reduce using rule 48 (statement -> max .)
    UNIFORME        reduce using rule 48 (statement -> max .)
    POISSON         reduce using rule 48 (statement -> max .)
    BINOMIAL        reduce using rule 48 (statement -> max .)
    INT             reduce using rule 48 (statement -> max .)
    FLOAT           reduce using rule 48 (statement -> max .)
    CHAR            reduce using rule 48 (statement -> max .)
    BRACKETCLOSE    reduce using rule 48 (statement -> max .)


state 73

    (49) statement -> min .

    IF              reduce using rule 49 (statement -> min .)
    PRINT           reduce using rule 49 (statement -> min .)
    READ            reduce using rule 49 (statement -> min .)
    ID              reduce using rule 49 (statement -> min .)
    PLOT            reduce using rule 49 (statement -> min .)
    RETURN          reduce using rule 49 (statement -> min .)
    WHILE           reduce using rule 49 (statement -> min .)
    FOR             reduce using rule 49 (statement -> min .)
    MAX             reduce using rule 49 (statement -> min .)
    MIN             reduce using rule 49 (statement -> min .)
    SUM             reduce using rule 49 (statement -> min .)
    NORMAL          reduce using rule 49 (statement -> min .)
    UNIFORME        reduce using rule 49 (statement -> min .)
    POISSON         reduce using rule 49 (statement -> min .)
    BINOMIAL        reduce using rule 49 (statement -> min .)
    INT             reduce using rule 49 (statement -> min .)
    FLOAT           reduce using rule 49 (statement -> min .)
    CHAR            reduce using rule 49 (statement -> min .)
    BRACKETCLOSE    reduce using rule 49 (statement -> min .)


state 74

    (50) statement -> sum .

    IF              reduce using rule 50 (statement -> sum .)
    PRINT           reduce using rule 50 (statement -> sum .)
    READ            reduce using rule 50 (statement -> sum .)
    ID              reduce using rule 50 (statement -> sum .)
    PLOT            reduce using rule 50 (statement -> sum .)
    RETURN          reduce using rule 50 (statement -> sum .)
    WHILE           reduce using rule 50 (statement -> sum .)
    FOR             reduce using rule 50 (statement -> sum .)
    MAX             reduce using rule 50 (statement -> sum .)
    MIN             reduce using rule 50 (statement -> sum .)
    SUM             reduce using rule 50 (statement -> sum .)
    NORMAL          reduce using rule 50 (statement -> sum .)
    UNIFORME        reduce using rule 50 (statement -> sum .)
    POISSON         reduce using rule 50 (statement -> sum .)
    BINOMIAL        reduce using rule 50 (statement -> sum .)
    INT             reduce using rule 50 (statement -> sum .)
    FLOAT           reduce using rule 50 (statement -> sum .)
    CHAR            reduce using rule 50 (statement -> sum .)
    BRACKETCLOSE    reduce using rule 50 (statement -> sum .)


state 75

    (51) statement -> normal .

    IF              reduce using rule 51 (statement -> normal .)
    PRINT           reduce using rule 51 (statement -> normal .)
    READ            reduce using rule 51 (statement -> normal .)
    ID              reduce using rule 51 (statement -> normal .)
    PLOT            reduce using rule 51 (statement -> normal .)
    RETURN          reduce using rule 51 (statement -> normal .)
    WHILE           reduce using rule 51 (statement -> normal .)
    FOR             reduce using rule 51 (statement -> normal .)
    MAX             reduce using rule 51 (statement -> normal .)
    MIN             reduce using rule 51 (statement -> normal .)
    SUM             reduce using rule 51 (statement -> normal .)
    NORMAL          reduce using rule 51 (statement -> normal .)
    UNIFORME        reduce using rule 51 (statement -> normal .)
    POISSON         reduce using rule 51 (statement -> normal .)
    BINOMIAL        reduce using rule 51 (statement -> normal .)
    INT             reduce using rule 51 (statement -> normal .)
    FLOAT           reduce using rule 51 (statement -> normal .)
    CHAR            reduce using rule 51 (statement -> normal .)
    BRACKETCLOSE    reduce using rule 51 (statement -> normal .)


state 76

    (52) statement -> uniforme .

    IF              reduce using rule 52 (statement -> uniforme .)
    PRINT           reduce using rule 52 (statement -> uniforme .)
    READ            reduce using rule 52 (statement -> uniforme .)
    ID              reduce using rule 52 (statement -> uniforme .)
    PLOT            reduce using rule 52 (statement -> uniforme .)
    RETURN          reduce using rule 52 (statement -> uniforme .)
    WHILE           reduce using rule 52 (statement -> uniforme .)
    FOR             reduce using rule 52 (statement -> uniforme .)
    MAX             reduce using rule 52 (statement -> uniforme .)
    MIN             reduce using rule 52 (statement -> uniforme .)
    SUM             reduce using rule 52 (statement -> uniforme .)
    NORMAL          reduce using rule 52 (statement -> uniforme .)
    UNIFORME        reduce using rule 52 (statement -> uniforme .)
    POISSON         reduce using rule 52 (statement -> uniforme .)
    BINOMIAL        reduce using rule 52 (statement -> uniforme .)
    INT             reduce using rule 52 (statement -> uniforme .)
    FLOAT           reduce using rule 52 (statement -> uniforme .)
    CHAR            reduce using rule 52 (statement -> uniforme .)
    BRACKETCLOSE    reduce using rule 52 (statement -> uniforme .)


state 77

    (53) statement -> poisson .

    IF              reduce using rule 53 (statement -> poisson .)
    PRINT           reduce using rule 53 (statement -> poisson .)
    READ            reduce using rule 53 (statement -> poisson .)
    ID              reduce using rule 53 (statement -> poisson .)
    PLOT            reduce using rule 53 (statement -> poisson .)
    RETURN          reduce using rule 53 (statement -> poisson .)
    WHILE           reduce using rule 53 (statement -> poisson .)
    FOR             reduce using rule 53 (statement -> poisson .)
    MAX             reduce using rule 53 (statement -> poisson .)
    MIN             reduce using rule 53 (statement -> poisson .)
    SUM             reduce using rule 53 (statement -> poisson .)
    NORMAL          reduce using rule 53 (statement -> poisson .)
    UNIFORME        reduce using rule 53 (statement -> poisson .)
    POISSON         reduce using rule 53 (statement -> poisson .)
    BINOMIAL        reduce using rule 53 (statement -> poisson .)
    INT             reduce using rule 53 (statement -> poisson .)
    FLOAT           reduce using rule 53 (statement -> poisson .)
    CHAR            reduce using rule 53 (statement -> poisson .)
    BRACKETCLOSE    reduce using rule 53 (statement -> poisson .)


state 78

    (54) statement -> binomial .

    IF              reduce using rule 54 (statement -> binomial .)
    PRINT           reduce using rule 54 (statement -> binomial .)
    READ            reduce using rule 54 (statement -> binomial .)
    ID              reduce using rule 54 (statement -> binomial .)
    PLOT            reduce using rule 54 (statement -> binomial .)
    RETURN          reduce using rule 54 (statement -> binomial .)
    WHILE           reduce using rule 54 (statement -> binomial .)
    FOR             reduce using rule 54 (statement -> binomial .)
    MAX             reduce using rule 54 (statement -> binomial .)
    MIN             reduce using rule 54 (statement -> binomial .)
    SUM             reduce using rule 54 (statement -> binomial .)
    NORMAL          reduce using rule 54 (statement -> binomial .)
    UNIFORME        reduce using rule 54 (statement -> binomial .)
    POISSON         reduce using rule 54 (statement -> binomial .)
    BINOMIAL        reduce using rule 54 (statement -> binomial .)
    INT             reduce using rule 54 (statement -> binomial .)
    FLOAT           reduce using rule 54 (statement -> binomial .)
    CHAR            reduce using rule 54 (statement -> binomial .)
    BRACKETCLOSE    reduce using rule 54 (statement -> binomial .)


state 79

    (55) dec_variables -> dec_variabless .

    IF              reduce using rule 55 (dec_variables -> dec_variabless .)
    PRINT           reduce using rule 55 (dec_variables -> dec_variabless .)
    READ            reduce using rule 55 (dec_variables -> dec_variabless .)
    ID              reduce using rule 55 (dec_variables -> dec_variabless .)
    PLOT            reduce using rule 55 (dec_variables -> dec_variabless .)
    RETURN          reduce using rule 55 (dec_variables -> dec_variabless .)
    WHILE           reduce using rule 55 (dec_variables -> dec_variabless .)
    FOR             reduce using rule 55 (dec_variables -> dec_variabless .)
    MAX             reduce using rule 55 (dec_variables -> dec_variabless .)
    MIN             reduce using rule 55 (dec_variables -> dec_variabless .)
    SUM             reduce using rule 55 (dec_variables -> dec_variabless .)
    NORMAL          reduce using rule 55 (dec_variables -> dec_variabless .)
    UNIFORME        reduce using rule 55 (dec_variables -> dec_variabless .)
    POISSON         reduce using rule 55 (dec_variables -> dec_variabless .)
    BINOMIAL        reduce using rule 55 (dec_variables -> dec_variabless .)
    INT             reduce using rule 55 (dec_variables -> dec_variabless .)
    FLOAT           reduce using rule 55 (dec_variables -> dec_variabless .)
    CHAR            reduce using rule 55 (dec_variables -> dec_variabless .)
    BRACKETCLOSE    reduce using rule 55 (dec_variables -> dec_variabless .)


state 80

    (64) assignment -> variableAssignment . EQUAL exp SEMICOLON

    EQUAL           shift and go to state 104


state 81

    (99) condition -> IF . PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
    (100) condition -> IF . PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse

    PARENOPEN       shift and go to state 105


state 82

    (105) writing -> PRINT . PARENOPEN writingg PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 106


state 83

    (111) reading -> READ . multivariables SEMICOLON
    (112) multivariables -> . variable
    (113) multivariables -> . variable COLON multivariables
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 109

    multivariables                 shift and go to state 107
    variable                       shift and go to state 108

state 84

    (65) call_func -> ID . PARENOPEN call_funcc PARENCLOSE
    (96) variableAssignment -> ID .
    (97) variableAssignment -> ID . BRACEOPEN exp BRACECLOSE
    (98) variableAssignment -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    PARENOPEN       shift and go to state 110
    EQUAL           reduce using rule 96 (variableAssignment -> ID .)
    BRACEOPEN       shift and go to state 111


state 85

    (69) graph -> PLOT . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 112


state 86

    (121) return -> RETURN . exp SEMICOLON
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    exp                            shift and go to state 113
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 87

    (114) while_loop -> WHILE . whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (115) whileMigaja -> . empty
    (131) empty -> .

    PARENOPEN       reduce using rule 131 (empty -> .)

    whileMigaja                    shift and go to state 124
    empty                          shift and go to state 125

state 88

    (118) for_loop -> FOR . PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd

    PARENOPEN       shift and go to state 126


state 89

    (122) max -> MAX . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 127


state 90

    (123) min -> MIN . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 128


state 91

    (124) sum -> SUM . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 129


state 92

    (130) normal -> NORMAL . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 130


state 93

    (129) uniforme -> UNIFORME . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 131


state 94

    (128) poisson -> POISSON . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 132


state 95

    (127) binomial -> BINOMIAL . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 133


state 96

    (56) dec_variabless -> type . guardarTipo dec_mvar SEMICOLON dec_variabless
    (57) dec_variabless -> type . guardarTipo dec_mvar SEMICOLON
    (14) guardarTipo -> . empty
    (131) empty -> .

    ID              reduce using rule 131 (empty -> .)

    guardarTipo                    shift and go to state 134
    empty                          shift and go to state 29

state 97

    (21) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE . body exitFunc
    (34) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 135

state 98

    (25) param -> typeParam ID .
    (26) param -> typeParam ID . COLON param

    PARENCLOSE      reduce using rule 25 (param -> typeParam ID .)
    COLON           shift and go to state 136


state 99

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE . body exitFunc
    (34) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 137

state 100

    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE COLON mvar
    (20) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE

    CTEINT          shift and go to state 138


state 101

    (16) mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON . mvar
    (15) mvar -> . ID COLON mvar
    (16) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> . ID
    (19) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (20) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 34

    mvar                           shift and go to state 139

state 102

    (34) body -> BRACKETOPEN bodyy BRACKETCLOSE .

    $end            reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FUNCTION        reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MAIN            reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    ELSE            reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    IF              reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    PRINT           reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    READ            reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    ID              reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    PLOT            reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    RETURN          reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    WHILE           reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FOR             reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MAX             reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MIN             reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    SUM             reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    NORMAL          reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    UNIFORME        reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    POISSON         reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    BINOMIAL        reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    INT             reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FLOAT           reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    CHAR            reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    BRACKETCLOSE    reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)


state 103

    (36) bodyy -> statement bodyy .

    BRACKETCLOSE    reduce using rule 36 (bodyy -> statement bodyy .)


state 104

    (64) assignment -> variableAssignment EQUAL . exp SEMICOLON
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    exp                            shift and go to state 140
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 105

    (99) condition -> IF PARENOPEN . exp PARENCLOSE cuadruploIF body ifEnd
    (100) condition -> IF PARENOPEN . exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    exp                            shift and go to state 141
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 106

    (105) writing -> PRINT PARENOPEN . writingg PARENCLOSE SEMICOLON
    (106) writingg -> . exp
    (107) writingg -> . exp COLON writingg
    (108) writingg -> . auxString
    (109) writingg -> . auxString COLON writingg
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (110) auxString -> . CTESTRING
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 145
    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    writingg                       shift and go to state 142
    exp                            shift and go to state 143
    auxString                      shift and go to state 144
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 107

    (111) reading -> READ multivariables . SEMICOLON

    SEMICOLON       shift and go to state 146


state 108

    (112) multivariables -> variable .
    (113) multivariables -> variable . COLON multivariables

    SEMICOLON       reduce using rule 112 (multivariables -> variable .)
    COLON           shift and go to state 147


state 109

    (93) variable -> ID .
    (94) variable -> ID . BRACEOPEN exp BRACECLOSE
    (95) variable -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    COLON           reduce using rule 93 (variable -> ID .)
    SEMICOLON       reduce using rule 93 (variable -> ID .)
    EQUAL           reduce using rule 93 (variable -> ID .)
    PARENCLOSE      reduce using rule 93 (variable -> ID .)
    BRACEOPEN       shift and go to state 148


state 110

    (65) call_func -> ID PARENOPEN . call_funcc PARENCLOSE
    (66) call_funcc -> . exp
    (67) call_funcc -> . exp COLON call_funcc
    (68) call_funcc -> . empty
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (131) empty -> .
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENCLOSE      reduce using rule 131 (empty -> .)
    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    call_funcc                     shift and go to state 149
    exp                            shift and go to state 150
    empty                          shift and go to state 151
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 111

    (97) variableAssignment -> ID BRACEOPEN . exp BRACECLOSE
    (98) variableAssignment -> ID BRACEOPEN . exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    exp                            shift and go to state 152
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 112

    (69) graph -> PLOT PARENOPEN . exp PARENCLOSE SEMICOLON
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    exp                            shift and go to state 153
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 113

    (121) return -> RETURN exp . SEMICOLON
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp

    SEMICOLON       shift and go to state 154
    AND             shift and go to state 155
    OR              shift and go to state 156


state 114

    (70) exp -> expp .
    (74) expp -> expp . GREATHERTHAN m_exp
    (75) expp -> expp . LESSTHAN m_exp
    (76) expp -> expp . GREATHEREQUAL m_exp
    (77) expp -> expp . LESSEQUAL m_exp
    (78) expp -> expp . DIFFERENT m_exp
    (79) expp -> expp . SAME m_exp

    SEMICOLON       reduce using rule 70 (exp -> expp .)
    AND             reduce using rule 70 (exp -> expp .)
    OR              reduce using rule 70 (exp -> expp .)
    PARENCLOSE      reduce using rule 70 (exp -> expp .)
    COLON           reduce using rule 70 (exp -> expp .)
    BRACECLOSE      reduce using rule 70 (exp -> expp .)
    TO              reduce using rule 70 (exp -> expp .)
    GREATHERTHAN    shift and go to state 157
    LESSTHAN        shift and go to state 158
    GREATHEREQUAL   shift and go to state 159
    LESSEQUAL       shift and go to state 160
    DIFFERENT       shift and go to state 161
    SAME            shift and go to state 162


state 115

    (73) expp -> m_exp .
    (81) m_exp -> m_exp . PLUS termino
    (82) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 73 (expp -> m_exp .)
    LESSTHAN        reduce using rule 73 (expp -> m_exp .)
    GREATHEREQUAL   reduce using rule 73 (expp -> m_exp .)
    LESSEQUAL       reduce using rule 73 (expp -> m_exp .)
    DIFFERENT       reduce using rule 73 (expp -> m_exp .)
    SAME            reduce using rule 73 (expp -> m_exp .)
    SEMICOLON       reduce using rule 73 (expp -> m_exp .)
    AND             reduce using rule 73 (expp -> m_exp .)
    OR              reduce using rule 73 (expp -> m_exp .)
    PARENCLOSE      reduce using rule 73 (expp -> m_exp .)
    COLON           reduce using rule 73 (expp -> m_exp .)
    BRACECLOSE      reduce using rule 73 (expp -> m_exp .)
    TO              reduce using rule 73 (expp -> m_exp .)
    PLUS            shift and go to state 163
    MINUS           shift and go to state 164


state 116

    (80) m_exp -> termino .
    (84) termino -> termino . MULTIPLY factor
    (85) termino -> termino . DIVIDE factor

    PLUS            reduce using rule 80 (m_exp -> termino .)
    MINUS           reduce using rule 80 (m_exp -> termino .)
    GREATHERTHAN    reduce using rule 80 (m_exp -> termino .)
    LESSTHAN        reduce using rule 80 (m_exp -> termino .)
    GREATHEREQUAL   reduce using rule 80 (m_exp -> termino .)
    LESSEQUAL       reduce using rule 80 (m_exp -> termino .)
    DIFFERENT       reduce using rule 80 (m_exp -> termino .)
    SAME            reduce using rule 80 (m_exp -> termino .)
    SEMICOLON       reduce using rule 80 (m_exp -> termino .)
    AND             reduce using rule 80 (m_exp -> termino .)
    OR              reduce using rule 80 (m_exp -> termino .)
    PARENCLOSE      reduce using rule 80 (m_exp -> termino .)
    COLON           reduce using rule 80 (m_exp -> termino .)
    BRACECLOSE      reduce using rule 80 (m_exp -> termino .)
    TO              reduce using rule 80 (m_exp -> termino .)
    MULTIPLY        shift and go to state 165
    DIVIDE          shift and go to state 166


state 117

    (83) termino -> factor .

    MULTIPLY        reduce using rule 83 (termino -> factor .)
    DIVIDE          reduce using rule 83 (termino -> factor .)
    PLUS            reduce using rule 83 (termino -> factor .)
    MINUS           reduce using rule 83 (termino -> factor .)
    GREATHERTHAN    reduce using rule 83 (termino -> factor .)
    LESSTHAN        reduce using rule 83 (termino -> factor .)
    GREATHEREQUAL   reduce using rule 83 (termino -> factor .)
    LESSEQUAL       reduce using rule 83 (termino -> factor .)
    DIFFERENT       reduce using rule 83 (termino -> factor .)
    SAME            reduce using rule 83 (termino -> factor .)
    SEMICOLON       reduce using rule 83 (termino -> factor .)
    AND             reduce using rule 83 (termino -> factor .)
    OR              reduce using rule 83 (termino -> factor .)
    PARENCLOSE      reduce using rule 83 (termino -> factor .)
    COLON           reduce using rule 83 (termino -> factor .)
    BRACECLOSE      reduce using rule 83 (termino -> factor .)
    TO              reduce using rule 83 (termino -> factor .)


state 118

    (86) factor -> ID .
    (93) variable -> ID .
    (94) variable -> ID . BRACEOPEN exp BRACECLOSE
    (95) variable -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> ID . PARENOPEN call_funcc PARENCLOSE

  ! reduce/reduce conflict for MULTIPLY resolved using rule 86 (factor -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 86 (factor -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 86 (factor -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 86 (factor -> ID .)
  ! reduce/reduce conflict for GREATHERTHAN resolved using rule 86 (factor -> ID .)
  ! reduce/reduce conflict for LESSTHAN resolved using rule 86 (factor -> ID .)
  ! reduce/reduce conflict for GREATHEREQUAL resolved using rule 86 (factor -> ID .)
  ! reduce/reduce conflict for LESSEQUAL resolved using rule 86 (factor -> ID .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 86 (factor -> ID .)
  ! reduce/reduce conflict for SAME resolved using rule 86 (factor -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 86 (factor -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 86 (factor -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 86 (factor -> ID .)
  ! reduce/reduce conflict for PARENCLOSE resolved using rule 86 (factor -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 86 (factor -> ID .)
  ! reduce/reduce conflict for BRACECLOSE resolved using rule 86 (factor -> ID .)
  ! reduce/reduce conflict for TO resolved using rule 86 (factor -> ID .)
    MULTIPLY        reduce using rule 86 (factor -> ID .)
    DIVIDE          reduce using rule 86 (factor -> ID .)
    PLUS            reduce using rule 86 (factor -> ID .)
    MINUS           reduce using rule 86 (factor -> ID .)
    GREATHERTHAN    reduce using rule 86 (factor -> ID .)
    LESSTHAN        reduce using rule 86 (factor -> ID .)
    GREATHEREQUAL   reduce using rule 86 (factor -> ID .)
    LESSEQUAL       reduce using rule 86 (factor -> ID .)
    DIFFERENT       reduce using rule 86 (factor -> ID .)
    SAME            reduce using rule 86 (factor -> ID .)
    SEMICOLON       reduce using rule 86 (factor -> ID .)
    AND             reduce using rule 86 (factor -> ID .)
    OR              reduce using rule 86 (factor -> ID .)
    PARENCLOSE      reduce using rule 86 (factor -> ID .)
    COLON           reduce using rule 86 (factor -> ID .)
    BRACECLOSE      reduce using rule 86 (factor -> ID .)
    TO              reduce using rule 86 (factor -> ID .)
    BRACEOPEN       shift and go to state 148
    PARENOPEN       shift and go to state 110

  ! MULTIPLY        [ reduce using rule 93 (variable -> ID .) ]
  ! DIVIDE          [ reduce using rule 93 (variable -> ID .) ]
  ! PLUS            [ reduce using rule 93 (variable -> ID .) ]
  ! MINUS           [ reduce using rule 93 (variable -> ID .) ]
  ! GREATHERTHAN    [ reduce using rule 93 (variable -> ID .) ]
  ! LESSTHAN        [ reduce using rule 93 (variable -> ID .) ]
  ! GREATHEREQUAL   [ reduce using rule 93 (variable -> ID .) ]
  ! LESSEQUAL       [ reduce using rule 93 (variable -> ID .) ]
  ! DIFFERENT       [ reduce using rule 93 (variable -> ID .) ]
  ! SAME            [ reduce using rule 93 (variable -> ID .) ]
  ! SEMICOLON       [ reduce using rule 93 (variable -> ID .) ]
  ! AND             [ reduce using rule 93 (variable -> ID .) ]
  ! OR              [ reduce using rule 93 (variable -> ID .) ]
  ! PARENCLOSE      [ reduce using rule 93 (variable -> ID .) ]
  ! COLON           [ reduce using rule 93 (variable -> ID .) ]
  ! BRACECLOSE      [ reduce using rule 93 (variable -> ID .) ]
  ! TO              [ reduce using rule 93 (variable -> ID .) ]


state 119

    (87) factor -> PARENOPEN . exp PARENCLOSE
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    exp                            shift and go to state 167
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 120

    (88) factor -> CTEINT . guardarConstante
    (92) guardarConstante -> . empty
    (131) empty -> .

    MULTIPLY        reduce using rule 131 (empty -> .)
    DIVIDE          reduce using rule 131 (empty -> .)
    PLUS            reduce using rule 131 (empty -> .)
    MINUS           reduce using rule 131 (empty -> .)
    GREATHERTHAN    reduce using rule 131 (empty -> .)
    LESSTHAN        reduce using rule 131 (empty -> .)
    GREATHEREQUAL   reduce using rule 131 (empty -> .)
    LESSEQUAL       reduce using rule 131 (empty -> .)
    DIFFERENT       reduce using rule 131 (empty -> .)
    SAME            reduce using rule 131 (empty -> .)
    SEMICOLON       reduce using rule 131 (empty -> .)
    AND             reduce using rule 131 (empty -> .)
    OR              reduce using rule 131 (empty -> .)
    PARENCLOSE      reduce using rule 131 (empty -> .)
    COLON           reduce using rule 131 (empty -> .)
    BRACECLOSE      reduce using rule 131 (empty -> .)
    TO              reduce using rule 131 (empty -> .)

    guardarConstante               shift and go to state 168
    empty                          shift and go to state 169

state 121

    (89) factor -> CTFLOAT . guardarConstante
    (92) guardarConstante -> . empty
    (131) empty -> .

    MULTIPLY        reduce using rule 131 (empty -> .)
    DIVIDE          reduce using rule 131 (empty -> .)
    PLUS            reduce using rule 131 (empty -> .)
    MINUS           reduce using rule 131 (empty -> .)
    GREATHERTHAN    reduce using rule 131 (empty -> .)
    LESSTHAN        reduce using rule 131 (empty -> .)
    GREATHEREQUAL   reduce using rule 131 (empty -> .)
    LESSEQUAL       reduce using rule 131 (empty -> .)
    DIFFERENT       reduce using rule 131 (empty -> .)
    SAME            reduce using rule 131 (empty -> .)
    SEMICOLON       reduce using rule 131 (empty -> .)
    AND             reduce using rule 131 (empty -> .)
    OR              reduce using rule 131 (empty -> .)
    PARENCLOSE      reduce using rule 131 (empty -> .)
    COLON           reduce using rule 131 (empty -> .)
    BRACECLOSE      reduce using rule 131 (empty -> .)
    TO              reduce using rule 131 (empty -> .)

    guardarConstante               shift and go to state 170
    empty                          shift and go to state 169

state 122

    (90) factor -> variable .

    MULTIPLY        reduce using rule 90 (factor -> variable .)
    DIVIDE          reduce using rule 90 (factor -> variable .)
    PLUS            reduce using rule 90 (factor -> variable .)
    MINUS           reduce using rule 90 (factor -> variable .)
    GREATHERTHAN    reduce using rule 90 (factor -> variable .)
    LESSTHAN        reduce using rule 90 (factor -> variable .)
    GREATHEREQUAL   reduce using rule 90 (factor -> variable .)
    LESSEQUAL       reduce using rule 90 (factor -> variable .)
    DIFFERENT       reduce using rule 90 (factor -> variable .)
    SAME            reduce using rule 90 (factor -> variable .)
    SEMICOLON       reduce using rule 90 (factor -> variable .)
    AND             reduce using rule 90 (factor -> variable .)
    OR              reduce using rule 90 (factor -> variable .)
    PARENCLOSE      reduce using rule 90 (factor -> variable .)
    COLON           reduce using rule 90 (factor -> variable .)
    BRACECLOSE      reduce using rule 90 (factor -> variable .)
    TO              reduce using rule 90 (factor -> variable .)


state 123

    (91) factor -> call_func .

    MULTIPLY        reduce using rule 91 (factor -> call_func .)
    DIVIDE          reduce using rule 91 (factor -> call_func .)
    PLUS            reduce using rule 91 (factor -> call_func .)
    MINUS           reduce using rule 91 (factor -> call_func .)
    GREATHERTHAN    reduce using rule 91 (factor -> call_func .)
    LESSTHAN        reduce using rule 91 (factor -> call_func .)
    GREATHEREQUAL   reduce using rule 91 (factor -> call_func .)
    LESSEQUAL       reduce using rule 91 (factor -> call_func .)
    DIFFERENT       reduce using rule 91 (factor -> call_func .)
    SAME            reduce using rule 91 (factor -> call_func .)
    SEMICOLON       reduce using rule 91 (factor -> call_func .)
    AND             reduce using rule 91 (factor -> call_func .)
    OR              reduce using rule 91 (factor -> call_func .)
    PARENCLOSE      reduce using rule 91 (factor -> call_func .)
    COLON           reduce using rule 91 (factor -> call_func .)
    BRACECLOSE      reduce using rule 91 (factor -> call_func .)
    TO              reduce using rule 91 (factor -> call_func .)


state 124

    (114) while_loop -> WHILE whileMigaja . PARENOPEN exp PARENCLOSE whileEval body whileEnd

    PARENOPEN       shift and go to state 171


state 125

    (115) whileMigaja -> empty .

    PARENOPEN       reduce using rule 115 (whileMigaja -> empty .)


state 126

    (118) for_loop -> FOR PARENOPEN . variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 109

    variable                       shift and go to state 172

state 127

    (122) max -> MAX PARENOPEN . exp PARENCLOSE SEMICOLON
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    exp                            shift and go to state 173
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 128

    (123) min -> MIN PARENOPEN . exp PARENCLOSE SEMICOLON
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    exp                            shift and go to state 174
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 129

    (124) sum -> SUM PARENOPEN . exp PARENCLOSE SEMICOLON
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    exp                            shift and go to state 175
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 130

    (130) normal -> NORMAL PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (125) param_dist -> . variable
    (126) param_dist -> . variable COLON param_dist
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 109

    param_dist                     shift and go to state 176
    variable                       shift and go to state 177

state 131

    (129) uniforme -> UNIFORME PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (125) param_dist -> . variable
    (126) param_dist -> . variable COLON param_dist
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 109

    param_dist                     shift and go to state 178
    variable                       shift and go to state 177

state 132

    (128) poisson -> POISSON PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (125) param_dist -> . variable
    (126) param_dist -> . variable COLON param_dist
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 109

    param_dist                     shift and go to state 179
    variable                       shift and go to state 177

state 133

    (127) binomial -> BINOMIAL PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (125) param_dist -> . variable
    (126) param_dist -> . variable COLON param_dist
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 109

    param_dist                     shift and go to state 180
    variable                       shift and go to state 177

state 134

    (56) dec_variabless -> type guardarTipo . dec_mvar SEMICOLON dec_variabless
    (57) dec_variabless -> type guardarTipo . dec_mvar SEMICOLON
    (58) dec_mvar -> . ID COLON dec_mvar
    (59) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (60) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (61) dec_mvar -> . ID
    (62) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (63) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 182

    dec_mvar                       shift and go to state 181

state 135

    (21) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body . exitFunc
    (24) exitFunc -> . empty
    (131) empty -> .

    FUNCTION        reduce using rule 131 (empty -> .)
    MAIN            reduce using rule 131 (empty -> .)

    exitFunc                       shift and go to state 183
    empty                          shift and go to state 184

state 136

    (26) param -> typeParam ID COLON . param
    (25) param -> . typeParam ID
    (26) param -> . typeParam ID COLON param
    (27) param -> . empty
    (28) typeParam -> . INT
    (29) typeParam -> . FLOAT
    (30) typeParam -> . CHAR
    (131) empty -> .

    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    CHAR            shift and go to state 56
    PARENCLOSE      reduce using rule 131 (empty -> .)

    typeParam                      shift and go to state 52
    param                          shift and go to state 185
    empty                          shift and go to state 53

state 137

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body . exitFunc
    (24) exitFunc -> . empty
    (131) empty -> .

    FUNCTION        reduce using rule 131 (empty -> .)
    MAIN            reduce using rule 131 (empty -> .)

    exitFunc                       shift and go to state 186
    empty                          shift and go to state 184

state 138

    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE COLON mvar
    (20) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE

    BRACECLOSE      shift and go to state 187


state 139

    (16) mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON mvar .

    SEMICOLON       reduce using rule 16 (mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON mvar .)


state 140

    (64) assignment -> variableAssignment EQUAL exp . SEMICOLON
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp

    SEMICOLON       shift and go to state 188
    AND             shift and go to state 155
    OR              shift and go to state 156


state 141

    (99) condition -> IF PARENOPEN exp . PARENCLOSE cuadruploIF body ifEnd
    (100) condition -> IF PARENOPEN exp . PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 189
    AND             shift and go to state 155
    OR              shift and go to state 156


state 142

    (105) writing -> PRINT PARENOPEN writingg . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 190


state 143

    (106) writingg -> exp .
    (107) writingg -> exp . COLON writingg
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp

    PARENCLOSE      reduce using rule 106 (writingg -> exp .)
    COLON           shift and go to state 191
    AND             shift and go to state 155
    OR              shift and go to state 156


state 144

    (108) writingg -> auxString .
    (109) writingg -> auxString . COLON writingg

    PARENCLOSE      reduce using rule 108 (writingg -> auxString .)
    COLON           shift and go to state 192


state 145

    (110) auxString -> CTESTRING .

    COLON           reduce using rule 110 (auxString -> CTESTRING .)
    PARENCLOSE      reduce using rule 110 (auxString -> CTESTRING .)


state 146

    (111) reading -> READ multivariables SEMICOLON .

    IF              reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    PRINT           reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    READ            reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    ID              reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    PLOT            reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    RETURN          reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    WHILE           reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    FOR             reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    MAX             reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    MIN             reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    SUM             reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    NORMAL          reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    UNIFORME        reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    POISSON         reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    BINOMIAL        reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    INT             reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    FLOAT           reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    CHAR            reduce using rule 111 (reading -> READ multivariables SEMICOLON .)
    BRACKETCLOSE    reduce using rule 111 (reading -> READ multivariables SEMICOLON .)


state 147

    (113) multivariables -> variable COLON . multivariables
    (112) multivariables -> . variable
    (113) multivariables -> . variable COLON multivariables
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 109

    variable                       shift and go to state 108
    multivariables                 shift and go to state 193

state 148

    (94) variable -> ID BRACEOPEN . exp BRACECLOSE
    (95) variable -> ID BRACEOPEN . exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    exp                            shift and go to state 194
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 149

    (65) call_func -> ID PARENOPEN call_funcc . PARENCLOSE

    PARENCLOSE      shift and go to state 195


state 150

    (66) call_funcc -> exp .
    (67) call_funcc -> exp . COLON call_funcc
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp

    PARENCLOSE      reduce using rule 66 (call_funcc -> exp .)
    COLON           shift and go to state 196
    AND             shift and go to state 155
    OR              shift and go to state 156


state 151

    (68) call_funcc -> empty .

    PARENCLOSE      reduce using rule 68 (call_funcc -> empty .)


state 152

    (97) variableAssignment -> ID BRACEOPEN exp . BRACECLOSE
    (98) variableAssignment -> ID BRACEOPEN exp . BRACECLOSE BRACEOPEN exp BRACECLOSE
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp

    BRACECLOSE      shift and go to state 197
    AND             shift and go to state 155
    OR              shift and go to state 156


state 153

    (69) graph -> PLOT PARENOPEN exp . PARENCLOSE SEMICOLON
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 198
    AND             shift and go to state 155
    OR              shift and go to state 156


state 154

    (121) return -> RETURN exp SEMICOLON .

    IF              reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    PRINT           reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    READ            reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    ID              reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    PLOT            reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    RETURN          reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    WHILE           reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    FOR             reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    MAX             reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    MIN             reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    SUM             reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    NORMAL          reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    UNIFORME        reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    POISSON         reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    BINOMIAL        reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    INT             reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    FLOAT           reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    CHAR            reduce using rule 121 (return -> RETURN exp SEMICOLON .)
    BRACKETCLOSE    reduce using rule 121 (return -> RETURN exp SEMICOLON .)


state 155

    (71) exp -> exp AND . expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    expp                           shift and go to state 199
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 156

    (72) exp -> exp OR . expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    expp                           shift and go to state 200
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 157

    (74) expp -> expp GREATHERTHAN . m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    m_exp                          shift and go to state 201
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 158

    (75) expp -> expp LESSTHAN . m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    m_exp                          shift and go to state 202
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 159

    (76) expp -> expp GREATHEREQUAL . m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    m_exp                          shift and go to state 203
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 160

    (77) expp -> expp LESSEQUAL . m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    m_exp                          shift and go to state 204
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 161

    (78) expp -> expp DIFFERENT . m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    m_exp                          shift and go to state 205
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 162

    (79) expp -> expp SAME . m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    m_exp                          shift and go to state 206
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 163

    (81) m_exp -> m_exp PLUS . termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    termino                        shift and go to state 207
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 164

    (82) m_exp -> m_exp MINUS . termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    termino                        shift and go to state 208
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 165

    (84) termino -> termino MULTIPLY . factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    factor                         shift and go to state 209
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 166

    (85) termino -> termino DIVIDE . factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    factor                         shift and go to state 210
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 167

    (87) factor -> PARENOPEN exp . PARENCLOSE
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 211
    AND             shift and go to state 155
    OR              shift and go to state 156


state 168

    (88) factor -> CTEINT guardarConstante .

    MULTIPLY        reduce using rule 88 (factor -> CTEINT guardarConstante .)
    DIVIDE          reduce using rule 88 (factor -> CTEINT guardarConstante .)
    PLUS            reduce using rule 88 (factor -> CTEINT guardarConstante .)
    MINUS           reduce using rule 88 (factor -> CTEINT guardarConstante .)
    GREATHERTHAN    reduce using rule 88 (factor -> CTEINT guardarConstante .)
    LESSTHAN        reduce using rule 88 (factor -> CTEINT guardarConstante .)
    GREATHEREQUAL   reduce using rule 88 (factor -> CTEINT guardarConstante .)
    LESSEQUAL       reduce using rule 88 (factor -> CTEINT guardarConstante .)
    DIFFERENT       reduce using rule 88 (factor -> CTEINT guardarConstante .)
    SAME            reduce using rule 88 (factor -> CTEINT guardarConstante .)
    SEMICOLON       reduce using rule 88 (factor -> CTEINT guardarConstante .)
    AND             reduce using rule 88 (factor -> CTEINT guardarConstante .)
    OR              reduce using rule 88 (factor -> CTEINT guardarConstante .)
    PARENCLOSE      reduce using rule 88 (factor -> CTEINT guardarConstante .)
    COLON           reduce using rule 88 (factor -> CTEINT guardarConstante .)
    BRACECLOSE      reduce using rule 88 (factor -> CTEINT guardarConstante .)
    TO              reduce using rule 88 (factor -> CTEINT guardarConstante .)


state 169

    (92) guardarConstante -> empty .

    MULTIPLY        reduce using rule 92 (guardarConstante -> empty .)
    DIVIDE          reduce using rule 92 (guardarConstante -> empty .)
    PLUS            reduce using rule 92 (guardarConstante -> empty .)
    MINUS           reduce using rule 92 (guardarConstante -> empty .)
    GREATHERTHAN    reduce using rule 92 (guardarConstante -> empty .)
    LESSTHAN        reduce using rule 92 (guardarConstante -> empty .)
    GREATHEREQUAL   reduce using rule 92 (guardarConstante -> empty .)
    LESSEQUAL       reduce using rule 92 (guardarConstante -> empty .)
    DIFFERENT       reduce using rule 92 (guardarConstante -> empty .)
    SAME            reduce using rule 92 (guardarConstante -> empty .)
    SEMICOLON       reduce using rule 92 (guardarConstante -> empty .)
    AND             reduce using rule 92 (guardarConstante -> empty .)
    OR              reduce using rule 92 (guardarConstante -> empty .)
    PARENCLOSE      reduce using rule 92 (guardarConstante -> empty .)
    COLON           reduce using rule 92 (guardarConstante -> empty .)
    BRACECLOSE      reduce using rule 92 (guardarConstante -> empty .)
    TO              reduce using rule 92 (guardarConstante -> empty .)


state 170

    (89) factor -> CTFLOAT guardarConstante .

    MULTIPLY        reduce using rule 89 (factor -> CTFLOAT guardarConstante .)
    DIVIDE          reduce using rule 89 (factor -> CTFLOAT guardarConstante .)
    PLUS            reduce using rule 89 (factor -> CTFLOAT guardarConstante .)
    MINUS           reduce using rule 89 (factor -> CTFLOAT guardarConstante .)
    GREATHERTHAN    reduce using rule 89 (factor -> CTFLOAT guardarConstante .)
    LESSTHAN        reduce using rule 89 (factor -> CTFLOAT guardarConstante .)
    GREATHEREQUAL   reduce using rule 89 (factor -> CTFLOAT guardarConstante .)
    LESSEQUAL       reduce using rule 89 (factor -> CTFLOAT guardarConstante .)
    DIFFERENT       reduce using rule 89 (factor -> CTFLOAT guardarConstante .)
    SAME            reduce using rule 89 (factor -> CTFLOAT guardarConstante .)
    SEMICOLON       reduce using rule 89 (factor -> CTFLOAT guardarConstante .)
    AND             reduce using rule 89 (factor -> CTFLOAT guardarConstante .)
    OR              reduce using rule 89 (factor -> CTFLOAT guardarConstante .)
    PARENCLOSE      reduce using rule 89 (factor -> CTFLOAT guardarConstante .)
    COLON           reduce using rule 89 (factor -> CTFLOAT guardarConstante .)
    BRACECLOSE      reduce using rule 89 (factor -> CTFLOAT guardarConstante .)
    TO              reduce using rule 89 (factor -> CTFLOAT guardarConstante .)


state 171

    (114) while_loop -> WHILE whileMigaja PARENOPEN . exp PARENCLOSE whileEval body whileEnd
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    exp                            shift and go to state 212
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 172

    (118) for_loop -> FOR PARENOPEN variable . EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd

    EQUAL           shift and go to state 213


state 173

    (122) max -> MAX PARENOPEN exp . PARENCLOSE SEMICOLON
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 214
    AND             shift and go to state 155
    OR              shift and go to state 156


state 174

    (123) min -> MIN PARENOPEN exp . PARENCLOSE SEMICOLON
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 215
    AND             shift and go to state 155
    OR              shift and go to state 156


state 175

    (124) sum -> SUM PARENOPEN exp . PARENCLOSE SEMICOLON
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 216
    AND             shift and go to state 155
    OR              shift and go to state 156


state 176

    (130) normal -> NORMAL PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 217


state 177

    (125) param_dist -> variable .
    (126) param_dist -> variable . COLON param_dist

    PARENCLOSE      reduce using rule 125 (param_dist -> variable .)
    COLON           shift and go to state 218


state 178

    (129) uniforme -> UNIFORME PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 219


state 179

    (128) poisson -> POISSON PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 220


state 180

    (127) binomial -> BINOMIAL PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 221


state 181

    (56) dec_variabless -> type guardarTipo dec_mvar . SEMICOLON dec_variabless
    (57) dec_variabless -> type guardarTipo dec_mvar . SEMICOLON

    SEMICOLON       shift and go to state 222


state 182

    (58) dec_mvar -> ID . COLON dec_mvar
    (59) dec_mvar -> ID . BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (60) dec_mvar -> ID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (61) dec_mvar -> ID .
    (62) dec_mvar -> ID . BRACEOPEN CTEINT BRACECLOSE
    (63) dec_mvar -> ID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 223
    BRACEOPEN       shift and go to state 224
    SEMICOLON       reduce using rule 61 (dec_mvar -> ID .)


state 183

    (21) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .

    FUNCTION        reduce using rule 21 (dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .)
    MAIN            reduce using rule 21 (dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .)


state 184

    (24) exitFunc -> empty .

    FUNCTION        reduce using rule 24 (exitFunc -> empty .)
    MAIN            reduce using rule 24 (exitFunc -> empty .)


state 185

    (26) param -> typeParam ID COLON param .

    PARENCLOSE      reduce using rule 26 (param -> typeParam ID COLON param .)


state 186

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .

    FUNCTION        reduce using rule 22 (dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .)
    MAIN            reduce using rule 22 (dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .)


state 187

    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE . COLON mvar
    (20) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .

    COLON           shift and go to state 225
    SEMICOLON       reduce using rule 20 (mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .)


state 188

    (64) assignment -> variableAssignment EQUAL exp SEMICOLON .

    IF              reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    PRINT           reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    READ            reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    ID              reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    PLOT            reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    RETURN          reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    WHILE           reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    FOR             reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    MAX             reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    MIN             reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    SUM             reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    NORMAL          reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    UNIFORME        reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    POISSON         reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    BINOMIAL        reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    INT             reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    FLOAT           reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    CHAR            reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    BRACKETCLOSE    reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)


state 189

    (99) condition -> IF PARENOPEN exp PARENCLOSE . cuadruploIF body ifEnd
    (100) condition -> IF PARENOPEN exp PARENCLOSE . cuadruploIF body cuadruploElse ELSE body ifEndElse
    (101) cuadruploIF -> . empty
    (131) empty -> .

    BRACKETOPEN     reduce using rule 131 (empty -> .)

    cuadruploIF                    shift and go to state 226
    empty                          shift and go to state 227

state 190

    (105) writing -> PRINT PARENOPEN writingg PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 228


state 191

    (107) writingg -> exp COLON . writingg
    (106) writingg -> . exp
    (107) writingg -> . exp COLON writingg
    (108) writingg -> . auxString
    (109) writingg -> . auxString COLON writingg
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (110) auxString -> . CTESTRING
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 145
    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    exp                            shift and go to state 143
    writingg                       shift and go to state 229
    auxString                      shift and go to state 144
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 192

    (109) writingg -> auxString COLON . writingg
    (106) writingg -> . exp
    (107) writingg -> . exp COLON writingg
    (108) writingg -> . auxString
    (109) writingg -> . auxString COLON writingg
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (110) auxString -> . CTESTRING
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 145
    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    auxString                      shift and go to state 144
    writingg                       shift and go to state 230
    exp                            shift and go to state 143
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 193

    (113) multivariables -> variable COLON multivariables .

    SEMICOLON       reduce using rule 113 (multivariables -> variable COLON multivariables .)


state 194

    (94) variable -> ID BRACEOPEN exp . BRACECLOSE
    (95) variable -> ID BRACEOPEN exp . BRACECLOSE BRACEOPEN exp BRACECLOSE
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp

    BRACECLOSE      shift and go to state 231
    AND             shift and go to state 155
    OR              shift and go to state 156


state 195

    (65) call_func -> ID PARENOPEN call_funcc PARENCLOSE .

    IF              reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    PRINT           reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    READ            reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    ID              reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    PLOT            reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    RETURN          reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    WHILE           reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    FOR             reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    MAX             reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    MIN             reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    SUM             reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    NORMAL          reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    UNIFORME        reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    POISSON         reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    BINOMIAL        reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    INT             reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    FLOAT           reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    CHAR            reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    BRACKETCLOSE    reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    MULTIPLY        reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    DIVIDE          reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    PLUS            reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    MINUS           reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    GREATHERTHAN    reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    LESSTHAN        reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    GREATHEREQUAL   reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    LESSEQUAL       reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    DIFFERENT       reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    SAME            reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    SEMICOLON       reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    AND             reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    OR              reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    PARENCLOSE      reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    COLON           reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    BRACECLOSE      reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    TO              reduce using rule 65 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)


state 196

    (67) call_funcc -> exp COLON . call_funcc
    (66) call_funcc -> . exp
    (67) call_funcc -> . exp COLON call_funcc
    (68) call_funcc -> . empty
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (131) empty -> .
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENCLOSE      reduce using rule 131 (empty -> .)
    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    exp                            shift and go to state 150
    call_funcc                     shift and go to state 232
    empty                          shift and go to state 151
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 197

    (97) variableAssignment -> ID BRACEOPEN exp BRACECLOSE .
    (98) variableAssignment -> ID BRACEOPEN exp BRACECLOSE . BRACEOPEN exp BRACECLOSE

    EQUAL           reduce using rule 97 (variableAssignment -> ID BRACEOPEN exp BRACECLOSE .)
    BRACEOPEN       shift and go to state 233


state 198

    (69) graph -> PLOT PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 234


state 199

    (71) exp -> exp AND expp .
    (74) expp -> expp . GREATHERTHAN m_exp
    (75) expp -> expp . LESSTHAN m_exp
    (76) expp -> expp . GREATHEREQUAL m_exp
    (77) expp -> expp . LESSEQUAL m_exp
    (78) expp -> expp . DIFFERENT m_exp
    (79) expp -> expp . SAME m_exp

    SEMICOLON       reduce using rule 71 (exp -> exp AND expp .)
    AND             reduce using rule 71 (exp -> exp AND expp .)
    OR              reduce using rule 71 (exp -> exp AND expp .)
    PARENCLOSE      reduce using rule 71 (exp -> exp AND expp .)
    COLON           reduce using rule 71 (exp -> exp AND expp .)
    BRACECLOSE      reduce using rule 71 (exp -> exp AND expp .)
    TO              reduce using rule 71 (exp -> exp AND expp .)
    GREATHERTHAN    shift and go to state 157
    LESSTHAN        shift and go to state 158
    GREATHEREQUAL   shift and go to state 159
    LESSEQUAL       shift and go to state 160
    DIFFERENT       shift and go to state 161
    SAME            shift and go to state 162


state 200

    (72) exp -> exp OR expp .
    (74) expp -> expp . GREATHERTHAN m_exp
    (75) expp -> expp . LESSTHAN m_exp
    (76) expp -> expp . GREATHEREQUAL m_exp
    (77) expp -> expp . LESSEQUAL m_exp
    (78) expp -> expp . DIFFERENT m_exp
    (79) expp -> expp . SAME m_exp

    SEMICOLON       reduce using rule 72 (exp -> exp OR expp .)
    AND             reduce using rule 72 (exp -> exp OR expp .)
    OR              reduce using rule 72 (exp -> exp OR expp .)
    PARENCLOSE      reduce using rule 72 (exp -> exp OR expp .)
    COLON           reduce using rule 72 (exp -> exp OR expp .)
    BRACECLOSE      reduce using rule 72 (exp -> exp OR expp .)
    TO              reduce using rule 72 (exp -> exp OR expp .)
    GREATHERTHAN    shift and go to state 157
    LESSTHAN        shift and go to state 158
    GREATHEREQUAL   shift and go to state 159
    LESSEQUAL       shift and go to state 160
    DIFFERENT       shift and go to state 161
    SAME            shift and go to state 162


state 201

    (74) expp -> expp GREATHERTHAN m_exp .
    (81) m_exp -> m_exp . PLUS termino
    (82) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 74 (expp -> expp GREATHERTHAN m_exp .)
    LESSTHAN        reduce using rule 74 (expp -> expp GREATHERTHAN m_exp .)
    GREATHEREQUAL   reduce using rule 74 (expp -> expp GREATHERTHAN m_exp .)
    LESSEQUAL       reduce using rule 74 (expp -> expp GREATHERTHAN m_exp .)
    DIFFERENT       reduce using rule 74 (expp -> expp GREATHERTHAN m_exp .)
    SAME            reduce using rule 74 (expp -> expp GREATHERTHAN m_exp .)
    SEMICOLON       reduce using rule 74 (expp -> expp GREATHERTHAN m_exp .)
    AND             reduce using rule 74 (expp -> expp GREATHERTHAN m_exp .)
    OR              reduce using rule 74 (expp -> expp GREATHERTHAN m_exp .)
    PARENCLOSE      reduce using rule 74 (expp -> expp GREATHERTHAN m_exp .)
    COLON           reduce using rule 74 (expp -> expp GREATHERTHAN m_exp .)
    BRACECLOSE      reduce using rule 74 (expp -> expp GREATHERTHAN m_exp .)
    TO              reduce using rule 74 (expp -> expp GREATHERTHAN m_exp .)
    PLUS            shift and go to state 163
    MINUS           shift and go to state 164


state 202

    (75) expp -> expp LESSTHAN m_exp .
    (81) m_exp -> m_exp . PLUS termino
    (82) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 75 (expp -> expp LESSTHAN m_exp .)
    LESSTHAN        reduce using rule 75 (expp -> expp LESSTHAN m_exp .)
    GREATHEREQUAL   reduce using rule 75 (expp -> expp LESSTHAN m_exp .)
    LESSEQUAL       reduce using rule 75 (expp -> expp LESSTHAN m_exp .)
    DIFFERENT       reduce using rule 75 (expp -> expp LESSTHAN m_exp .)
    SAME            reduce using rule 75 (expp -> expp LESSTHAN m_exp .)
    SEMICOLON       reduce using rule 75 (expp -> expp LESSTHAN m_exp .)
    AND             reduce using rule 75 (expp -> expp LESSTHAN m_exp .)
    OR              reduce using rule 75 (expp -> expp LESSTHAN m_exp .)
    PARENCLOSE      reduce using rule 75 (expp -> expp LESSTHAN m_exp .)
    COLON           reduce using rule 75 (expp -> expp LESSTHAN m_exp .)
    BRACECLOSE      reduce using rule 75 (expp -> expp LESSTHAN m_exp .)
    TO              reduce using rule 75 (expp -> expp LESSTHAN m_exp .)
    PLUS            shift and go to state 163
    MINUS           shift and go to state 164


state 203

    (76) expp -> expp GREATHEREQUAL m_exp .
    (81) m_exp -> m_exp . PLUS termino
    (82) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 76 (expp -> expp GREATHEREQUAL m_exp .)
    LESSTHAN        reduce using rule 76 (expp -> expp GREATHEREQUAL m_exp .)
    GREATHEREQUAL   reduce using rule 76 (expp -> expp GREATHEREQUAL m_exp .)
    LESSEQUAL       reduce using rule 76 (expp -> expp GREATHEREQUAL m_exp .)
    DIFFERENT       reduce using rule 76 (expp -> expp GREATHEREQUAL m_exp .)
    SAME            reduce using rule 76 (expp -> expp GREATHEREQUAL m_exp .)
    SEMICOLON       reduce using rule 76 (expp -> expp GREATHEREQUAL m_exp .)
    AND             reduce using rule 76 (expp -> expp GREATHEREQUAL m_exp .)
    OR              reduce using rule 76 (expp -> expp GREATHEREQUAL m_exp .)
    PARENCLOSE      reduce using rule 76 (expp -> expp GREATHEREQUAL m_exp .)
    COLON           reduce using rule 76 (expp -> expp GREATHEREQUAL m_exp .)
    BRACECLOSE      reduce using rule 76 (expp -> expp GREATHEREQUAL m_exp .)
    TO              reduce using rule 76 (expp -> expp GREATHEREQUAL m_exp .)
    PLUS            shift and go to state 163
    MINUS           shift and go to state 164


state 204

    (77) expp -> expp LESSEQUAL m_exp .
    (81) m_exp -> m_exp . PLUS termino
    (82) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 77 (expp -> expp LESSEQUAL m_exp .)
    LESSTHAN        reduce using rule 77 (expp -> expp LESSEQUAL m_exp .)
    GREATHEREQUAL   reduce using rule 77 (expp -> expp LESSEQUAL m_exp .)
    LESSEQUAL       reduce using rule 77 (expp -> expp LESSEQUAL m_exp .)
    DIFFERENT       reduce using rule 77 (expp -> expp LESSEQUAL m_exp .)
    SAME            reduce using rule 77 (expp -> expp LESSEQUAL m_exp .)
    SEMICOLON       reduce using rule 77 (expp -> expp LESSEQUAL m_exp .)
    AND             reduce using rule 77 (expp -> expp LESSEQUAL m_exp .)
    OR              reduce using rule 77 (expp -> expp LESSEQUAL m_exp .)
    PARENCLOSE      reduce using rule 77 (expp -> expp LESSEQUAL m_exp .)
    COLON           reduce using rule 77 (expp -> expp LESSEQUAL m_exp .)
    BRACECLOSE      reduce using rule 77 (expp -> expp LESSEQUAL m_exp .)
    TO              reduce using rule 77 (expp -> expp LESSEQUAL m_exp .)
    PLUS            shift and go to state 163
    MINUS           shift and go to state 164


state 205

    (78) expp -> expp DIFFERENT m_exp .
    (81) m_exp -> m_exp . PLUS termino
    (82) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 78 (expp -> expp DIFFERENT m_exp .)
    LESSTHAN        reduce using rule 78 (expp -> expp DIFFERENT m_exp .)
    GREATHEREQUAL   reduce using rule 78 (expp -> expp DIFFERENT m_exp .)
    LESSEQUAL       reduce using rule 78 (expp -> expp DIFFERENT m_exp .)
    DIFFERENT       reduce using rule 78 (expp -> expp DIFFERENT m_exp .)
    SAME            reduce using rule 78 (expp -> expp DIFFERENT m_exp .)
    SEMICOLON       reduce using rule 78 (expp -> expp DIFFERENT m_exp .)
    AND             reduce using rule 78 (expp -> expp DIFFERENT m_exp .)
    OR              reduce using rule 78 (expp -> expp DIFFERENT m_exp .)
    PARENCLOSE      reduce using rule 78 (expp -> expp DIFFERENT m_exp .)
    COLON           reduce using rule 78 (expp -> expp DIFFERENT m_exp .)
    BRACECLOSE      reduce using rule 78 (expp -> expp DIFFERENT m_exp .)
    TO              reduce using rule 78 (expp -> expp DIFFERENT m_exp .)
    PLUS            shift and go to state 163
    MINUS           shift and go to state 164


state 206

    (79) expp -> expp SAME m_exp .
    (81) m_exp -> m_exp . PLUS termino
    (82) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 79 (expp -> expp SAME m_exp .)
    LESSTHAN        reduce using rule 79 (expp -> expp SAME m_exp .)
    GREATHEREQUAL   reduce using rule 79 (expp -> expp SAME m_exp .)
    LESSEQUAL       reduce using rule 79 (expp -> expp SAME m_exp .)
    DIFFERENT       reduce using rule 79 (expp -> expp SAME m_exp .)
    SAME            reduce using rule 79 (expp -> expp SAME m_exp .)
    SEMICOLON       reduce using rule 79 (expp -> expp SAME m_exp .)
    AND             reduce using rule 79 (expp -> expp SAME m_exp .)
    OR              reduce using rule 79 (expp -> expp SAME m_exp .)
    PARENCLOSE      reduce using rule 79 (expp -> expp SAME m_exp .)
    COLON           reduce using rule 79 (expp -> expp SAME m_exp .)
    BRACECLOSE      reduce using rule 79 (expp -> expp SAME m_exp .)
    TO              reduce using rule 79 (expp -> expp SAME m_exp .)
    PLUS            shift and go to state 163
    MINUS           shift and go to state 164


state 207

    (81) m_exp -> m_exp PLUS termino .
    (84) termino -> termino . MULTIPLY factor
    (85) termino -> termino . DIVIDE factor

    PLUS            reduce using rule 81 (m_exp -> m_exp PLUS termino .)
    MINUS           reduce using rule 81 (m_exp -> m_exp PLUS termino .)
    GREATHERTHAN    reduce using rule 81 (m_exp -> m_exp PLUS termino .)
    LESSTHAN        reduce using rule 81 (m_exp -> m_exp PLUS termino .)
    GREATHEREQUAL   reduce using rule 81 (m_exp -> m_exp PLUS termino .)
    LESSEQUAL       reduce using rule 81 (m_exp -> m_exp PLUS termino .)
    DIFFERENT       reduce using rule 81 (m_exp -> m_exp PLUS termino .)
    SAME            reduce using rule 81 (m_exp -> m_exp PLUS termino .)
    SEMICOLON       reduce using rule 81 (m_exp -> m_exp PLUS termino .)
    AND             reduce using rule 81 (m_exp -> m_exp PLUS termino .)
    OR              reduce using rule 81 (m_exp -> m_exp PLUS termino .)
    PARENCLOSE      reduce using rule 81 (m_exp -> m_exp PLUS termino .)
    COLON           reduce using rule 81 (m_exp -> m_exp PLUS termino .)
    BRACECLOSE      reduce using rule 81 (m_exp -> m_exp PLUS termino .)
    TO              reduce using rule 81 (m_exp -> m_exp PLUS termino .)
    MULTIPLY        shift and go to state 165
    DIVIDE          shift and go to state 166


state 208

    (82) m_exp -> m_exp MINUS termino .
    (84) termino -> termino . MULTIPLY factor
    (85) termino -> termino . DIVIDE factor

    PLUS            reduce using rule 82 (m_exp -> m_exp MINUS termino .)
    MINUS           reduce using rule 82 (m_exp -> m_exp MINUS termino .)
    GREATHERTHAN    reduce using rule 82 (m_exp -> m_exp MINUS termino .)
    LESSTHAN        reduce using rule 82 (m_exp -> m_exp MINUS termino .)
    GREATHEREQUAL   reduce using rule 82 (m_exp -> m_exp MINUS termino .)
    LESSEQUAL       reduce using rule 82 (m_exp -> m_exp MINUS termino .)
    DIFFERENT       reduce using rule 82 (m_exp -> m_exp MINUS termino .)
    SAME            reduce using rule 82 (m_exp -> m_exp MINUS termino .)
    SEMICOLON       reduce using rule 82 (m_exp -> m_exp MINUS termino .)
    AND             reduce using rule 82 (m_exp -> m_exp MINUS termino .)
    OR              reduce using rule 82 (m_exp -> m_exp MINUS termino .)
    PARENCLOSE      reduce using rule 82 (m_exp -> m_exp MINUS termino .)
    COLON           reduce using rule 82 (m_exp -> m_exp MINUS termino .)
    BRACECLOSE      reduce using rule 82 (m_exp -> m_exp MINUS termino .)
    TO              reduce using rule 82 (m_exp -> m_exp MINUS termino .)
    MULTIPLY        shift and go to state 165
    DIVIDE          shift and go to state 166


state 209

    (84) termino -> termino MULTIPLY factor .

    MULTIPLY        reduce using rule 84 (termino -> termino MULTIPLY factor .)
    DIVIDE          reduce using rule 84 (termino -> termino MULTIPLY factor .)
    PLUS            reduce using rule 84 (termino -> termino MULTIPLY factor .)
    MINUS           reduce using rule 84 (termino -> termino MULTIPLY factor .)
    GREATHERTHAN    reduce using rule 84 (termino -> termino MULTIPLY factor .)
    LESSTHAN        reduce using rule 84 (termino -> termino MULTIPLY factor .)
    GREATHEREQUAL   reduce using rule 84 (termino -> termino MULTIPLY factor .)
    LESSEQUAL       reduce using rule 84 (termino -> termino MULTIPLY factor .)
    DIFFERENT       reduce using rule 84 (termino -> termino MULTIPLY factor .)
    SAME            reduce using rule 84 (termino -> termino MULTIPLY factor .)
    SEMICOLON       reduce using rule 84 (termino -> termino MULTIPLY factor .)
    AND             reduce using rule 84 (termino -> termino MULTIPLY factor .)
    OR              reduce using rule 84 (termino -> termino MULTIPLY factor .)
    PARENCLOSE      reduce using rule 84 (termino -> termino MULTIPLY factor .)
    COLON           reduce using rule 84 (termino -> termino MULTIPLY factor .)
    BRACECLOSE      reduce using rule 84 (termino -> termino MULTIPLY factor .)
    TO              reduce using rule 84 (termino -> termino MULTIPLY factor .)


state 210

    (85) termino -> termino DIVIDE factor .

    MULTIPLY        reduce using rule 85 (termino -> termino DIVIDE factor .)
    DIVIDE          reduce using rule 85 (termino -> termino DIVIDE factor .)
    PLUS            reduce using rule 85 (termino -> termino DIVIDE factor .)
    MINUS           reduce using rule 85 (termino -> termino DIVIDE factor .)
    GREATHERTHAN    reduce using rule 85 (termino -> termino DIVIDE factor .)
    LESSTHAN        reduce using rule 85 (termino -> termino DIVIDE factor .)
    GREATHEREQUAL   reduce using rule 85 (termino -> termino DIVIDE factor .)
    LESSEQUAL       reduce using rule 85 (termino -> termino DIVIDE factor .)
    DIFFERENT       reduce using rule 85 (termino -> termino DIVIDE factor .)
    SAME            reduce using rule 85 (termino -> termino DIVIDE factor .)
    SEMICOLON       reduce using rule 85 (termino -> termino DIVIDE factor .)
    AND             reduce using rule 85 (termino -> termino DIVIDE factor .)
    OR              reduce using rule 85 (termino -> termino DIVIDE factor .)
    PARENCLOSE      reduce using rule 85 (termino -> termino DIVIDE factor .)
    COLON           reduce using rule 85 (termino -> termino DIVIDE factor .)
    BRACECLOSE      reduce using rule 85 (termino -> termino DIVIDE factor .)
    TO              reduce using rule 85 (termino -> termino DIVIDE factor .)


state 211

    (87) factor -> PARENOPEN exp PARENCLOSE .

    MULTIPLY        reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)
    DIVIDE          reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)
    PLUS            reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)
    MINUS           reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)
    GREATHERTHAN    reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)
    LESSTHAN        reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)
    GREATHEREQUAL   reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)
    LESSEQUAL       reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)
    DIFFERENT       reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)
    SAME            reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)
    SEMICOLON       reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)
    AND             reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)
    OR              reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)
    PARENCLOSE      reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)
    COLON           reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)
    BRACECLOSE      reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)
    TO              reduce using rule 87 (factor -> PARENOPEN exp PARENCLOSE .)


state 212

    (114) while_loop -> WHILE whileMigaja PARENOPEN exp . PARENCLOSE whileEval body whileEnd
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 235
    AND             shift and go to state 155
    OR              shift and go to state 156


state 213

    (118) for_loop -> FOR PARENOPEN variable EQUAL . exp guardarValorFor TO exp PARENCLOSE body forEnd
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    variable                       shift and go to state 122
    exp                            shift and go to state 236
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    call_func                      shift and go to state 123

state 214

    (122) max -> MAX PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 237


state 215

    (123) min -> MIN PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 238


state 216

    (124) sum -> SUM PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 239


state 217

    (130) normal -> NORMAL PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 240


state 218

    (126) param_dist -> variable COLON . param_dist
    (125) param_dist -> . variable
    (126) param_dist -> . variable COLON param_dist
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 109

    variable                       shift and go to state 177
    param_dist                     shift and go to state 241

state 219

    (129) uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 242


state 220

    (128) poisson -> POISSON PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 243


state 221

    (127) binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 244


state 222

    (56) dec_variabless -> type guardarTipo dec_mvar SEMICOLON . dec_variabless
    (57) dec_variabless -> type guardarTipo dec_mvar SEMICOLON .
    (56) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON dec_variabless
    (57) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON
    (31) type -> . INT
    (32) type -> . FLOAT
    (33) type -> . CHAR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    IF              reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    PRINT           reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    READ            reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    ID              reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    PLOT            reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    RETURN          reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    WHILE           reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    FOR             reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    MAX             reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    MIN             reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    SUM             reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    NORMAL          reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    UNIFORME        reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    POISSON         reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    BINOMIAL        reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    BRACKETCLOSE    reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

  ! INT             [ reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .) ]
  ! CHAR            [ reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .) ]

    type                           shift and go to state 96
    dec_variabless                 shift and go to state 245

state 223

    (58) dec_mvar -> ID COLON . dec_mvar
    (58) dec_mvar -> . ID COLON dec_mvar
    (59) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (60) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (61) dec_mvar -> . ID
    (62) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (63) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 182

    dec_mvar                       shift and go to state 246

state 224

    (59) dec_mvar -> ID BRACEOPEN . CTEINT BRACECLOSE COLON dec_mvar
    (60) dec_mvar -> ID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (62) dec_mvar -> ID BRACEOPEN . CTEINT BRACECLOSE
    (63) dec_mvar -> ID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    CTEINT          shift and go to state 247


state 225

    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON . mvar
    (15) mvar -> . ID COLON mvar
    (16) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> . ID
    (19) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (20) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 34

    mvar                           shift and go to state 248

state 226

    (99) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF . body ifEnd
    (100) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF . body cuadruploElse ELSE body ifEndElse
    (34) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 249

state 227

    (101) cuadruploIF -> empty .

    BRACKETOPEN     reduce using rule 101 (cuadruploIF -> empty .)


state 228

    (105) writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .

    IF              reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    READ            reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    ID              reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    INT             reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 105 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)


state 229

    (107) writingg -> exp COLON writingg .

    PARENCLOSE      reduce using rule 107 (writingg -> exp COLON writingg .)


state 230

    (109) writingg -> auxString COLON writingg .

    PARENCLOSE      reduce using rule 109 (writingg -> auxString COLON writingg .)


state 231

    (94) variable -> ID BRACEOPEN exp BRACECLOSE .
    (95) variable -> ID BRACEOPEN exp BRACECLOSE . BRACEOPEN exp BRACECLOSE

    COLON           reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    SEMICOLON       reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    MULTIPLY        reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    DIVIDE          reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    PLUS            reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    MINUS           reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    GREATHERTHAN    reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    LESSTHAN        reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    GREATHEREQUAL   reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    LESSEQUAL       reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    DIFFERENT       reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    SAME            reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    AND             reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    OR              reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    PARENCLOSE      reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    BRACECLOSE      reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    EQUAL           reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    TO              reduce using rule 94 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    BRACEOPEN       shift and go to state 250


state 232

    (67) call_funcc -> exp COLON call_funcc .

    PARENCLOSE      reduce using rule 67 (call_funcc -> exp COLON call_funcc .)


state 233

    (98) variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN . exp BRACECLOSE
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    exp                            shift and go to state 251
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 234

    (69) graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 69 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)


state 235

    (114) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE . whileEval body whileEnd
    (116) whileEval -> . empty
    (131) empty -> .

    BRACKETOPEN     reduce using rule 131 (empty -> .)

    whileEval                      shift and go to state 252
    empty                          shift and go to state 253

state 236

    (118) for_loop -> FOR PARENOPEN variable EQUAL exp . guardarValorFor TO exp PARENCLOSE body forEnd
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp
    (119) guardarValorFor -> . empty
    (131) empty -> .

    AND             shift and go to state 155
    OR              shift and go to state 156
    TO              reduce using rule 131 (empty -> .)

    guardarValorFor                shift and go to state 254
    empty                          shift and go to state 255

state 237

    (122) max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 122 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)


state 238

    (123) min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 123 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)


state 239

    (124) sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 124 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)


state 240

    (130) normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 130 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 241

    (126) param_dist -> variable COLON param_dist .

    PARENCLOSE      reduce using rule 126 (param_dist -> variable COLON param_dist .)


state 242

    (129) uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 129 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 243

    (128) poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 128 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 244

    (127) binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 127 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 245

    (56) dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .

    IF              reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    PRINT           reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    READ            reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    ID              reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    PLOT            reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    RETURN          reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    WHILE           reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    FOR             reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    MAX             reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    MIN             reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    SUM             reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    NORMAL          reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    UNIFORME        reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    POISSON         reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    BINOMIAL        reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    INT             reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    FLOAT           reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    CHAR            reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    BRACKETCLOSE    reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)


state 246

    (58) dec_mvar -> ID COLON dec_mvar .

    SEMICOLON       reduce using rule 58 (dec_mvar -> ID COLON dec_mvar .)


state 247

    (59) dec_mvar -> ID BRACEOPEN CTEINT . BRACECLOSE COLON dec_mvar
    (60) dec_mvar -> ID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (62) dec_mvar -> ID BRACEOPEN CTEINT . BRACECLOSE
    (63) dec_mvar -> ID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    BRACECLOSE      shift and go to state 256


state 248

    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar .

    SEMICOLON       reduce using rule 17 (mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar .)


state 249

    (99) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body . ifEnd
    (100) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body . cuadruploElse ELSE body ifEndElse
    (102) ifEnd -> . empty
    (103) cuadruploElse -> . empty
    (131) empty -> .

    IF              reduce using rule 131 (empty -> .)
    PRINT           reduce using rule 131 (empty -> .)
    READ            reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    PLOT            reduce using rule 131 (empty -> .)
    RETURN          reduce using rule 131 (empty -> .)
    WHILE           reduce using rule 131 (empty -> .)
    FOR             reduce using rule 131 (empty -> .)
    MAX             reduce using rule 131 (empty -> .)
    MIN             reduce using rule 131 (empty -> .)
    SUM             reduce using rule 131 (empty -> .)
    NORMAL          reduce using rule 131 (empty -> .)
    UNIFORME        reduce using rule 131 (empty -> .)
    POISSON         reduce using rule 131 (empty -> .)
    BINOMIAL        reduce using rule 131 (empty -> .)
    INT             reduce using rule 131 (empty -> .)
    FLOAT           reduce using rule 131 (empty -> .)
    CHAR            reduce using rule 131 (empty -> .)
    BRACKETCLOSE    reduce using rule 131 (empty -> .)
    ELSE            reduce using rule 131 (empty -> .)

    ifEnd                          shift and go to state 257
    cuadruploElse                  shift and go to state 258
    empty                          shift and go to state 259

state 250

    (95) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN . exp BRACECLOSE
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    exp                            shift and go to state 260
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 251

    (98) variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp . BRACECLOSE
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp

    BRACECLOSE      shift and go to state 261
    AND             shift and go to state 155
    OR              shift and go to state 156


state 252

    (114) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval . body whileEnd
    (34) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 262

state 253

    (116) whileEval -> empty .

    BRACKETOPEN     reduce using rule 116 (whileEval -> empty .)


state 254

    (118) for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor . TO exp PARENCLOSE body forEnd

    TO              shift and go to state 263


state 255

    (119) guardarValorFor -> empty .

    TO              reduce using rule 119 (guardarValorFor -> empty .)


state 256

    (59) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE . COLON dec_mvar
    (60) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (62) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE .
    (63) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 265
    BRACEOPEN       shift and go to state 264
    SEMICOLON       reduce using rule 62 (dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE .)


state 257

    (99) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .

    IF              reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    PRINT           reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    READ            reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    ID              reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    PLOT            reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    RETURN          reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    WHILE           reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    FOR             reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    MAX             reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    MIN             reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    SUM             reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    NORMAL          reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    UNIFORME        reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    POISSON         reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    BINOMIAL        reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    INT             reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    FLOAT           reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    CHAR            reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    BRACKETCLOSE    reduce using rule 99 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)


state 258

    (100) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse . ELSE body ifEndElse

    ELSE            shift and go to state 266


state 259

    (102) ifEnd -> empty .
    (103) cuadruploElse -> empty .

    IF              reduce using rule 102 (ifEnd -> empty .)
    PRINT           reduce using rule 102 (ifEnd -> empty .)
    READ            reduce using rule 102 (ifEnd -> empty .)
    ID              reduce using rule 102 (ifEnd -> empty .)
    PLOT            reduce using rule 102 (ifEnd -> empty .)
    RETURN          reduce using rule 102 (ifEnd -> empty .)
    WHILE           reduce using rule 102 (ifEnd -> empty .)
    FOR             reduce using rule 102 (ifEnd -> empty .)
    MAX             reduce using rule 102 (ifEnd -> empty .)
    MIN             reduce using rule 102 (ifEnd -> empty .)
    SUM             reduce using rule 102 (ifEnd -> empty .)
    NORMAL          reduce using rule 102 (ifEnd -> empty .)
    UNIFORME        reduce using rule 102 (ifEnd -> empty .)
    POISSON         reduce using rule 102 (ifEnd -> empty .)
    BINOMIAL        reduce using rule 102 (ifEnd -> empty .)
    INT             reduce using rule 102 (ifEnd -> empty .)
    FLOAT           reduce using rule 102 (ifEnd -> empty .)
    CHAR            reduce using rule 102 (ifEnd -> empty .)
    BRACKETCLOSE    reduce using rule 102 (ifEnd -> empty .)
    ELSE            reduce using rule 103 (cuadruploElse -> empty .)


state 260

    (95) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp . BRACECLOSE
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp

    BRACECLOSE      shift and go to state 267
    AND             shift and go to state 155
    OR              shift and go to state 156


state 261

    (98) variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .

    EQUAL           reduce using rule 98 (variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)


state 262

    (114) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body . whileEnd
    (117) whileEnd -> . empty
    (131) empty -> .

    IF              reduce using rule 131 (empty -> .)
    PRINT           reduce using rule 131 (empty -> .)
    READ            reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    PLOT            reduce using rule 131 (empty -> .)
    RETURN          reduce using rule 131 (empty -> .)
    WHILE           reduce using rule 131 (empty -> .)
    FOR             reduce using rule 131 (empty -> .)
    MAX             reduce using rule 131 (empty -> .)
    MIN             reduce using rule 131 (empty -> .)
    SUM             reduce using rule 131 (empty -> .)
    NORMAL          reduce using rule 131 (empty -> .)
    UNIFORME        reduce using rule 131 (empty -> .)
    POISSON         reduce using rule 131 (empty -> .)
    BINOMIAL        reduce using rule 131 (empty -> .)
    INT             reduce using rule 131 (empty -> .)
    FLOAT           reduce using rule 131 (empty -> .)
    CHAR            reduce using rule 131 (empty -> .)
    BRACKETCLOSE    reduce using rule 131 (empty -> .)

    whileEnd                       shift and go to state 268
    empty                          shift and go to state 269

state 263

    (118) for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO . exp PARENCLOSE body forEnd
    (70) exp -> . expp
    (71) exp -> . exp AND expp
    (72) exp -> . exp OR expp
    (73) expp -> . m_exp
    (74) expp -> . expp GREATHERTHAN m_exp
    (75) expp -> . expp LESSTHAN m_exp
    (76) expp -> . expp GREATHEREQUAL m_exp
    (77) expp -> . expp LESSEQUAL m_exp
    (78) expp -> . expp DIFFERENT m_exp
    (79) expp -> . expp SAME m_exp
    (80) m_exp -> . termino
    (81) m_exp -> . m_exp PLUS termino
    (82) m_exp -> . m_exp MINUS termino
    (83) termino -> . factor
    (84) termino -> . termino MULTIPLY factor
    (85) termino -> . termino DIVIDE factor
    (86) factor -> . ID
    (87) factor -> . PARENOPEN exp PARENCLOSE
    (88) factor -> . CTEINT guardarConstante
    (89) factor -> . CTFLOAT guardarConstante
    (90) factor -> . variable
    (91) factor -> . call_func
    (93) variable -> . ID
    (94) variable -> . ID BRACEOPEN exp BRACECLOSE
    (95) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 118
    PARENOPEN       shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121

    variable                       shift and go to state 122
    exp                            shift and go to state 270
    expp                           shift and go to state 114
    m_exp                          shift and go to state 115
    termino                        shift and go to state 116
    factor                         shift and go to state 117
    call_func                      shift and go to state 123

state 264

    (60) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE COLON dec_mvar
    (63) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE

    CTEINT          shift and go to state 271


state 265

    (59) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON . dec_mvar
    (58) dec_mvar -> . ID COLON dec_mvar
    (59) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (60) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (61) dec_mvar -> . ID
    (62) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (63) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 182

    dec_mvar                       shift and go to state 272

state 266

    (100) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE . body ifEndElse
    (34) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 273

state 267

    (95) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .

    COLON           reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    SEMICOLON       reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    MULTIPLY        reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    DIVIDE          reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    PLUS            reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    MINUS           reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    GREATHERTHAN    reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    LESSTHAN        reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    GREATHEREQUAL   reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    LESSEQUAL       reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    DIFFERENT       reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    SAME            reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    AND             reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    OR              reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    PARENCLOSE      reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    BRACECLOSE      reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    EQUAL           reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    TO              reduce using rule 95 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)


state 268

    (114) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .

    IF              reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    PRINT           reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    READ            reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    ID              reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    PLOT            reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    RETURN          reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    WHILE           reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    FOR             reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    MAX             reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    MIN             reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    SUM             reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    NORMAL          reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    UNIFORME        reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    POISSON         reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    BINOMIAL        reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    INT             reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    FLOAT           reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    CHAR            reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    BRACKETCLOSE    reduce using rule 114 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)


state 269

    (117) whileEnd -> empty .

    IF              reduce using rule 117 (whileEnd -> empty .)
    PRINT           reduce using rule 117 (whileEnd -> empty .)
    READ            reduce using rule 117 (whileEnd -> empty .)
    ID              reduce using rule 117 (whileEnd -> empty .)
    PLOT            reduce using rule 117 (whileEnd -> empty .)
    RETURN          reduce using rule 117 (whileEnd -> empty .)
    WHILE           reduce using rule 117 (whileEnd -> empty .)
    FOR             reduce using rule 117 (whileEnd -> empty .)
    MAX             reduce using rule 117 (whileEnd -> empty .)
    MIN             reduce using rule 117 (whileEnd -> empty .)
    SUM             reduce using rule 117 (whileEnd -> empty .)
    NORMAL          reduce using rule 117 (whileEnd -> empty .)
    UNIFORME        reduce using rule 117 (whileEnd -> empty .)
    POISSON         reduce using rule 117 (whileEnd -> empty .)
    BINOMIAL        reduce using rule 117 (whileEnd -> empty .)
    INT             reduce using rule 117 (whileEnd -> empty .)
    FLOAT           reduce using rule 117 (whileEnd -> empty .)
    CHAR            reduce using rule 117 (whileEnd -> empty .)
    BRACKETCLOSE    reduce using rule 117 (whileEnd -> empty .)


state 270

    (118) for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp . PARENCLOSE body forEnd
    (71) exp -> exp . AND expp
    (72) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 274
    AND             shift and go to state 155
    OR              shift and go to state 156


state 271

    (60) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE COLON dec_mvar
    (63) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE

    BRACECLOSE      shift and go to state 275


state 272

    (59) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .

    SEMICOLON       reduce using rule 59 (dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .)


state 273

    (100) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body . ifEndElse
    (104) ifEndElse -> . empty
    (131) empty -> .

    IF              reduce using rule 131 (empty -> .)
    PRINT           reduce using rule 131 (empty -> .)
    READ            reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    PLOT            reduce using rule 131 (empty -> .)
    RETURN          reduce using rule 131 (empty -> .)
    WHILE           reduce using rule 131 (empty -> .)
    FOR             reduce using rule 131 (empty -> .)
    MAX             reduce using rule 131 (empty -> .)
    MIN             reduce using rule 131 (empty -> .)
    SUM             reduce using rule 131 (empty -> .)
    NORMAL          reduce using rule 131 (empty -> .)
    UNIFORME        reduce using rule 131 (empty -> .)
    POISSON         reduce using rule 131 (empty -> .)
    BINOMIAL        reduce using rule 131 (empty -> .)
    INT             reduce using rule 131 (empty -> .)
    FLOAT           reduce using rule 131 (empty -> .)
    CHAR            reduce using rule 131 (empty -> .)
    BRACKETCLOSE    reduce using rule 131 (empty -> .)

    ifEndElse                      shift and go to state 276
    empty                          shift and go to state 277

state 274

    (118) for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE . body forEnd
    (34) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 278

state 275

    (60) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE . COLON dec_mvar
    (63) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .

    COLON           shift and go to state 279
    SEMICOLON       reduce using rule 63 (dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .)


state 276

    (100) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .

    IF              reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    PRINT           reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    READ            reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    ID              reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    PLOT            reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    RETURN          reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    WHILE           reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    FOR             reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    MAX             reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    MIN             reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    SUM             reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    NORMAL          reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    UNIFORME        reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    POISSON         reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    BINOMIAL        reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    INT             reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    FLOAT           reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    CHAR            reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    BRACKETCLOSE    reduce using rule 100 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)


state 277

    (104) ifEndElse -> empty .

    IF              reduce using rule 104 (ifEndElse -> empty .)
    PRINT           reduce using rule 104 (ifEndElse -> empty .)
    READ            reduce using rule 104 (ifEndElse -> empty .)
    ID              reduce using rule 104 (ifEndElse -> empty .)
    PLOT            reduce using rule 104 (ifEndElse -> empty .)
    RETURN          reduce using rule 104 (ifEndElse -> empty .)
    WHILE           reduce using rule 104 (ifEndElse -> empty .)
    FOR             reduce using rule 104 (ifEndElse -> empty .)
    MAX             reduce using rule 104 (ifEndElse -> empty .)
    MIN             reduce using rule 104 (ifEndElse -> empty .)
    SUM             reduce using rule 104 (ifEndElse -> empty .)
    NORMAL          reduce using rule 104 (ifEndElse -> empty .)
    UNIFORME        reduce using rule 104 (ifEndElse -> empty .)
    POISSON         reduce using rule 104 (ifEndElse -> empty .)
    BINOMIAL        reduce using rule 104 (ifEndElse -> empty .)
    INT             reduce using rule 104 (ifEndElse -> empty .)
    FLOAT           reduce using rule 104 (ifEndElse -> empty .)
    CHAR            reduce using rule 104 (ifEndElse -> empty .)
    BRACKETCLOSE    reduce using rule 104 (ifEndElse -> empty .)


state 278

    (118) for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body . forEnd
    (120) forEnd -> . empty
    (131) empty -> .

    IF              reduce using rule 131 (empty -> .)
    PRINT           reduce using rule 131 (empty -> .)
    READ            reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    PLOT            reduce using rule 131 (empty -> .)
    RETURN          reduce using rule 131 (empty -> .)
    WHILE           reduce using rule 131 (empty -> .)
    FOR             reduce using rule 131 (empty -> .)
    MAX             reduce using rule 131 (empty -> .)
    MIN             reduce using rule 131 (empty -> .)
    SUM             reduce using rule 131 (empty -> .)
    NORMAL          reduce using rule 131 (empty -> .)
    UNIFORME        reduce using rule 131 (empty -> .)
    POISSON         reduce using rule 131 (empty -> .)
    BINOMIAL        reduce using rule 131 (empty -> .)
    INT             reduce using rule 131 (empty -> .)
    FLOAT           reduce using rule 131 (empty -> .)
    CHAR            reduce using rule 131 (empty -> .)
    BRACKETCLOSE    reduce using rule 131 (empty -> .)

    forEnd                         shift and go to state 280
    empty                          shift and go to state 281

state 279

    (60) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON . dec_mvar
    (58) dec_mvar -> . ID COLON dec_mvar
    (59) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (60) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (61) dec_mvar -> . ID
    (62) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (63) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 182

    dec_mvar                       shift and go to state 282

state 280

    (118) for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .

    IF              reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    PRINT           reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    READ            reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    ID              reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    PLOT            reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    RETURN          reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    WHILE           reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    FOR             reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    MAX             reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    MIN             reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    SUM             reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    NORMAL          reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    UNIFORME        reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    POISSON         reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    BINOMIAL        reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    INT             reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    FLOAT           reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    CHAR            reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    BRACKETCLOSE    reduce using rule 118 (for_loop -> FOR PARENOPEN variable EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)


state 281

    (120) forEnd -> empty .

    IF              reduce using rule 120 (forEnd -> empty .)
    PRINT           reduce using rule 120 (forEnd -> empty .)
    READ            reduce using rule 120 (forEnd -> empty .)
    ID              reduce using rule 120 (forEnd -> empty .)
    PLOT            reduce using rule 120 (forEnd -> empty .)
    RETURN          reduce using rule 120 (forEnd -> empty .)
    WHILE           reduce using rule 120 (forEnd -> empty .)
    FOR             reduce using rule 120 (forEnd -> empty .)
    MAX             reduce using rule 120 (forEnd -> empty .)
    MIN             reduce using rule 120 (forEnd -> empty .)
    SUM             reduce using rule 120 (forEnd -> empty .)
    NORMAL          reduce using rule 120 (forEnd -> empty .)
    UNIFORME        reduce using rule 120 (forEnd -> empty .)
    POISSON         reduce using rule 120 (forEnd -> empty .)
    BINOMIAL        reduce using rule 120 (forEnd -> empty .)
    INT             reduce using rule 120 (forEnd -> empty .)
    FLOAT           reduce using rule 120 (forEnd -> empty .)
    CHAR            reduce using rule 120 (forEnd -> empty .)
    BRACKETCLOSE    reduce using rule 120 (forEnd -> empty .)


state 282

    (60) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .

    SEMICOLON       reduce using rule 60 (dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 222 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 222 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 222 resolved as shift
WARNING: reduce/reduce conflict in state 60 resolved using rule (bodyy -> statement)
WARNING: rejected rule (empty -> <empty>) in state 60
WARNING: reduce/reduce conflict in state 118 resolved using rule (factor -> ID)
WARNING: rejected rule (variable -> ID) in state 118
