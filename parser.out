Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start_program
Rule 1     start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body
Rule 2     start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body
Rule 3     start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body
Rule 4     start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body
Rule 5     cuadruploMain -> empty
Rule 6     multiple_funcs -> dec_func
Rule 7     multiple_funcs -> dec_func multiple_funcs
Rule 8     main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body
Rule 9     crearTablaMain -> empty
Rule 10    gotoMain -> empty
Rule 11    vars -> VAR varss
Rule 12    varss -> type guardarTipo mvar SEMICOLON varss
Rule 13    varss -> type guardarTipo mvar SEMICOLON
Rule 14    guardarTipo -> empty
Rule 15    mvar -> ID COLON mvar
Rule 16    mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
Rule 17    mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
Rule 18    mvar -> ID
Rule 19    mvar -> ID BRACEOPEN CTEINT BRACECLOSE
Rule 20    mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE
Rule 21    dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
Rule 22    dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
Rule 23    crearSymbolTable -> empty
Rule 24    exitFunc -> empty
Rule 25    param -> typeParam ID
Rule 26    param -> typeParam ID COLON param
Rule 27    param -> empty
Rule 28    typeParam -> INT
Rule 29    typeParam -> FLOAT
Rule 30    typeParam -> CHAR
Rule 31    type -> INT
Rule 32    type -> FLOAT
Rule 33    type -> CHAR
Rule 34    body -> BRACKETOPEN bodyy BRACKETCLOSE
Rule 35    bodyy -> statement
Rule 36    bodyy -> statement bodyy
Rule 37    bodyy -> empty
Rule 38    statement -> dec_variables
Rule 39    statement -> assignment
Rule 40    statement -> condition
Rule 41    statement -> writing
Rule 42    statement -> reading
Rule 43    statement -> call_func
Rule 44    statement -> graph
Rule 45    statement -> return
Rule 46    statement -> while_loop
Rule 47    statement -> for_loop
Rule 48    statement -> max
Rule 49    statement -> min
Rule 50    statement -> sum
Rule 51    statement -> normal
Rule 52    statement -> uniforme
Rule 53    statement -> poisson
Rule 54    statement -> binomial
Rule 55    dec_variables -> dec_variabless
Rule 56    dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless
Rule 57    dec_variabless -> type guardarTipo dec_mvar SEMICOLON
Rule 58    dec_mvar -> ID COLON dec_mvar
Rule 59    dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
Rule 60    dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
Rule 61    dec_mvar -> ID
Rule 62    dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE
Rule 63    dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE
Rule 64    assignment -> variableAssignment EQUAL exp SEMICOLON
Rule 65    call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE
Rule 66    generarERA -> empty
Rule 67    call_funcc -> exp mandarParam
Rule 68    call_funcc -> exp mandarParam COLON call_funcc
Rule 69    call_funcc -> empty
Rule 70    mandarParam -> empty
Rule 71    graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON
Rule 72    exp -> expp
Rule 73    exp -> exp AND expp
Rule 74    exp -> exp OR expp
Rule 75    expp -> m_exp
Rule 76    expp -> expp GREATHERTHAN m_exp
Rule 77    expp -> expp LESSTHAN m_exp
Rule 78    expp -> expp GREATHEREQUAL m_exp
Rule 79    expp -> expp LESSEQUAL m_exp
Rule 80    expp -> expp DIFFERENT m_exp
Rule 81    expp -> expp SAME m_exp
Rule 82    m_exp -> termino
Rule 83    m_exp -> m_exp PLUS termino
Rule 84    m_exp -> m_exp MINUS termino
Rule 85    termino -> factor
Rule 86    termino -> termino MULTIPLY factor
Rule 87    termino -> termino DIVIDE factor
Rule 88    factor -> ID
Rule 89    factor -> CTEINT guardarConstanteInt
Rule 90    factor -> CTFLOAT guardarConstanteFloat
Rule 91    factor -> variable
Rule 92    factor -> call_func
Rule 93    factor -> PARENOPEN exp PARENCLOSE
Rule 94    guardarConstanteInt -> empty
Rule 95    guardarConstanteFloat -> empty
Rule 96    variable -> ID
Rule 97    variable -> ID BRACEOPEN exp BRACECLOSE
Rule 98    variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
Rule 99    variableAssignment -> ID
Rule 100   variableAssignment -> ID BRACEOPEN exp BRACECLOSE
Rule 101   variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
Rule 102   condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
Rule 103   condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
Rule 104   cuadruploIF -> empty
Rule 105   ifEnd -> empty
Rule 106   cuadruploElse -> empty
Rule 107   ifEndElse -> empty
Rule 108   writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
Rule 109   writingg -> exp
Rule 110   writingg -> exp COLON writingg
Rule 111   writingg -> auxString
Rule 112   writingg -> auxString COLON writingg
Rule 113   auxString -> CTESTRING
Rule 114   reading -> READ multivariables SEMICOLON
Rule 115   multivariables -> variable
Rule 116   multivariables -> variable COLON multivariables
Rule 117   while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
Rule 118   whileMigaja -> empty
Rule 119   whileEval -> empty
Rule 120   whileEnd -> empty
Rule 121   for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd
Rule 122   guardarValorFor -> empty
Rule 123   forEnd -> empty
Rule 124   return -> RETURN exp SEMICOLON
Rule 125   max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON
Rule 126   min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON
Rule 127   sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON
Rule 128   param_dist -> variable
Rule 129   param_dist -> variable COLON param_dist
Rule 130   binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 131   poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 132   uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 133   normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 134   empty -> <empty>

Terminals, with rules where they appear

AND                  : 73
BINOMIAL             : 130
BRACECLOSE           : 16 17 17 19 20 20 59 60 60 62 63 63 97 98 98 100 101 101
BRACEOPEN            : 16 17 17 19 20 20 59 60 60 62 63 63 97 98 98 100 101 101
BRACKETCLOSE         : 34
BRACKETOPEN          : 34
CHAR                 : 30 33
COLON                : 15 16 17 26 58 59 60 68 110 112 116 129
CTEINT               : 16 17 17 19 20 20 59 60 60 62 63 63 89
CTESTRING            : 113
CTFLOAT              : 90
DIFFERENT            : 80
DIVIDE               : 87
ELSE                 : 103
EQUAL                : 64 121
FLOAT                : 29 32
FOR                  : 121
FUNCTION             : 21 22
GREATHEREQUAL        : 78
GREATHERTHAN         : 76
ID                   : 1 2 3 4 15 16 17 18 19 20 21 22 25 26 58 59 60 61 62 63 65 88 96 97 98 99 100 101 121
IF                   : 102 103
INT                  : 28 31
LESSEQUAL            : 79
LESSTHAN             : 77
MAIN                 : 8
MAX                  : 125
MIN                  : 126
MINUS                : 84
MULTIPLY             : 86
NORMAL               : 133
OR                   : 74
PARENCLOSE           : 8 21 22 65 71 93 102 103 108 117 121 125 126 127 130 131 132 133
PARENOPEN            : 8 21 22 65 71 93 102 103 108 117 121 125 126 127 130 131 132 133
PLOT                 : 71
PLUS                 : 83
POISSON              : 131
PRINT                : 108
PROGRAM              : 1 2 3 4
READ                 : 114
RETURN               : 124
SAME                 : 81
SEMICOLON            : 1 2 3 4 12 13 56 57 64 71 108 114 124 125 126 127 130 131 132 133
SUM                  : 127
TO                   : 121
UNIFORME             : 132
VAR                  : 11
VOID                 : 22
WHILE                : 117
error                : 

Nonterminals, with rules where they appear

assignment           : 39
auxString            : 111 112
binomial             : 54
body                 : 8 21 22 102 103 103 117 121
bodyy                : 34 36
call_func            : 43 92
call_funcc           : 65 68
condition            : 40
crearSymbolTable     : 21 22
crearTablaMain       : 8
cuadruploElse        : 103
cuadruploIF          : 102 103
cuadruploMain        : 1 2 3 4
dec_func             : 6 7
dec_mvar             : 56 57 58 59 60
dec_variables        : 38
dec_variabless       : 55 56
empty                : 5 9 10 14 23 24 27 37 66 69 70 94 95 104 105 106 107 118 119 120 122 123
exitFunc             : 21 22
exp                  : 64 67 68 71 73 74 93 97 98 98 100 101 101 102 103 109 110 117 121 121 124 125 126 127
expp                 : 72 73 74 76 77 78 79 80 81
factor               : 85 86 87
forEnd               : 121
for_loop             : 47
generarERA           : 65
gotoMain             : 8
graph                : 44
guardarConstanteFloat : 90
guardarConstanteInt  : 89
guardarTipo          : 12 13 56 57
guardarValorFor      : 121
ifEnd                : 102
ifEndElse            : 103
m_exp                : 75 76 77 78 79 80 81 83 84
main_body            : 1 2 3 4
mandarParam          : 67 68
max                  : 48
min                  : 49
multiple_funcs       : 1 3 7
multivariables       : 114 116
mvar                 : 12 13 15 16 17
normal               : 51
param                : 21 22 26
param_dist           : 129 130 131 132 133
poisson              : 53
reading              : 42
return               : 45
start_program        : 0
statement            : 35 36
sum                  : 50
termino              : 82 83 84 86 87
type                 : 12 13 21 56 57
typeParam            : 25 26
uniforme             : 52
variable             : 91 115 116 128 129
variableAssignment   : 64
vars                 : 1 2
varss                : 11 12
whileEnd             : 117
whileEval            : 117
whileMigaja          : 117
while_loop           : 46
writing              : 41
writingg             : 108 110 112

Parsing method: LALR

state 0

    (0) S' -> . start_program
    (1) start_program -> . cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body
    (2) start_program -> . cuadruploMain PROGRAM ID SEMICOLON vars main_body
    (3) start_program -> . cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body
    (4) start_program -> . cuadruploMain PROGRAM ID SEMICOLON main_body
    (5) cuadruploMain -> . empty
    (134) empty -> .

    PROGRAM         reduce using rule 134 (empty -> .)

    start_program                  shift and go to state 1
    cuadruploMain                  shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> start_program .



state 2

    (1) start_program -> cuadruploMain . PROGRAM ID SEMICOLON vars multiple_funcs main_body
    (2) start_program -> cuadruploMain . PROGRAM ID SEMICOLON vars main_body
    (3) start_program -> cuadruploMain . PROGRAM ID SEMICOLON multiple_funcs main_body
    (4) start_program -> cuadruploMain . PROGRAM ID SEMICOLON main_body

    PROGRAM         shift and go to state 4


state 3

    (5) cuadruploMain -> empty .

    PROGRAM         reduce using rule 5 (cuadruploMain -> empty .)


state 4

    (1) start_program -> cuadruploMain PROGRAM . ID SEMICOLON vars multiple_funcs main_body
    (2) start_program -> cuadruploMain PROGRAM . ID SEMICOLON vars main_body
    (3) start_program -> cuadruploMain PROGRAM . ID SEMICOLON multiple_funcs main_body
    (4) start_program -> cuadruploMain PROGRAM . ID SEMICOLON main_body

    ID              shift and go to state 5


state 5

    (1) start_program -> cuadruploMain PROGRAM ID . SEMICOLON vars multiple_funcs main_body
    (2) start_program -> cuadruploMain PROGRAM ID . SEMICOLON vars main_body
    (3) start_program -> cuadruploMain PROGRAM ID . SEMICOLON multiple_funcs main_body
    (4) start_program -> cuadruploMain PROGRAM ID . SEMICOLON main_body

    SEMICOLON       shift and go to state 6


state 6

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON . vars multiple_funcs main_body
    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON . vars main_body
    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON . multiple_funcs main_body
    (4) start_program -> cuadruploMain PROGRAM ID SEMICOLON . main_body
    (11) vars -> . VAR varss
    (6) multiple_funcs -> . dec_func
    (7) multiple_funcs -> . dec_func multiple_funcs
    (8) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body
    (21) dec_func -> . FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (22) dec_func -> . FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc

    VAR             shift and go to state 10
    MAIN            shift and go to state 12
    FUNCTION        shift and go to state 13

    vars                           shift and go to state 7
    multiple_funcs                 shift and go to state 8
    main_body                      shift and go to state 9
    dec_func                       shift and go to state 11

state 7

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars . multiple_funcs main_body
    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars . main_body
    (6) multiple_funcs -> . dec_func
    (7) multiple_funcs -> . dec_func multiple_funcs
    (8) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body
    (21) dec_func -> . FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (22) dec_func -> . FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc

    MAIN            shift and go to state 12
    FUNCTION        shift and go to state 13

    multiple_funcs                 shift and go to state 14
    main_body                      shift and go to state 15
    dec_func                       shift and go to state 11

state 8

    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs . main_body
    (8) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body

    MAIN            shift and go to state 12

    main_body                      shift and go to state 16

state 9

    (4) start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body .

    $end            reduce using rule 4 (start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body .)


state 10

    (11) vars -> VAR . varss
    (12) varss -> . type guardarTipo mvar SEMICOLON varss
    (13) varss -> . type guardarTipo mvar SEMICOLON
    (31) type -> . INT
    (32) type -> . FLOAT
    (33) type -> . CHAR

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    varss                          shift and go to state 17
    type                           shift and go to state 18

state 11

    (6) multiple_funcs -> dec_func .
    (7) multiple_funcs -> dec_func . multiple_funcs
    (6) multiple_funcs -> . dec_func
    (7) multiple_funcs -> . dec_func multiple_funcs
    (21) dec_func -> . FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (22) dec_func -> . FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc

    MAIN            reduce using rule 6 (multiple_funcs -> dec_func .)
    FUNCTION        shift and go to state 13

    dec_func                       shift and go to state 11
    multiple_funcs                 shift and go to state 22

state 12

    (8) main_body -> MAIN . crearTablaMain PARENOPEN PARENCLOSE gotoMain body
    (9) crearTablaMain -> . empty
    (134) empty -> .

    PARENOPEN       reduce using rule 134 (empty -> .)

    crearTablaMain                 shift and go to state 23
    empty                          shift and go to state 24

state 13

    (21) dec_func -> FUNCTION . type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (22) dec_func -> FUNCTION . VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (31) type -> . INT
    (32) type -> . FLOAT
    (33) type -> . CHAR

    VOID            shift and go to state 26
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    type                           shift and go to state 25

state 14

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs . main_body
    (8) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body

    MAIN            shift and go to state 12

    main_body                      shift and go to state 27

state 15

    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body .

    $end            reduce using rule 2 (start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body .)


state 16

    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body .

    $end            reduce using rule 3 (start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body .)


state 17

    (11) vars -> VAR varss .

    MAIN            reduce using rule 11 (vars -> VAR varss .)
    FUNCTION        reduce using rule 11 (vars -> VAR varss .)


state 18

    (12) varss -> type . guardarTipo mvar SEMICOLON varss
    (13) varss -> type . guardarTipo mvar SEMICOLON
    (14) guardarTipo -> . empty
    (134) empty -> .

    ID              reduce using rule 134 (empty -> .)

    guardarTipo                    shift and go to state 28
    empty                          shift and go to state 29

state 19

    (31) type -> INT .

    ID              reduce using rule 31 (type -> INT .)


state 20

    (32) type -> FLOAT .

    ID              reduce using rule 32 (type -> FLOAT .)


state 21

    (33) type -> CHAR .

    ID              reduce using rule 33 (type -> CHAR .)


state 22

    (7) multiple_funcs -> dec_func multiple_funcs .

    MAIN            reduce using rule 7 (multiple_funcs -> dec_func multiple_funcs .)


state 23

    (8) main_body -> MAIN crearTablaMain . PARENOPEN PARENCLOSE gotoMain body

    PARENOPEN       shift and go to state 30


state 24

    (9) crearTablaMain -> empty .

    PARENOPEN       reduce using rule 9 (crearTablaMain -> empty .)


state 25

    (21) dec_func -> FUNCTION type . ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc

    ID              shift and go to state 31


state 26

    (22) dec_func -> FUNCTION VOID . ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc

    ID              shift and go to state 32


state 27

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body .

    $end            reduce using rule 1 (start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body .)


state 28

    (12) varss -> type guardarTipo . mvar SEMICOLON varss
    (13) varss -> type guardarTipo . mvar SEMICOLON
    (15) mvar -> . ID COLON mvar
    (16) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> . ID
    (19) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (20) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 34

    mvar                           shift and go to state 33

state 29

    (14) guardarTipo -> empty .

    ID              reduce using rule 14 (guardarTipo -> empty .)


state 30

    (8) main_body -> MAIN crearTablaMain PARENOPEN . PARENCLOSE gotoMain body

    PARENCLOSE      shift and go to state 35


state 31

    (21) dec_func -> FUNCTION type ID . crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (23) crearSymbolTable -> . empty
    (134) empty -> .

    PARENOPEN       reduce using rule 134 (empty -> .)

    crearSymbolTable               shift and go to state 36
    empty                          shift and go to state 37

state 32

    (22) dec_func -> FUNCTION VOID ID . crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc
    (23) crearSymbolTable -> . empty
    (134) empty -> .

    PARENOPEN       reduce using rule 134 (empty -> .)

    crearSymbolTable               shift and go to state 38
    empty                          shift and go to state 37

state 33

    (12) varss -> type guardarTipo mvar . SEMICOLON varss
    (13) varss -> type guardarTipo mvar . SEMICOLON

    SEMICOLON       shift and go to state 39


state 34

    (15) mvar -> ID . COLON mvar
    (16) mvar -> ID . BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> ID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> ID .
    (19) mvar -> ID . BRACEOPEN CTEINT BRACECLOSE
    (20) mvar -> ID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 40
    BRACEOPEN       shift and go to state 41
    SEMICOLON       reduce using rule 18 (mvar -> ID .)


state 35

    (8) main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE . gotoMain body
    (10) gotoMain -> . empty
    (134) empty -> .

    BRACKETOPEN     reduce using rule 134 (empty -> .)

    gotoMain                       shift and go to state 42
    empty                          shift and go to state 43

state 36

    (21) dec_func -> FUNCTION type ID crearSymbolTable . PARENOPEN param PARENCLOSE body exitFunc

    PARENOPEN       shift and go to state 44


state 37

    (23) crearSymbolTable -> empty .

    PARENOPEN       reduce using rule 23 (crearSymbolTable -> empty .)


state 38

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable . PARENOPEN param PARENCLOSE body exitFunc

    PARENOPEN       shift and go to state 45


state 39

    (12) varss -> type guardarTipo mvar SEMICOLON . varss
    (13) varss -> type guardarTipo mvar SEMICOLON .
    (12) varss -> . type guardarTipo mvar SEMICOLON varss
    (13) varss -> . type guardarTipo mvar SEMICOLON
    (31) type -> . INT
    (32) type -> . FLOAT
    (33) type -> . CHAR

    MAIN            reduce using rule 13 (varss -> type guardarTipo mvar SEMICOLON .)
    FUNCTION        reduce using rule 13 (varss -> type guardarTipo mvar SEMICOLON .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    type                           shift and go to state 18
    varss                          shift and go to state 46

state 40

    (15) mvar -> ID COLON . mvar
    (15) mvar -> . ID COLON mvar
    (16) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> . ID
    (19) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (20) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 34

    mvar                           shift and go to state 47

state 41

    (16) mvar -> ID BRACEOPEN . CTEINT BRACECLOSE COLON mvar
    (17) mvar -> ID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (19) mvar -> ID BRACEOPEN . CTEINT BRACECLOSE
    (20) mvar -> ID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    CTEINT          shift and go to state 48


state 42

    (8) main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain . body
    (34) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 49

state 43

    (10) gotoMain -> empty .

    BRACKETOPEN     reduce using rule 10 (gotoMain -> empty .)


state 44

    (21) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN . param PARENCLOSE body exitFunc
    (25) param -> . typeParam ID
    (26) param -> . typeParam ID COLON param
    (27) param -> . empty
    (28) typeParam -> . INT
    (29) typeParam -> . FLOAT
    (30) typeParam -> . CHAR
    (134) empty -> .

    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    CHAR            shift and go to state 56
    PARENCLOSE      reduce using rule 134 (empty -> .)

    param                          shift and go to state 51
    typeParam                      shift and go to state 52
    empty                          shift and go to state 53

state 45

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN . param PARENCLOSE body exitFunc
    (25) param -> . typeParam ID
    (26) param -> . typeParam ID COLON param
    (27) param -> . empty
    (28) typeParam -> . INT
    (29) typeParam -> . FLOAT
    (30) typeParam -> . CHAR
    (134) empty -> .

    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    CHAR            shift and go to state 56
    PARENCLOSE      reduce using rule 134 (empty -> .)

    param                          shift and go to state 57
    typeParam                      shift and go to state 52
    empty                          shift and go to state 53

state 46

    (12) varss -> type guardarTipo mvar SEMICOLON varss .

    MAIN            reduce using rule 12 (varss -> type guardarTipo mvar SEMICOLON varss .)
    FUNCTION        reduce using rule 12 (varss -> type guardarTipo mvar SEMICOLON varss .)


state 47

    (15) mvar -> ID COLON mvar .

    SEMICOLON       reduce using rule 15 (mvar -> ID COLON mvar .)


state 48

    (16) mvar -> ID BRACEOPEN CTEINT . BRACECLOSE COLON mvar
    (17) mvar -> ID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (19) mvar -> ID BRACEOPEN CTEINT . BRACECLOSE
    (20) mvar -> ID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    BRACECLOSE      shift and go to state 58


state 49

    (8) main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body .

    $end            reduce using rule 8 (main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body .)


state 50

    (34) body -> BRACKETOPEN . bodyy BRACKETCLOSE
    (35) bodyy -> . statement
    (36) bodyy -> . statement bodyy
    (37) bodyy -> . empty
    (38) statement -> . dec_variables
    (39) statement -> . assignment
    (40) statement -> . condition
    (41) statement -> . writing
    (42) statement -> . reading
    (43) statement -> . call_func
    (44) statement -> . graph
    (45) statement -> . return
    (46) statement -> . while_loop
    (47) statement -> . for_loop
    (48) statement -> . max
    (49) statement -> . min
    (50) statement -> . sum
    (51) statement -> . normal
    (52) statement -> . uniforme
    (53) statement -> . poisson
    (54) statement -> . binomial
    (134) empty -> .
    (55) dec_variables -> . dec_variabless
    (64) assignment -> . variableAssignment EQUAL exp SEMICOLON
    (102) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
    (103) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (108) writing -> . PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
    (114) reading -> . READ multivariables SEMICOLON
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE
    (71) graph -> . PLOT PARENOPEN exp PARENCLOSE SEMICOLON
    (124) return -> . RETURN exp SEMICOLON
    (117) while_loop -> . WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (121) for_loop -> . FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd
    (125) max -> . MAX PARENOPEN exp PARENCLOSE SEMICOLON
    (126) min -> . MIN PARENOPEN exp PARENCLOSE SEMICOLON
    (127) sum -> . SUM PARENOPEN exp PARENCLOSE SEMICOLON
    (133) normal -> . NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (132) uniforme -> . UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON
    (131) poisson -> . POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON
    (130) binomial -> . BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (56) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON dec_variabless
    (57) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON
    (99) variableAssignment -> . ID
    (100) variableAssignment -> . ID BRACEOPEN exp BRACECLOSE
    (101) variableAssignment -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (31) type -> . INT
    (32) type -> . FLOAT
    (33) type -> . CHAR

    BRACKETCLOSE    reduce using rule 134 (empty -> .)
    IF              shift and go to state 81
    PRINT           shift and go to state 82
    READ            shift and go to state 83
    ID              shift and go to state 84
    PLOT            shift and go to state 85
    RETURN          shift and go to state 86
    WHILE           shift and go to state 87
    FOR             shift and go to state 88
    MAX             shift and go to state 89
    MIN             shift and go to state 90
    SUM             shift and go to state 91
    NORMAL          shift and go to state 92
    UNIFORME        shift and go to state 93
    POISSON         shift and go to state 94
    BINOMIAL        shift and go to state 95
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    bodyy                          shift and go to state 59
    statement                      shift and go to state 60
    empty                          shift and go to state 61
    dec_variables                  shift and go to state 62
    assignment                     shift and go to state 63
    condition                      shift and go to state 64
    writing                        shift and go to state 65
    reading                        shift and go to state 66
    call_func                      shift and go to state 67
    graph                          shift and go to state 68
    return                         shift and go to state 69
    while_loop                     shift and go to state 70
    for_loop                       shift and go to state 71
    max                            shift and go to state 72
    min                            shift and go to state 73
    sum                            shift and go to state 74
    normal                         shift and go to state 75
    uniforme                       shift and go to state 76
    poisson                        shift and go to state 77
    binomial                       shift and go to state 78
    dec_variabless                 shift and go to state 79
    variableAssignment             shift and go to state 80
    type                           shift and go to state 96

state 51

    (21) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param . PARENCLOSE body exitFunc

    PARENCLOSE      shift and go to state 97


state 52

    (25) param -> typeParam . ID
    (26) param -> typeParam . ID COLON param

    ID              shift and go to state 98


state 53

    (27) param -> empty .

    PARENCLOSE      reduce using rule 27 (param -> empty .)


state 54

    (28) typeParam -> INT .

    ID              reduce using rule 28 (typeParam -> INT .)


state 55

    (29) typeParam -> FLOAT .

    ID              reduce using rule 29 (typeParam -> FLOAT .)


state 56

    (30) typeParam -> CHAR .

    ID              reduce using rule 30 (typeParam -> CHAR .)


state 57

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param . PARENCLOSE body exitFunc

    PARENCLOSE      shift and go to state 99


state 58

    (16) mvar -> ID BRACEOPEN CTEINT BRACECLOSE . COLON mvar
    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (19) mvar -> ID BRACEOPEN CTEINT BRACECLOSE .
    (20) mvar -> ID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 101
    BRACEOPEN       shift and go to state 100
    SEMICOLON       reduce using rule 19 (mvar -> ID BRACEOPEN CTEINT BRACECLOSE .)


state 59

    (34) body -> BRACKETOPEN bodyy . BRACKETCLOSE

    BRACKETCLOSE    shift and go to state 102


state 60

    (35) bodyy -> statement .
    (36) bodyy -> statement . bodyy
    (35) bodyy -> . statement
    (36) bodyy -> . statement bodyy
    (37) bodyy -> . empty
    (38) statement -> . dec_variables
    (39) statement -> . assignment
    (40) statement -> . condition
    (41) statement -> . writing
    (42) statement -> . reading
    (43) statement -> . call_func
    (44) statement -> . graph
    (45) statement -> . return
    (46) statement -> . while_loop
    (47) statement -> . for_loop
    (48) statement -> . max
    (49) statement -> . min
    (50) statement -> . sum
    (51) statement -> . normal
    (52) statement -> . uniforme
    (53) statement -> . poisson
    (54) statement -> . binomial
    (134) empty -> .
    (55) dec_variables -> . dec_variabless
    (64) assignment -> . variableAssignment EQUAL exp SEMICOLON
    (102) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
    (103) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (108) writing -> . PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
    (114) reading -> . READ multivariables SEMICOLON
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE
    (71) graph -> . PLOT PARENOPEN exp PARENCLOSE SEMICOLON
    (124) return -> . RETURN exp SEMICOLON
    (117) while_loop -> . WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (121) for_loop -> . FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd
    (125) max -> . MAX PARENOPEN exp PARENCLOSE SEMICOLON
    (126) min -> . MIN PARENOPEN exp PARENCLOSE SEMICOLON
    (127) sum -> . SUM PARENOPEN exp PARENCLOSE SEMICOLON
    (133) normal -> . NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (132) uniforme -> . UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON
    (131) poisson -> . POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON
    (130) binomial -> . BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (56) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON dec_variabless
    (57) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON
    (99) variableAssignment -> . ID
    (100) variableAssignment -> . ID BRACEOPEN exp BRACECLOSE
    (101) variableAssignment -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (31) type -> . INT
    (32) type -> . FLOAT
    (33) type -> . CHAR

  ! reduce/reduce conflict for BRACKETCLOSE resolved using rule 35 (bodyy -> statement .)
    BRACKETCLOSE    reduce using rule 35 (bodyy -> statement .)
    IF              shift and go to state 81
    PRINT           shift and go to state 82
    READ            shift and go to state 83
    ID              shift and go to state 84
    PLOT            shift and go to state 85
    RETURN          shift and go to state 86
    WHILE           shift and go to state 87
    FOR             shift and go to state 88
    MAX             shift and go to state 89
    MIN             shift and go to state 90
    SUM             shift and go to state 91
    NORMAL          shift and go to state 92
    UNIFORME        shift and go to state 93
    POISSON         shift and go to state 94
    BINOMIAL        shift and go to state 95
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

  ! BRACKETCLOSE    [ reduce using rule 134 (empty -> .) ]

    statement                      shift and go to state 60
    bodyy                          shift and go to state 103
    empty                          shift and go to state 61
    dec_variables                  shift and go to state 62
    assignment                     shift and go to state 63
    condition                      shift and go to state 64
    writing                        shift and go to state 65
    reading                        shift and go to state 66
    call_func                      shift and go to state 67
    graph                          shift and go to state 68
    return                         shift and go to state 69
    while_loop                     shift and go to state 70
    for_loop                       shift and go to state 71
    max                            shift and go to state 72
    min                            shift and go to state 73
    sum                            shift and go to state 74
    normal                         shift and go to state 75
    uniforme                       shift and go to state 76
    poisson                        shift and go to state 77
    binomial                       shift and go to state 78
    dec_variabless                 shift and go to state 79
    variableAssignment             shift and go to state 80
    type                           shift and go to state 96

state 61

    (37) bodyy -> empty .

    BRACKETCLOSE    reduce using rule 37 (bodyy -> empty .)


state 62

    (38) statement -> dec_variables .

    IF              reduce using rule 38 (statement -> dec_variables .)
    PRINT           reduce using rule 38 (statement -> dec_variables .)
    READ            reduce using rule 38 (statement -> dec_variables .)
    ID              reduce using rule 38 (statement -> dec_variables .)
    PLOT            reduce using rule 38 (statement -> dec_variables .)
    RETURN          reduce using rule 38 (statement -> dec_variables .)
    WHILE           reduce using rule 38 (statement -> dec_variables .)
    FOR             reduce using rule 38 (statement -> dec_variables .)
    MAX             reduce using rule 38 (statement -> dec_variables .)
    MIN             reduce using rule 38 (statement -> dec_variables .)
    SUM             reduce using rule 38 (statement -> dec_variables .)
    NORMAL          reduce using rule 38 (statement -> dec_variables .)
    UNIFORME        reduce using rule 38 (statement -> dec_variables .)
    POISSON         reduce using rule 38 (statement -> dec_variables .)
    BINOMIAL        reduce using rule 38 (statement -> dec_variables .)
    INT             reduce using rule 38 (statement -> dec_variables .)
    FLOAT           reduce using rule 38 (statement -> dec_variables .)
    CHAR            reduce using rule 38 (statement -> dec_variables .)
    BRACKETCLOSE    reduce using rule 38 (statement -> dec_variables .)


state 63

    (39) statement -> assignment .

    IF              reduce using rule 39 (statement -> assignment .)
    PRINT           reduce using rule 39 (statement -> assignment .)
    READ            reduce using rule 39 (statement -> assignment .)
    ID              reduce using rule 39 (statement -> assignment .)
    PLOT            reduce using rule 39 (statement -> assignment .)
    RETURN          reduce using rule 39 (statement -> assignment .)
    WHILE           reduce using rule 39 (statement -> assignment .)
    FOR             reduce using rule 39 (statement -> assignment .)
    MAX             reduce using rule 39 (statement -> assignment .)
    MIN             reduce using rule 39 (statement -> assignment .)
    SUM             reduce using rule 39 (statement -> assignment .)
    NORMAL          reduce using rule 39 (statement -> assignment .)
    UNIFORME        reduce using rule 39 (statement -> assignment .)
    POISSON         reduce using rule 39 (statement -> assignment .)
    BINOMIAL        reduce using rule 39 (statement -> assignment .)
    INT             reduce using rule 39 (statement -> assignment .)
    FLOAT           reduce using rule 39 (statement -> assignment .)
    CHAR            reduce using rule 39 (statement -> assignment .)
    BRACKETCLOSE    reduce using rule 39 (statement -> assignment .)


state 64

    (40) statement -> condition .

    IF              reduce using rule 40 (statement -> condition .)
    PRINT           reduce using rule 40 (statement -> condition .)
    READ            reduce using rule 40 (statement -> condition .)
    ID              reduce using rule 40 (statement -> condition .)
    PLOT            reduce using rule 40 (statement -> condition .)
    RETURN          reduce using rule 40 (statement -> condition .)
    WHILE           reduce using rule 40 (statement -> condition .)
    FOR             reduce using rule 40 (statement -> condition .)
    MAX             reduce using rule 40 (statement -> condition .)
    MIN             reduce using rule 40 (statement -> condition .)
    SUM             reduce using rule 40 (statement -> condition .)
    NORMAL          reduce using rule 40 (statement -> condition .)
    UNIFORME        reduce using rule 40 (statement -> condition .)
    POISSON         reduce using rule 40 (statement -> condition .)
    BINOMIAL        reduce using rule 40 (statement -> condition .)
    INT             reduce using rule 40 (statement -> condition .)
    FLOAT           reduce using rule 40 (statement -> condition .)
    CHAR            reduce using rule 40 (statement -> condition .)
    BRACKETCLOSE    reduce using rule 40 (statement -> condition .)


state 65

    (41) statement -> writing .

    IF              reduce using rule 41 (statement -> writing .)
    PRINT           reduce using rule 41 (statement -> writing .)
    READ            reduce using rule 41 (statement -> writing .)
    ID              reduce using rule 41 (statement -> writing .)
    PLOT            reduce using rule 41 (statement -> writing .)
    RETURN          reduce using rule 41 (statement -> writing .)
    WHILE           reduce using rule 41 (statement -> writing .)
    FOR             reduce using rule 41 (statement -> writing .)
    MAX             reduce using rule 41 (statement -> writing .)
    MIN             reduce using rule 41 (statement -> writing .)
    SUM             reduce using rule 41 (statement -> writing .)
    NORMAL          reduce using rule 41 (statement -> writing .)
    UNIFORME        reduce using rule 41 (statement -> writing .)
    POISSON         reduce using rule 41 (statement -> writing .)
    BINOMIAL        reduce using rule 41 (statement -> writing .)
    INT             reduce using rule 41 (statement -> writing .)
    FLOAT           reduce using rule 41 (statement -> writing .)
    CHAR            reduce using rule 41 (statement -> writing .)
    BRACKETCLOSE    reduce using rule 41 (statement -> writing .)


state 66

    (42) statement -> reading .

    IF              reduce using rule 42 (statement -> reading .)
    PRINT           reduce using rule 42 (statement -> reading .)
    READ            reduce using rule 42 (statement -> reading .)
    ID              reduce using rule 42 (statement -> reading .)
    PLOT            reduce using rule 42 (statement -> reading .)
    RETURN          reduce using rule 42 (statement -> reading .)
    WHILE           reduce using rule 42 (statement -> reading .)
    FOR             reduce using rule 42 (statement -> reading .)
    MAX             reduce using rule 42 (statement -> reading .)
    MIN             reduce using rule 42 (statement -> reading .)
    SUM             reduce using rule 42 (statement -> reading .)
    NORMAL          reduce using rule 42 (statement -> reading .)
    UNIFORME        reduce using rule 42 (statement -> reading .)
    POISSON         reduce using rule 42 (statement -> reading .)
    BINOMIAL        reduce using rule 42 (statement -> reading .)
    INT             reduce using rule 42 (statement -> reading .)
    FLOAT           reduce using rule 42 (statement -> reading .)
    CHAR            reduce using rule 42 (statement -> reading .)
    BRACKETCLOSE    reduce using rule 42 (statement -> reading .)


state 67

    (43) statement -> call_func .

    IF              reduce using rule 43 (statement -> call_func .)
    PRINT           reduce using rule 43 (statement -> call_func .)
    READ            reduce using rule 43 (statement -> call_func .)
    ID              reduce using rule 43 (statement -> call_func .)
    PLOT            reduce using rule 43 (statement -> call_func .)
    RETURN          reduce using rule 43 (statement -> call_func .)
    WHILE           reduce using rule 43 (statement -> call_func .)
    FOR             reduce using rule 43 (statement -> call_func .)
    MAX             reduce using rule 43 (statement -> call_func .)
    MIN             reduce using rule 43 (statement -> call_func .)
    SUM             reduce using rule 43 (statement -> call_func .)
    NORMAL          reduce using rule 43 (statement -> call_func .)
    UNIFORME        reduce using rule 43 (statement -> call_func .)
    POISSON         reduce using rule 43 (statement -> call_func .)
    BINOMIAL        reduce using rule 43 (statement -> call_func .)
    INT             reduce using rule 43 (statement -> call_func .)
    FLOAT           reduce using rule 43 (statement -> call_func .)
    CHAR            reduce using rule 43 (statement -> call_func .)
    BRACKETCLOSE    reduce using rule 43 (statement -> call_func .)


state 68

    (44) statement -> graph .

    IF              reduce using rule 44 (statement -> graph .)
    PRINT           reduce using rule 44 (statement -> graph .)
    READ            reduce using rule 44 (statement -> graph .)
    ID              reduce using rule 44 (statement -> graph .)
    PLOT            reduce using rule 44 (statement -> graph .)
    RETURN          reduce using rule 44 (statement -> graph .)
    WHILE           reduce using rule 44 (statement -> graph .)
    FOR             reduce using rule 44 (statement -> graph .)
    MAX             reduce using rule 44 (statement -> graph .)
    MIN             reduce using rule 44 (statement -> graph .)
    SUM             reduce using rule 44 (statement -> graph .)
    NORMAL          reduce using rule 44 (statement -> graph .)
    UNIFORME        reduce using rule 44 (statement -> graph .)
    POISSON         reduce using rule 44 (statement -> graph .)
    BINOMIAL        reduce using rule 44 (statement -> graph .)
    INT             reduce using rule 44 (statement -> graph .)
    FLOAT           reduce using rule 44 (statement -> graph .)
    CHAR            reduce using rule 44 (statement -> graph .)
    BRACKETCLOSE    reduce using rule 44 (statement -> graph .)


state 69

    (45) statement -> return .

    IF              reduce using rule 45 (statement -> return .)
    PRINT           reduce using rule 45 (statement -> return .)
    READ            reduce using rule 45 (statement -> return .)
    ID              reduce using rule 45 (statement -> return .)
    PLOT            reduce using rule 45 (statement -> return .)
    RETURN          reduce using rule 45 (statement -> return .)
    WHILE           reduce using rule 45 (statement -> return .)
    FOR             reduce using rule 45 (statement -> return .)
    MAX             reduce using rule 45 (statement -> return .)
    MIN             reduce using rule 45 (statement -> return .)
    SUM             reduce using rule 45 (statement -> return .)
    NORMAL          reduce using rule 45 (statement -> return .)
    UNIFORME        reduce using rule 45 (statement -> return .)
    POISSON         reduce using rule 45 (statement -> return .)
    BINOMIAL        reduce using rule 45 (statement -> return .)
    INT             reduce using rule 45 (statement -> return .)
    FLOAT           reduce using rule 45 (statement -> return .)
    CHAR            reduce using rule 45 (statement -> return .)
    BRACKETCLOSE    reduce using rule 45 (statement -> return .)


state 70

    (46) statement -> while_loop .

    IF              reduce using rule 46 (statement -> while_loop .)
    PRINT           reduce using rule 46 (statement -> while_loop .)
    READ            reduce using rule 46 (statement -> while_loop .)
    ID              reduce using rule 46 (statement -> while_loop .)
    PLOT            reduce using rule 46 (statement -> while_loop .)
    RETURN          reduce using rule 46 (statement -> while_loop .)
    WHILE           reduce using rule 46 (statement -> while_loop .)
    FOR             reduce using rule 46 (statement -> while_loop .)
    MAX             reduce using rule 46 (statement -> while_loop .)
    MIN             reduce using rule 46 (statement -> while_loop .)
    SUM             reduce using rule 46 (statement -> while_loop .)
    NORMAL          reduce using rule 46 (statement -> while_loop .)
    UNIFORME        reduce using rule 46 (statement -> while_loop .)
    POISSON         reduce using rule 46 (statement -> while_loop .)
    BINOMIAL        reduce using rule 46 (statement -> while_loop .)
    INT             reduce using rule 46 (statement -> while_loop .)
    FLOAT           reduce using rule 46 (statement -> while_loop .)
    CHAR            reduce using rule 46 (statement -> while_loop .)
    BRACKETCLOSE    reduce using rule 46 (statement -> while_loop .)


state 71

    (47) statement -> for_loop .

    IF              reduce using rule 47 (statement -> for_loop .)
    PRINT           reduce using rule 47 (statement -> for_loop .)
    READ            reduce using rule 47 (statement -> for_loop .)
    ID              reduce using rule 47 (statement -> for_loop .)
    PLOT            reduce using rule 47 (statement -> for_loop .)
    RETURN          reduce using rule 47 (statement -> for_loop .)
    WHILE           reduce using rule 47 (statement -> for_loop .)
    FOR             reduce using rule 47 (statement -> for_loop .)
    MAX             reduce using rule 47 (statement -> for_loop .)
    MIN             reduce using rule 47 (statement -> for_loop .)
    SUM             reduce using rule 47 (statement -> for_loop .)
    NORMAL          reduce using rule 47 (statement -> for_loop .)
    UNIFORME        reduce using rule 47 (statement -> for_loop .)
    POISSON         reduce using rule 47 (statement -> for_loop .)
    BINOMIAL        reduce using rule 47 (statement -> for_loop .)
    INT             reduce using rule 47 (statement -> for_loop .)
    FLOAT           reduce using rule 47 (statement -> for_loop .)
    CHAR            reduce using rule 47 (statement -> for_loop .)
    BRACKETCLOSE    reduce using rule 47 (statement -> for_loop .)


state 72

    (48) statement -> max .

    IF              reduce using rule 48 (statement -> max .)
    PRINT           reduce using rule 48 (statement -> max .)
    READ            reduce using rule 48 (statement -> max .)
    ID              reduce using rule 48 (statement -> max .)
    PLOT            reduce using rule 48 (statement -> max .)
    RETURN          reduce using rule 48 (statement -> max .)
    WHILE           reduce using rule 48 (statement -> max .)
    FOR             reduce using rule 48 (statement -> max .)
    MAX             reduce using rule 48 (statement -> max .)
    MIN             reduce using rule 48 (statement -> max .)
    SUM             reduce using rule 48 (statement -> max .)
    NORMAL          reduce using rule 48 (statement -> max .)
    UNIFORME        reduce using rule 48 (statement -> max .)
    POISSON         reduce using rule 48 (statement -> max .)
    BINOMIAL        reduce using rule 48 (statement -> max .)
    INT             reduce using rule 48 (statement -> max .)
    FLOAT           reduce using rule 48 (statement -> max .)
    CHAR            reduce using rule 48 (statement -> max .)
    BRACKETCLOSE    reduce using rule 48 (statement -> max .)


state 73

    (49) statement -> min .

    IF              reduce using rule 49 (statement -> min .)
    PRINT           reduce using rule 49 (statement -> min .)
    READ            reduce using rule 49 (statement -> min .)
    ID              reduce using rule 49 (statement -> min .)
    PLOT            reduce using rule 49 (statement -> min .)
    RETURN          reduce using rule 49 (statement -> min .)
    WHILE           reduce using rule 49 (statement -> min .)
    FOR             reduce using rule 49 (statement -> min .)
    MAX             reduce using rule 49 (statement -> min .)
    MIN             reduce using rule 49 (statement -> min .)
    SUM             reduce using rule 49 (statement -> min .)
    NORMAL          reduce using rule 49 (statement -> min .)
    UNIFORME        reduce using rule 49 (statement -> min .)
    POISSON         reduce using rule 49 (statement -> min .)
    BINOMIAL        reduce using rule 49 (statement -> min .)
    INT             reduce using rule 49 (statement -> min .)
    FLOAT           reduce using rule 49 (statement -> min .)
    CHAR            reduce using rule 49 (statement -> min .)
    BRACKETCLOSE    reduce using rule 49 (statement -> min .)


state 74

    (50) statement -> sum .

    IF              reduce using rule 50 (statement -> sum .)
    PRINT           reduce using rule 50 (statement -> sum .)
    READ            reduce using rule 50 (statement -> sum .)
    ID              reduce using rule 50 (statement -> sum .)
    PLOT            reduce using rule 50 (statement -> sum .)
    RETURN          reduce using rule 50 (statement -> sum .)
    WHILE           reduce using rule 50 (statement -> sum .)
    FOR             reduce using rule 50 (statement -> sum .)
    MAX             reduce using rule 50 (statement -> sum .)
    MIN             reduce using rule 50 (statement -> sum .)
    SUM             reduce using rule 50 (statement -> sum .)
    NORMAL          reduce using rule 50 (statement -> sum .)
    UNIFORME        reduce using rule 50 (statement -> sum .)
    POISSON         reduce using rule 50 (statement -> sum .)
    BINOMIAL        reduce using rule 50 (statement -> sum .)
    INT             reduce using rule 50 (statement -> sum .)
    FLOAT           reduce using rule 50 (statement -> sum .)
    CHAR            reduce using rule 50 (statement -> sum .)
    BRACKETCLOSE    reduce using rule 50 (statement -> sum .)


state 75

    (51) statement -> normal .

    IF              reduce using rule 51 (statement -> normal .)
    PRINT           reduce using rule 51 (statement -> normal .)
    READ            reduce using rule 51 (statement -> normal .)
    ID              reduce using rule 51 (statement -> normal .)
    PLOT            reduce using rule 51 (statement -> normal .)
    RETURN          reduce using rule 51 (statement -> normal .)
    WHILE           reduce using rule 51 (statement -> normal .)
    FOR             reduce using rule 51 (statement -> normal .)
    MAX             reduce using rule 51 (statement -> normal .)
    MIN             reduce using rule 51 (statement -> normal .)
    SUM             reduce using rule 51 (statement -> normal .)
    NORMAL          reduce using rule 51 (statement -> normal .)
    UNIFORME        reduce using rule 51 (statement -> normal .)
    POISSON         reduce using rule 51 (statement -> normal .)
    BINOMIAL        reduce using rule 51 (statement -> normal .)
    INT             reduce using rule 51 (statement -> normal .)
    FLOAT           reduce using rule 51 (statement -> normal .)
    CHAR            reduce using rule 51 (statement -> normal .)
    BRACKETCLOSE    reduce using rule 51 (statement -> normal .)


state 76

    (52) statement -> uniforme .

    IF              reduce using rule 52 (statement -> uniforme .)
    PRINT           reduce using rule 52 (statement -> uniforme .)
    READ            reduce using rule 52 (statement -> uniforme .)
    ID              reduce using rule 52 (statement -> uniforme .)
    PLOT            reduce using rule 52 (statement -> uniforme .)
    RETURN          reduce using rule 52 (statement -> uniforme .)
    WHILE           reduce using rule 52 (statement -> uniforme .)
    FOR             reduce using rule 52 (statement -> uniforme .)
    MAX             reduce using rule 52 (statement -> uniforme .)
    MIN             reduce using rule 52 (statement -> uniforme .)
    SUM             reduce using rule 52 (statement -> uniforme .)
    NORMAL          reduce using rule 52 (statement -> uniforme .)
    UNIFORME        reduce using rule 52 (statement -> uniforme .)
    POISSON         reduce using rule 52 (statement -> uniforme .)
    BINOMIAL        reduce using rule 52 (statement -> uniforme .)
    INT             reduce using rule 52 (statement -> uniforme .)
    FLOAT           reduce using rule 52 (statement -> uniforme .)
    CHAR            reduce using rule 52 (statement -> uniforme .)
    BRACKETCLOSE    reduce using rule 52 (statement -> uniforme .)


state 77

    (53) statement -> poisson .

    IF              reduce using rule 53 (statement -> poisson .)
    PRINT           reduce using rule 53 (statement -> poisson .)
    READ            reduce using rule 53 (statement -> poisson .)
    ID              reduce using rule 53 (statement -> poisson .)
    PLOT            reduce using rule 53 (statement -> poisson .)
    RETURN          reduce using rule 53 (statement -> poisson .)
    WHILE           reduce using rule 53 (statement -> poisson .)
    FOR             reduce using rule 53 (statement -> poisson .)
    MAX             reduce using rule 53 (statement -> poisson .)
    MIN             reduce using rule 53 (statement -> poisson .)
    SUM             reduce using rule 53 (statement -> poisson .)
    NORMAL          reduce using rule 53 (statement -> poisson .)
    UNIFORME        reduce using rule 53 (statement -> poisson .)
    POISSON         reduce using rule 53 (statement -> poisson .)
    BINOMIAL        reduce using rule 53 (statement -> poisson .)
    INT             reduce using rule 53 (statement -> poisson .)
    FLOAT           reduce using rule 53 (statement -> poisson .)
    CHAR            reduce using rule 53 (statement -> poisson .)
    BRACKETCLOSE    reduce using rule 53 (statement -> poisson .)


state 78

    (54) statement -> binomial .

    IF              reduce using rule 54 (statement -> binomial .)
    PRINT           reduce using rule 54 (statement -> binomial .)
    READ            reduce using rule 54 (statement -> binomial .)
    ID              reduce using rule 54 (statement -> binomial .)
    PLOT            reduce using rule 54 (statement -> binomial .)
    RETURN          reduce using rule 54 (statement -> binomial .)
    WHILE           reduce using rule 54 (statement -> binomial .)
    FOR             reduce using rule 54 (statement -> binomial .)
    MAX             reduce using rule 54 (statement -> binomial .)
    MIN             reduce using rule 54 (statement -> binomial .)
    SUM             reduce using rule 54 (statement -> binomial .)
    NORMAL          reduce using rule 54 (statement -> binomial .)
    UNIFORME        reduce using rule 54 (statement -> binomial .)
    POISSON         reduce using rule 54 (statement -> binomial .)
    BINOMIAL        reduce using rule 54 (statement -> binomial .)
    INT             reduce using rule 54 (statement -> binomial .)
    FLOAT           reduce using rule 54 (statement -> binomial .)
    CHAR            reduce using rule 54 (statement -> binomial .)
    BRACKETCLOSE    reduce using rule 54 (statement -> binomial .)


state 79

    (55) dec_variables -> dec_variabless .

    IF              reduce using rule 55 (dec_variables -> dec_variabless .)
    PRINT           reduce using rule 55 (dec_variables -> dec_variabless .)
    READ            reduce using rule 55 (dec_variables -> dec_variabless .)
    ID              reduce using rule 55 (dec_variables -> dec_variabless .)
    PLOT            reduce using rule 55 (dec_variables -> dec_variabless .)
    RETURN          reduce using rule 55 (dec_variables -> dec_variabless .)
    WHILE           reduce using rule 55 (dec_variables -> dec_variabless .)
    FOR             reduce using rule 55 (dec_variables -> dec_variabless .)
    MAX             reduce using rule 55 (dec_variables -> dec_variabless .)
    MIN             reduce using rule 55 (dec_variables -> dec_variabless .)
    SUM             reduce using rule 55 (dec_variables -> dec_variabless .)
    NORMAL          reduce using rule 55 (dec_variables -> dec_variabless .)
    UNIFORME        reduce using rule 55 (dec_variables -> dec_variabless .)
    POISSON         reduce using rule 55 (dec_variables -> dec_variabless .)
    BINOMIAL        reduce using rule 55 (dec_variables -> dec_variabless .)
    INT             reduce using rule 55 (dec_variables -> dec_variabless .)
    FLOAT           reduce using rule 55 (dec_variables -> dec_variabless .)
    CHAR            reduce using rule 55 (dec_variables -> dec_variabless .)
    BRACKETCLOSE    reduce using rule 55 (dec_variables -> dec_variabless .)


state 80

    (64) assignment -> variableAssignment . EQUAL exp SEMICOLON

    EQUAL           shift and go to state 104


state 81

    (102) condition -> IF . PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
    (103) condition -> IF . PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse

    PARENOPEN       shift and go to state 105


state 82

    (108) writing -> PRINT . PARENOPEN writingg PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 106


state 83

    (114) reading -> READ . multivariables SEMICOLON
    (115) multivariables -> . variable
    (116) multivariables -> . variable COLON multivariables
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 109

    multivariables                 shift and go to state 107
    variable                       shift and go to state 108

state 84

    (65) call_func -> ID . generarERA PARENOPEN call_funcc PARENCLOSE
    (99) variableAssignment -> ID .
    (100) variableAssignment -> ID . BRACEOPEN exp BRACECLOSE
    (101) variableAssignment -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (66) generarERA -> . empty
    (134) empty -> .

    EQUAL           reduce using rule 99 (variableAssignment -> ID .)
    BRACEOPEN       shift and go to state 111
    PARENOPEN       reduce using rule 134 (empty -> .)

    generarERA                     shift and go to state 110
    empty                          shift and go to state 112

state 85

    (71) graph -> PLOT . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 113


state 86

    (124) return -> RETURN . exp SEMICOLON
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 114
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 87

    (117) while_loop -> WHILE . whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (118) whileMigaja -> . empty
    (134) empty -> .

    PARENOPEN       reduce using rule 134 (empty -> .)

    whileMigaja                    shift and go to state 125
    empty                          shift and go to state 126

state 88

    (121) for_loop -> FOR . PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd

    PARENOPEN       shift and go to state 127


state 89

    (125) max -> MAX . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 128


state 90

    (126) min -> MIN . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 129


state 91

    (127) sum -> SUM . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 130


state 92

    (133) normal -> NORMAL . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 131


state 93

    (132) uniforme -> UNIFORME . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 132


state 94

    (131) poisson -> POISSON . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 133


state 95

    (130) binomial -> BINOMIAL . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 134


state 96

    (56) dec_variabless -> type . guardarTipo dec_mvar SEMICOLON dec_variabless
    (57) dec_variabless -> type . guardarTipo dec_mvar SEMICOLON
    (14) guardarTipo -> . empty
    (134) empty -> .

    ID              reduce using rule 134 (empty -> .)

    guardarTipo                    shift and go to state 135
    empty                          shift and go to state 29

state 97

    (21) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE . body exitFunc
    (34) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 136

state 98

    (25) param -> typeParam ID .
    (26) param -> typeParam ID . COLON param

    PARENCLOSE      reduce using rule 25 (param -> typeParam ID .)
    COLON           shift and go to state 137


state 99

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE . body exitFunc
    (34) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 138

state 100

    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE COLON mvar
    (20) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE

    CTEINT          shift and go to state 139


state 101

    (16) mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON . mvar
    (15) mvar -> . ID COLON mvar
    (16) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> . ID
    (19) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (20) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 34

    mvar                           shift and go to state 140

state 102

    (34) body -> BRACKETOPEN bodyy BRACKETCLOSE .

    $end            reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FUNCTION        reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MAIN            reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    ELSE            reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    IF              reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    PRINT           reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    READ            reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    ID              reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    PLOT            reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    RETURN          reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    WHILE           reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FOR             reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MAX             reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MIN             reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    SUM             reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    NORMAL          reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    UNIFORME        reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    POISSON         reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    BINOMIAL        reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    INT             reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FLOAT           reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    CHAR            reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    BRACKETCLOSE    reduce using rule 34 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)


state 103

    (36) bodyy -> statement bodyy .

    BRACKETCLOSE    reduce using rule 36 (bodyy -> statement bodyy .)


state 104

    (64) assignment -> variableAssignment EQUAL . exp SEMICOLON
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 141
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 105

    (102) condition -> IF PARENOPEN . exp PARENCLOSE cuadruploIF body ifEnd
    (103) condition -> IF PARENOPEN . exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 142
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 106

    (108) writing -> PRINT PARENOPEN . writingg PARENCLOSE SEMICOLON
    (109) writingg -> . exp
    (110) writingg -> . exp COLON writingg
    (111) writingg -> . auxString
    (112) writingg -> . auxString COLON writingg
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (113) auxString -> . CTESTRING
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 146
    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    writingg                       shift and go to state 143
    exp                            shift and go to state 144
    auxString                      shift and go to state 145
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 107

    (114) reading -> READ multivariables . SEMICOLON

    SEMICOLON       shift and go to state 147


state 108

    (115) multivariables -> variable .
    (116) multivariables -> variable . COLON multivariables

    SEMICOLON       reduce using rule 115 (multivariables -> variable .)
    COLON           shift and go to state 148


state 109

    (96) variable -> ID .
    (97) variable -> ID . BRACEOPEN exp BRACECLOSE
    (98) variable -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    COLON           reduce using rule 96 (variable -> ID .)
    SEMICOLON       reduce using rule 96 (variable -> ID .)
    PARENCLOSE      reduce using rule 96 (variable -> ID .)
    BRACEOPEN       shift and go to state 149


state 110

    (65) call_func -> ID generarERA . PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 150


state 111

    (100) variableAssignment -> ID BRACEOPEN . exp BRACECLOSE
    (101) variableAssignment -> ID BRACEOPEN . exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 151
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 112

    (66) generarERA -> empty .

    PARENOPEN       reduce using rule 66 (generarERA -> empty .)


state 113

    (71) graph -> PLOT PARENOPEN . exp PARENCLOSE SEMICOLON
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 152
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 114

    (124) return -> RETURN exp . SEMICOLON
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp

    SEMICOLON       shift and go to state 153
    AND             shift and go to state 154
    OR              shift and go to state 155


state 115

    (72) exp -> expp .
    (76) expp -> expp . GREATHERTHAN m_exp
    (77) expp -> expp . LESSTHAN m_exp
    (78) expp -> expp . GREATHEREQUAL m_exp
    (79) expp -> expp . LESSEQUAL m_exp
    (80) expp -> expp . DIFFERENT m_exp
    (81) expp -> expp . SAME m_exp

    SEMICOLON       reduce using rule 72 (exp -> expp .)
    AND             reduce using rule 72 (exp -> expp .)
    OR              reduce using rule 72 (exp -> expp .)
    PARENCLOSE      reduce using rule 72 (exp -> expp .)
    COLON           reduce using rule 72 (exp -> expp .)
    BRACECLOSE      reduce using rule 72 (exp -> expp .)
    TO              reduce using rule 72 (exp -> expp .)
    GREATHERTHAN    shift and go to state 156
    LESSTHAN        shift and go to state 157
    GREATHEREQUAL   shift and go to state 158
    LESSEQUAL       shift and go to state 159
    DIFFERENT       shift and go to state 160
    SAME            shift and go to state 161


state 116

    (75) expp -> m_exp .
    (83) m_exp -> m_exp . PLUS termino
    (84) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 75 (expp -> m_exp .)
    LESSTHAN        reduce using rule 75 (expp -> m_exp .)
    GREATHEREQUAL   reduce using rule 75 (expp -> m_exp .)
    LESSEQUAL       reduce using rule 75 (expp -> m_exp .)
    DIFFERENT       reduce using rule 75 (expp -> m_exp .)
    SAME            reduce using rule 75 (expp -> m_exp .)
    SEMICOLON       reduce using rule 75 (expp -> m_exp .)
    AND             reduce using rule 75 (expp -> m_exp .)
    OR              reduce using rule 75 (expp -> m_exp .)
    PARENCLOSE      reduce using rule 75 (expp -> m_exp .)
    COLON           reduce using rule 75 (expp -> m_exp .)
    BRACECLOSE      reduce using rule 75 (expp -> m_exp .)
    TO              reduce using rule 75 (expp -> m_exp .)
    PLUS            shift and go to state 162
    MINUS           shift and go to state 163


state 117

    (82) m_exp -> termino .
    (86) termino -> termino . MULTIPLY factor
    (87) termino -> termino . DIVIDE factor

    PLUS            reduce using rule 82 (m_exp -> termino .)
    MINUS           reduce using rule 82 (m_exp -> termino .)
    GREATHERTHAN    reduce using rule 82 (m_exp -> termino .)
    LESSTHAN        reduce using rule 82 (m_exp -> termino .)
    GREATHEREQUAL   reduce using rule 82 (m_exp -> termino .)
    LESSEQUAL       reduce using rule 82 (m_exp -> termino .)
    DIFFERENT       reduce using rule 82 (m_exp -> termino .)
    SAME            reduce using rule 82 (m_exp -> termino .)
    SEMICOLON       reduce using rule 82 (m_exp -> termino .)
    AND             reduce using rule 82 (m_exp -> termino .)
    OR              reduce using rule 82 (m_exp -> termino .)
    PARENCLOSE      reduce using rule 82 (m_exp -> termino .)
    COLON           reduce using rule 82 (m_exp -> termino .)
    BRACECLOSE      reduce using rule 82 (m_exp -> termino .)
    TO              reduce using rule 82 (m_exp -> termino .)
    MULTIPLY        shift and go to state 164
    DIVIDE          shift and go to state 165


state 118

    (85) termino -> factor .

    MULTIPLY        reduce using rule 85 (termino -> factor .)
    DIVIDE          reduce using rule 85 (termino -> factor .)
    PLUS            reduce using rule 85 (termino -> factor .)
    MINUS           reduce using rule 85 (termino -> factor .)
    GREATHERTHAN    reduce using rule 85 (termino -> factor .)
    LESSTHAN        reduce using rule 85 (termino -> factor .)
    GREATHEREQUAL   reduce using rule 85 (termino -> factor .)
    LESSEQUAL       reduce using rule 85 (termino -> factor .)
    DIFFERENT       reduce using rule 85 (termino -> factor .)
    SAME            reduce using rule 85 (termino -> factor .)
    SEMICOLON       reduce using rule 85 (termino -> factor .)
    AND             reduce using rule 85 (termino -> factor .)
    OR              reduce using rule 85 (termino -> factor .)
    PARENCLOSE      reduce using rule 85 (termino -> factor .)
    COLON           reduce using rule 85 (termino -> factor .)
    BRACECLOSE      reduce using rule 85 (termino -> factor .)
    TO              reduce using rule 85 (termino -> factor .)


state 119

    (88) factor -> ID .
    (96) variable -> ID .
    (97) variable -> ID . BRACEOPEN exp BRACECLOSE
    (98) variable -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> ID . generarERA PARENOPEN call_funcc PARENCLOSE
    (66) generarERA -> . empty
    (134) empty -> .

  ! reduce/reduce conflict for MULTIPLY resolved using rule 88 (factor -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 88 (factor -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 88 (factor -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 88 (factor -> ID .)
  ! reduce/reduce conflict for GREATHERTHAN resolved using rule 88 (factor -> ID .)
  ! reduce/reduce conflict for LESSTHAN resolved using rule 88 (factor -> ID .)
  ! reduce/reduce conflict for GREATHEREQUAL resolved using rule 88 (factor -> ID .)
  ! reduce/reduce conflict for LESSEQUAL resolved using rule 88 (factor -> ID .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 88 (factor -> ID .)
  ! reduce/reduce conflict for SAME resolved using rule 88 (factor -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 88 (factor -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 88 (factor -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 88 (factor -> ID .)
  ! reduce/reduce conflict for PARENCLOSE resolved using rule 88 (factor -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 88 (factor -> ID .)
  ! reduce/reduce conflict for BRACECLOSE resolved using rule 88 (factor -> ID .)
  ! reduce/reduce conflict for TO resolved using rule 88 (factor -> ID .)
    MULTIPLY        reduce using rule 88 (factor -> ID .)
    DIVIDE          reduce using rule 88 (factor -> ID .)
    PLUS            reduce using rule 88 (factor -> ID .)
    MINUS           reduce using rule 88 (factor -> ID .)
    GREATHERTHAN    reduce using rule 88 (factor -> ID .)
    LESSTHAN        reduce using rule 88 (factor -> ID .)
    GREATHEREQUAL   reduce using rule 88 (factor -> ID .)
    LESSEQUAL       reduce using rule 88 (factor -> ID .)
    DIFFERENT       reduce using rule 88 (factor -> ID .)
    SAME            reduce using rule 88 (factor -> ID .)
    SEMICOLON       reduce using rule 88 (factor -> ID .)
    AND             reduce using rule 88 (factor -> ID .)
    OR              reduce using rule 88 (factor -> ID .)
    PARENCLOSE      reduce using rule 88 (factor -> ID .)
    COLON           reduce using rule 88 (factor -> ID .)
    BRACECLOSE      reduce using rule 88 (factor -> ID .)
    TO              reduce using rule 88 (factor -> ID .)
    BRACEOPEN       shift and go to state 149
    PARENOPEN       reduce using rule 134 (empty -> .)

  ! MULTIPLY        [ reduce using rule 96 (variable -> ID .) ]
  ! DIVIDE          [ reduce using rule 96 (variable -> ID .) ]
  ! PLUS            [ reduce using rule 96 (variable -> ID .) ]
  ! MINUS           [ reduce using rule 96 (variable -> ID .) ]
  ! GREATHERTHAN    [ reduce using rule 96 (variable -> ID .) ]
  ! LESSTHAN        [ reduce using rule 96 (variable -> ID .) ]
  ! GREATHEREQUAL   [ reduce using rule 96 (variable -> ID .) ]
  ! LESSEQUAL       [ reduce using rule 96 (variable -> ID .) ]
  ! DIFFERENT       [ reduce using rule 96 (variable -> ID .) ]
  ! SAME            [ reduce using rule 96 (variable -> ID .) ]
  ! SEMICOLON       [ reduce using rule 96 (variable -> ID .) ]
  ! AND             [ reduce using rule 96 (variable -> ID .) ]
  ! OR              [ reduce using rule 96 (variable -> ID .) ]
  ! PARENCLOSE      [ reduce using rule 96 (variable -> ID .) ]
  ! COLON           [ reduce using rule 96 (variable -> ID .) ]
  ! BRACECLOSE      [ reduce using rule 96 (variable -> ID .) ]
  ! TO              [ reduce using rule 96 (variable -> ID .) ]

    generarERA                     shift and go to state 110
    empty                          shift and go to state 112

state 120

    (89) factor -> CTEINT . guardarConstanteInt
    (94) guardarConstanteInt -> . empty
    (134) empty -> .

    MULTIPLY        reduce using rule 134 (empty -> .)
    DIVIDE          reduce using rule 134 (empty -> .)
    PLUS            reduce using rule 134 (empty -> .)
    MINUS           reduce using rule 134 (empty -> .)
    GREATHERTHAN    reduce using rule 134 (empty -> .)
    LESSTHAN        reduce using rule 134 (empty -> .)
    GREATHEREQUAL   reduce using rule 134 (empty -> .)
    LESSEQUAL       reduce using rule 134 (empty -> .)
    DIFFERENT       reduce using rule 134 (empty -> .)
    SAME            reduce using rule 134 (empty -> .)
    SEMICOLON       reduce using rule 134 (empty -> .)
    AND             reduce using rule 134 (empty -> .)
    OR              reduce using rule 134 (empty -> .)
    PARENCLOSE      reduce using rule 134 (empty -> .)
    COLON           reduce using rule 134 (empty -> .)
    BRACECLOSE      reduce using rule 134 (empty -> .)
    TO              reduce using rule 134 (empty -> .)

    guardarConstanteInt            shift and go to state 166
    empty                          shift and go to state 167

state 121

    (90) factor -> CTFLOAT . guardarConstanteFloat
    (95) guardarConstanteFloat -> . empty
    (134) empty -> .

    MULTIPLY        reduce using rule 134 (empty -> .)
    DIVIDE          reduce using rule 134 (empty -> .)
    PLUS            reduce using rule 134 (empty -> .)
    MINUS           reduce using rule 134 (empty -> .)
    GREATHERTHAN    reduce using rule 134 (empty -> .)
    LESSTHAN        reduce using rule 134 (empty -> .)
    GREATHEREQUAL   reduce using rule 134 (empty -> .)
    LESSEQUAL       reduce using rule 134 (empty -> .)
    DIFFERENT       reduce using rule 134 (empty -> .)
    SAME            reduce using rule 134 (empty -> .)
    SEMICOLON       reduce using rule 134 (empty -> .)
    AND             reduce using rule 134 (empty -> .)
    OR              reduce using rule 134 (empty -> .)
    PARENCLOSE      reduce using rule 134 (empty -> .)
    COLON           reduce using rule 134 (empty -> .)
    BRACECLOSE      reduce using rule 134 (empty -> .)
    TO              reduce using rule 134 (empty -> .)

    guardarConstanteFloat          shift and go to state 168
    empty                          shift and go to state 169

state 122

    (91) factor -> variable .

    MULTIPLY        reduce using rule 91 (factor -> variable .)
    DIVIDE          reduce using rule 91 (factor -> variable .)
    PLUS            reduce using rule 91 (factor -> variable .)
    MINUS           reduce using rule 91 (factor -> variable .)
    GREATHERTHAN    reduce using rule 91 (factor -> variable .)
    LESSTHAN        reduce using rule 91 (factor -> variable .)
    GREATHEREQUAL   reduce using rule 91 (factor -> variable .)
    LESSEQUAL       reduce using rule 91 (factor -> variable .)
    DIFFERENT       reduce using rule 91 (factor -> variable .)
    SAME            reduce using rule 91 (factor -> variable .)
    SEMICOLON       reduce using rule 91 (factor -> variable .)
    AND             reduce using rule 91 (factor -> variable .)
    OR              reduce using rule 91 (factor -> variable .)
    PARENCLOSE      reduce using rule 91 (factor -> variable .)
    COLON           reduce using rule 91 (factor -> variable .)
    BRACECLOSE      reduce using rule 91 (factor -> variable .)
    TO              reduce using rule 91 (factor -> variable .)


state 123

    (92) factor -> call_func .

    MULTIPLY        reduce using rule 92 (factor -> call_func .)
    DIVIDE          reduce using rule 92 (factor -> call_func .)
    PLUS            reduce using rule 92 (factor -> call_func .)
    MINUS           reduce using rule 92 (factor -> call_func .)
    GREATHERTHAN    reduce using rule 92 (factor -> call_func .)
    LESSTHAN        reduce using rule 92 (factor -> call_func .)
    GREATHEREQUAL   reduce using rule 92 (factor -> call_func .)
    LESSEQUAL       reduce using rule 92 (factor -> call_func .)
    DIFFERENT       reduce using rule 92 (factor -> call_func .)
    SAME            reduce using rule 92 (factor -> call_func .)
    SEMICOLON       reduce using rule 92 (factor -> call_func .)
    AND             reduce using rule 92 (factor -> call_func .)
    OR              reduce using rule 92 (factor -> call_func .)
    PARENCLOSE      reduce using rule 92 (factor -> call_func .)
    COLON           reduce using rule 92 (factor -> call_func .)
    BRACECLOSE      reduce using rule 92 (factor -> call_func .)
    TO              reduce using rule 92 (factor -> call_func .)


state 124

    (93) factor -> PARENOPEN . exp PARENCLOSE
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 170
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 125

    (117) while_loop -> WHILE whileMigaja . PARENOPEN exp PARENCLOSE whileEval body whileEnd

    PARENOPEN       shift and go to state 171


state 126

    (118) whileMigaja -> empty .

    PARENOPEN       reduce using rule 118 (whileMigaja -> empty .)


state 127

    (121) for_loop -> FOR PARENOPEN . ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd

    ID              shift and go to state 172


state 128

    (125) max -> MAX PARENOPEN . exp PARENCLOSE SEMICOLON
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 173
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 129

    (126) min -> MIN PARENOPEN . exp PARENCLOSE SEMICOLON
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 174
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 130

    (127) sum -> SUM PARENOPEN . exp PARENCLOSE SEMICOLON
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 175
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 131

    (133) normal -> NORMAL PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (128) param_dist -> . variable
    (129) param_dist -> . variable COLON param_dist
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 109

    param_dist                     shift and go to state 176
    variable                       shift and go to state 177

state 132

    (132) uniforme -> UNIFORME PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (128) param_dist -> . variable
    (129) param_dist -> . variable COLON param_dist
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 109

    param_dist                     shift and go to state 178
    variable                       shift and go to state 177

state 133

    (131) poisson -> POISSON PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (128) param_dist -> . variable
    (129) param_dist -> . variable COLON param_dist
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 109

    param_dist                     shift and go to state 179
    variable                       shift and go to state 177

state 134

    (130) binomial -> BINOMIAL PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (128) param_dist -> . variable
    (129) param_dist -> . variable COLON param_dist
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 109

    param_dist                     shift and go to state 180
    variable                       shift and go to state 177

state 135

    (56) dec_variabless -> type guardarTipo . dec_mvar SEMICOLON dec_variabless
    (57) dec_variabless -> type guardarTipo . dec_mvar SEMICOLON
    (58) dec_mvar -> . ID COLON dec_mvar
    (59) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (60) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (61) dec_mvar -> . ID
    (62) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (63) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 182

    dec_mvar                       shift and go to state 181

state 136

    (21) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body . exitFunc
    (24) exitFunc -> . empty
    (134) empty -> .

    FUNCTION        reduce using rule 134 (empty -> .)
    MAIN            reduce using rule 134 (empty -> .)

    exitFunc                       shift and go to state 183
    empty                          shift and go to state 184

state 137

    (26) param -> typeParam ID COLON . param
    (25) param -> . typeParam ID
    (26) param -> . typeParam ID COLON param
    (27) param -> . empty
    (28) typeParam -> . INT
    (29) typeParam -> . FLOAT
    (30) typeParam -> . CHAR
    (134) empty -> .

    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    CHAR            shift and go to state 56
    PARENCLOSE      reduce using rule 134 (empty -> .)

    typeParam                      shift and go to state 52
    param                          shift and go to state 185
    empty                          shift and go to state 53

state 138

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body . exitFunc
    (24) exitFunc -> . empty
    (134) empty -> .

    FUNCTION        reduce using rule 134 (empty -> .)
    MAIN            reduce using rule 134 (empty -> .)

    exitFunc                       shift and go to state 186
    empty                          shift and go to state 184

state 139

    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE COLON mvar
    (20) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE

    BRACECLOSE      shift and go to state 187


state 140

    (16) mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON mvar .

    SEMICOLON       reduce using rule 16 (mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON mvar .)


state 141

    (64) assignment -> variableAssignment EQUAL exp . SEMICOLON
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp

    SEMICOLON       shift and go to state 188
    AND             shift and go to state 154
    OR              shift and go to state 155


state 142

    (102) condition -> IF PARENOPEN exp . PARENCLOSE cuadruploIF body ifEnd
    (103) condition -> IF PARENOPEN exp . PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 189
    AND             shift and go to state 154
    OR              shift and go to state 155


state 143

    (108) writing -> PRINT PARENOPEN writingg . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 190


state 144

    (109) writingg -> exp .
    (110) writingg -> exp . COLON writingg
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp

    PARENCLOSE      reduce using rule 109 (writingg -> exp .)
    COLON           shift and go to state 191
    AND             shift and go to state 154
    OR              shift and go to state 155


state 145

    (111) writingg -> auxString .
    (112) writingg -> auxString . COLON writingg

    PARENCLOSE      reduce using rule 111 (writingg -> auxString .)
    COLON           shift and go to state 192


state 146

    (113) auxString -> CTESTRING .

    COLON           reduce using rule 113 (auxString -> CTESTRING .)
    PARENCLOSE      reduce using rule 113 (auxString -> CTESTRING .)


state 147

    (114) reading -> READ multivariables SEMICOLON .

    IF              reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    PRINT           reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    READ            reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    ID              reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    PLOT            reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    RETURN          reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    WHILE           reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    FOR             reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    MAX             reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    MIN             reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    SUM             reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    NORMAL          reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    UNIFORME        reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    POISSON         reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    BINOMIAL        reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    INT             reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    FLOAT           reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    CHAR            reduce using rule 114 (reading -> READ multivariables SEMICOLON .)
    BRACKETCLOSE    reduce using rule 114 (reading -> READ multivariables SEMICOLON .)


state 148

    (116) multivariables -> variable COLON . multivariables
    (115) multivariables -> . variable
    (116) multivariables -> . variable COLON multivariables
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 109

    variable                       shift and go to state 108
    multivariables                 shift and go to state 193

state 149

    (97) variable -> ID BRACEOPEN . exp BRACECLOSE
    (98) variable -> ID BRACEOPEN . exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 194
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 150

    (65) call_func -> ID generarERA PARENOPEN . call_funcc PARENCLOSE
    (67) call_funcc -> . exp mandarParam
    (68) call_funcc -> . exp mandarParam COLON call_funcc
    (69) call_funcc -> . empty
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (134) empty -> .
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    PARENCLOSE      reduce using rule 134 (empty -> .)
    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    call_funcc                     shift and go to state 195
    exp                            shift and go to state 196
    empty                          shift and go to state 197
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 151

    (100) variableAssignment -> ID BRACEOPEN exp . BRACECLOSE
    (101) variableAssignment -> ID BRACEOPEN exp . BRACECLOSE BRACEOPEN exp BRACECLOSE
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp

    BRACECLOSE      shift and go to state 198
    AND             shift and go to state 154
    OR              shift and go to state 155


state 152

    (71) graph -> PLOT PARENOPEN exp . PARENCLOSE SEMICOLON
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 199
    AND             shift and go to state 154
    OR              shift and go to state 155


state 153

    (124) return -> RETURN exp SEMICOLON .

    IF              reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    PRINT           reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    READ            reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    ID              reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    PLOT            reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    RETURN          reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    WHILE           reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    FOR             reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    MAX             reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    MIN             reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    SUM             reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    NORMAL          reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    UNIFORME        reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    POISSON         reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    BINOMIAL        reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    INT             reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    FLOAT           reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    CHAR            reduce using rule 124 (return -> RETURN exp SEMICOLON .)
    BRACKETCLOSE    reduce using rule 124 (return -> RETURN exp SEMICOLON .)


state 154

    (73) exp -> exp AND . expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    expp                           shift and go to state 200
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 155

    (74) exp -> exp OR . expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    expp                           shift and go to state 201
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 156

    (76) expp -> expp GREATHERTHAN . m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    m_exp                          shift and go to state 202
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 157

    (77) expp -> expp LESSTHAN . m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    m_exp                          shift and go to state 203
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 158

    (78) expp -> expp GREATHEREQUAL . m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    m_exp                          shift and go to state 204
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 159

    (79) expp -> expp LESSEQUAL . m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    m_exp                          shift and go to state 205
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 160

    (80) expp -> expp DIFFERENT . m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    m_exp                          shift and go to state 206
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 161

    (81) expp -> expp SAME . m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    m_exp                          shift and go to state 207
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 162

    (83) m_exp -> m_exp PLUS . termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    termino                        shift and go to state 208
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 163

    (84) m_exp -> m_exp MINUS . termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    termino                        shift and go to state 209
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 164

    (86) termino -> termino MULTIPLY . factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    factor                         shift and go to state 210
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 165

    (87) termino -> termino DIVIDE . factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    factor                         shift and go to state 211
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 166

    (89) factor -> CTEINT guardarConstanteInt .

    MULTIPLY        reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)
    DIVIDE          reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)
    PLUS            reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)
    MINUS           reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)
    GREATHERTHAN    reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)
    LESSTHAN        reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)
    GREATHEREQUAL   reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)
    LESSEQUAL       reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)
    DIFFERENT       reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)
    SAME            reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)
    SEMICOLON       reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)
    AND             reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)
    OR              reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)
    PARENCLOSE      reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)
    COLON           reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)
    BRACECLOSE      reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)
    TO              reduce using rule 89 (factor -> CTEINT guardarConstanteInt .)


state 167

    (94) guardarConstanteInt -> empty .

    MULTIPLY        reduce using rule 94 (guardarConstanteInt -> empty .)
    DIVIDE          reduce using rule 94 (guardarConstanteInt -> empty .)
    PLUS            reduce using rule 94 (guardarConstanteInt -> empty .)
    MINUS           reduce using rule 94 (guardarConstanteInt -> empty .)
    GREATHERTHAN    reduce using rule 94 (guardarConstanteInt -> empty .)
    LESSTHAN        reduce using rule 94 (guardarConstanteInt -> empty .)
    GREATHEREQUAL   reduce using rule 94 (guardarConstanteInt -> empty .)
    LESSEQUAL       reduce using rule 94 (guardarConstanteInt -> empty .)
    DIFFERENT       reduce using rule 94 (guardarConstanteInt -> empty .)
    SAME            reduce using rule 94 (guardarConstanteInt -> empty .)
    SEMICOLON       reduce using rule 94 (guardarConstanteInt -> empty .)
    AND             reduce using rule 94 (guardarConstanteInt -> empty .)
    OR              reduce using rule 94 (guardarConstanteInt -> empty .)
    PARENCLOSE      reduce using rule 94 (guardarConstanteInt -> empty .)
    COLON           reduce using rule 94 (guardarConstanteInt -> empty .)
    BRACECLOSE      reduce using rule 94 (guardarConstanteInt -> empty .)
    TO              reduce using rule 94 (guardarConstanteInt -> empty .)


state 168

    (90) factor -> CTFLOAT guardarConstanteFloat .

    MULTIPLY        reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)
    DIVIDE          reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)
    PLUS            reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)
    MINUS           reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)
    GREATHERTHAN    reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)
    LESSTHAN        reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)
    GREATHEREQUAL   reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)
    LESSEQUAL       reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)
    DIFFERENT       reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)
    SAME            reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)
    SEMICOLON       reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)
    AND             reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)
    OR              reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)
    PARENCLOSE      reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)
    COLON           reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)
    BRACECLOSE      reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)
    TO              reduce using rule 90 (factor -> CTFLOAT guardarConstanteFloat .)


state 169

    (95) guardarConstanteFloat -> empty .

    MULTIPLY        reduce using rule 95 (guardarConstanteFloat -> empty .)
    DIVIDE          reduce using rule 95 (guardarConstanteFloat -> empty .)
    PLUS            reduce using rule 95 (guardarConstanteFloat -> empty .)
    MINUS           reduce using rule 95 (guardarConstanteFloat -> empty .)
    GREATHERTHAN    reduce using rule 95 (guardarConstanteFloat -> empty .)
    LESSTHAN        reduce using rule 95 (guardarConstanteFloat -> empty .)
    GREATHEREQUAL   reduce using rule 95 (guardarConstanteFloat -> empty .)
    LESSEQUAL       reduce using rule 95 (guardarConstanteFloat -> empty .)
    DIFFERENT       reduce using rule 95 (guardarConstanteFloat -> empty .)
    SAME            reduce using rule 95 (guardarConstanteFloat -> empty .)
    SEMICOLON       reduce using rule 95 (guardarConstanteFloat -> empty .)
    AND             reduce using rule 95 (guardarConstanteFloat -> empty .)
    OR              reduce using rule 95 (guardarConstanteFloat -> empty .)
    PARENCLOSE      reduce using rule 95 (guardarConstanteFloat -> empty .)
    COLON           reduce using rule 95 (guardarConstanteFloat -> empty .)
    BRACECLOSE      reduce using rule 95 (guardarConstanteFloat -> empty .)
    TO              reduce using rule 95 (guardarConstanteFloat -> empty .)


state 170

    (93) factor -> PARENOPEN exp . PARENCLOSE
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 212
    AND             shift and go to state 154
    OR              shift and go to state 155


state 171

    (117) while_loop -> WHILE whileMigaja PARENOPEN . exp PARENCLOSE whileEval body whileEnd
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 213
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 172

    (121) for_loop -> FOR PARENOPEN ID . EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd

    EQUAL           shift and go to state 214


state 173

    (125) max -> MAX PARENOPEN exp . PARENCLOSE SEMICOLON
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 215
    AND             shift and go to state 154
    OR              shift and go to state 155


state 174

    (126) min -> MIN PARENOPEN exp . PARENCLOSE SEMICOLON
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 216
    AND             shift and go to state 154
    OR              shift and go to state 155


state 175

    (127) sum -> SUM PARENOPEN exp . PARENCLOSE SEMICOLON
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 217
    AND             shift and go to state 154
    OR              shift and go to state 155


state 176

    (133) normal -> NORMAL PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 218


state 177

    (128) param_dist -> variable .
    (129) param_dist -> variable . COLON param_dist

    PARENCLOSE      reduce using rule 128 (param_dist -> variable .)
    COLON           shift and go to state 219


state 178

    (132) uniforme -> UNIFORME PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 220


state 179

    (131) poisson -> POISSON PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 221


state 180

    (130) binomial -> BINOMIAL PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 222


state 181

    (56) dec_variabless -> type guardarTipo dec_mvar . SEMICOLON dec_variabless
    (57) dec_variabless -> type guardarTipo dec_mvar . SEMICOLON

    SEMICOLON       shift and go to state 223


state 182

    (58) dec_mvar -> ID . COLON dec_mvar
    (59) dec_mvar -> ID . BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (60) dec_mvar -> ID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (61) dec_mvar -> ID .
    (62) dec_mvar -> ID . BRACEOPEN CTEINT BRACECLOSE
    (63) dec_mvar -> ID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 224
    BRACEOPEN       shift and go to state 225
    SEMICOLON       reduce using rule 61 (dec_mvar -> ID .)


state 183

    (21) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .

    FUNCTION        reduce using rule 21 (dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .)
    MAIN            reduce using rule 21 (dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .)


state 184

    (24) exitFunc -> empty .

    FUNCTION        reduce using rule 24 (exitFunc -> empty .)
    MAIN            reduce using rule 24 (exitFunc -> empty .)


state 185

    (26) param -> typeParam ID COLON param .

    PARENCLOSE      reduce using rule 26 (param -> typeParam ID COLON param .)


state 186

    (22) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .

    FUNCTION        reduce using rule 22 (dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .)
    MAIN            reduce using rule 22 (dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param PARENCLOSE body exitFunc .)


state 187

    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE . COLON mvar
    (20) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .

    COLON           shift and go to state 226
    SEMICOLON       reduce using rule 20 (mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .)


state 188

    (64) assignment -> variableAssignment EQUAL exp SEMICOLON .

    IF              reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    PRINT           reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    READ            reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    ID              reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    PLOT            reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    RETURN          reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    WHILE           reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    FOR             reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    MAX             reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    MIN             reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    SUM             reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    NORMAL          reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    UNIFORME        reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    POISSON         reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    BINOMIAL        reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    INT             reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    FLOAT           reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    CHAR            reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    BRACKETCLOSE    reduce using rule 64 (assignment -> variableAssignment EQUAL exp SEMICOLON .)


state 189

    (102) condition -> IF PARENOPEN exp PARENCLOSE . cuadruploIF body ifEnd
    (103) condition -> IF PARENOPEN exp PARENCLOSE . cuadruploIF body cuadruploElse ELSE body ifEndElse
    (104) cuadruploIF -> . empty
    (134) empty -> .

    BRACKETOPEN     reduce using rule 134 (empty -> .)

    cuadruploIF                    shift and go to state 227
    empty                          shift and go to state 228

state 190

    (108) writing -> PRINT PARENOPEN writingg PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 229


state 191

    (110) writingg -> exp COLON . writingg
    (109) writingg -> . exp
    (110) writingg -> . exp COLON writingg
    (111) writingg -> . auxString
    (112) writingg -> . auxString COLON writingg
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (113) auxString -> . CTESTRING
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 146
    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 144
    writingg                       shift and go to state 230
    auxString                      shift and go to state 145
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 192

    (112) writingg -> auxString COLON . writingg
    (109) writingg -> . exp
    (110) writingg -> . exp COLON writingg
    (111) writingg -> . auxString
    (112) writingg -> . auxString COLON writingg
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (113) auxString -> . CTESTRING
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 146
    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    auxString                      shift and go to state 145
    writingg                       shift and go to state 231
    exp                            shift and go to state 144
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 193

    (116) multivariables -> variable COLON multivariables .

    SEMICOLON       reduce using rule 116 (multivariables -> variable COLON multivariables .)


state 194

    (97) variable -> ID BRACEOPEN exp . BRACECLOSE
    (98) variable -> ID BRACEOPEN exp . BRACECLOSE BRACEOPEN exp BRACECLOSE
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp

    BRACECLOSE      shift and go to state 232
    AND             shift and go to state 154
    OR              shift and go to state 155


state 195

    (65) call_func -> ID generarERA PARENOPEN call_funcc . PARENCLOSE

    PARENCLOSE      shift and go to state 233


state 196

    (67) call_funcc -> exp . mandarParam
    (68) call_funcc -> exp . mandarParam COLON call_funcc
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp
    (70) mandarParam -> . empty
    (134) empty -> .

    AND             shift and go to state 154
    OR              shift and go to state 155
    COLON           reduce using rule 134 (empty -> .)
    PARENCLOSE      reduce using rule 134 (empty -> .)

    mandarParam                    shift and go to state 234
    empty                          shift and go to state 235

state 197

    (69) call_funcc -> empty .

    PARENCLOSE      reduce using rule 69 (call_funcc -> empty .)


state 198

    (100) variableAssignment -> ID BRACEOPEN exp BRACECLOSE .
    (101) variableAssignment -> ID BRACEOPEN exp BRACECLOSE . BRACEOPEN exp BRACECLOSE

    EQUAL           reduce using rule 100 (variableAssignment -> ID BRACEOPEN exp BRACECLOSE .)
    BRACEOPEN       shift and go to state 236


state 199

    (71) graph -> PLOT PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 237


state 200

    (73) exp -> exp AND expp .
    (76) expp -> expp . GREATHERTHAN m_exp
    (77) expp -> expp . LESSTHAN m_exp
    (78) expp -> expp . GREATHEREQUAL m_exp
    (79) expp -> expp . LESSEQUAL m_exp
    (80) expp -> expp . DIFFERENT m_exp
    (81) expp -> expp . SAME m_exp

    SEMICOLON       reduce using rule 73 (exp -> exp AND expp .)
    AND             reduce using rule 73 (exp -> exp AND expp .)
    OR              reduce using rule 73 (exp -> exp AND expp .)
    PARENCLOSE      reduce using rule 73 (exp -> exp AND expp .)
    COLON           reduce using rule 73 (exp -> exp AND expp .)
    BRACECLOSE      reduce using rule 73 (exp -> exp AND expp .)
    TO              reduce using rule 73 (exp -> exp AND expp .)
    GREATHERTHAN    shift and go to state 156
    LESSTHAN        shift and go to state 157
    GREATHEREQUAL   shift and go to state 158
    LESSEQUAL       shift and go to state 159
    DIFFERENT       shift and go to state 160
    SAME            shift and go to state 161


state 201

    (74) exp -> exp OR expp .
    (76) expp -> expp . GREATHERTHAN m_exp
    (77) expp -> expp . LESSTHAN m_exp
    (78) expp -> expp . GREATHEREQUAL m_exp
    (79) expp -> expp . LESSEQUAL m_exp
    (80) expp -> expp . DIFFERENT m_exp
    (81) expp -> expp . SAME m_exp

    SEMICOLON       reduce using rule 74 (exp -> exp OR expp .)
    AND             reduce using rule 74 (exp -> exp OR expp .)
    OR              reduce using rule 74 (exp -> exp OR expp .)
    PARENCLOSE      reduce using rule 74 (exp -> exp OR expp .)
    COLON           reduce using rule 74 (exp -> exp OR expp .)
    BRACECLOSE      reduce using rule 74 (exp -> exp OR expp .)
    TO              reduce using rule 74 (exp -> exp OR expp .)
    GREATHERTHAN    shift and go to state 156
    LESSTHAN        shift and go to state 157
    GREATHEREQUAL   shift and go to state 158
    LESSEQUAL       shift and go to state 159
    DIFFERENT       shift and go to state 160
    SAME            shift and go to state 161


state 202

    (76) expp -> expp GREATHERTHAN m_exp .
    (83) m_exp -> m_exp . PLUS termino
    (84) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 76 (expp -> expp GREATHERTHAN m_exp .)
    LESSTHAN        reduce using rule 76 (expp -> expp GREATHERTHAN m_exp .)
    GREATHEREQUAL   reduce using rule 76 (expp -> expp GREATHERTHAN m_exp .)
    LESSEQUAL       reduce using rule 76 (expp -> expp GREATHERTHAN m_exp .)
    DIFFERENT       reduce using rule 76 (expp -> expp GREATHERTHAN m_exp .)
    SAME            reduce using rule 76 (expp -> expp GREATHERTHAN m_exp .)
    SEMICOLON       reduce using rule 76 (expp -> expp GREATHERTHAN m_exp .)
    AND             reduce using rule 76 (expp -> expp GREATHERTHAN m_exp .)
    OR              reduce using rule 76 (expp -> expp GREATHERTHAN m_exp .)
    PARENCLOSE      reduce using rule 76 (expp -> expp GREATHERTHAN m_exp .)
    COLON           reduce using rule 76 (expp -> expp GREATHERTHAN m_exp .)
    BRACECLOSE      reduce using rule 76 (expp -> expp GREATHERTHAN m_exp .)
    TO              reduce using rule 76 (expp -> expp GREATHERTHAN m_exp .)
    PLUS            shift and go to state 162
    MINUS           shift and go to state 163


state 203

    (77) expp -> expp LESSTHAN m_exp .
    (83) m_exp -> m_exp . PLUS termino
    (84) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 77 (expp -> expp LESSTHAN m_exp .)
    LESSTHAN        reduce using rule 77 (expp -> expp LESSTHAN m_exp .)
    GREATHEREQUAL   reduce using rule 77 (expp -> expp LESSTHAN m_exp .)
    LESSEQUAL       reduce using rule 77 (expp -> expp LESSTHAN m_exp .)
    DIFFERENT       reduce using rule 77 (expp -> expp LESSTHAN m_exp .)
    SAME            reduce using rule 77 (expp -> expp LESSTHAN m_exp .)
    SEMICOLON       reduce using rule 77 (expp -> expp LESSTHAN m_exp .)
    AND             reduce using rule 77 (expp -> expp LESSTHAN m_exp .)
    OR              reduce using rule 77 (expp -> expp LESSTHAN m_exp .)
    PARENCLOSE      reduce using rule 77 (expp -> expp LESSTHAN m_exp .)
    COLON           reduce using rule 77 (expp -> expp LESSTHAN m_exp .)
    BRACECLOSE      reduce using rule 77 (expp -> expp LESSTHAN m_exp .)
    TO              reduce using rule 77 (expp -> expp LESSTHAN m_exp .)
    PLUS            shift and go to state 162
    MINUS           shift and go to state 163


state 204

    (78) expp -> expp GREATHEREQUAL m_exp .
    (83) m_exp -> m_exp . PLUS termino
    (84) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 78 (expp -> expp GREATHEREQUAL m_exp .)
    LESSTHAN        reduce using rule 78 (expp -> expp GREATHEREQUAL m_exp .)
    GREATHEREQUAL   reduce using rule 78 (expp -> expp GREATHEREQUAL m_exp .)
    LESSEQUAL       reduce using rule 78 (expp -> expp GREATHEREQUAL m_exp .)
    DIFFERENT       reduce using rule 78 (expp -> expp GREATHEREQUAL m_exp .)
    SAME            reduce using rule 78 (expp -> expp GREATHEREQUAL m_exp .)
    SEMICOLON       reduce using rule 78 (expp -> expp GREATHEREQUAL m_exp .)
    AND             reduce using rule 78 (expp -> expp GREATHEREQUAL m_exp .)
    OR              reduce using rule 78 (expp -> expp GREATHEREQUAL m_exp .)
    PARENCLOSE      reduce using rule 78 (expp -> expp GREATHEREQUAL m_exp .)
    COLON           reduce using rule 78 (expp -> expp GREATHEREQUAL m_exp .)
    BRACECLOSE      reduce using rule 78 (expp -> expp GREATHEREQUAL m_exp .)
    TO              reduce using rule 78 (expp -> expp GREATHEREQUAL m_exp .)
    PLUS            shift and go to state 162
    MINUS           shift and go to state 163


state 205

    (79) expp -> expp LESSEQUAL m_exp .
    (83) m_exp -> m_exp . PLUS termino
    (84) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 79 (expp -> expp LESSEQUAL m_exp .)
    LESSTHAN        reduce using rule 79 (expp -> expp LESSEQUAL m_exp .)
    GREATHEREQUAL   reduce using rule 79 (expp -> expp LESSEQUAL m_exp .)
    LESSEQUAL       reduce using rule 79 (expp -> expp LESSEQUAL m_exp .)
    DIFFERENT       reduce using rule 79 (expp -> expp LESSEQUAL m_exp .)
    SAME            reduce using rule 79 (expp -> expp LESSEQUAL m_exp .)
    SEMICOLON       reduce using rule 79 (expp -> expp LESSEQUAL m_exp .)
    AND             reduce using rule 79 (expp -> expp LESSEQUAL m_exp .)
    OR              reduce using rule 79 (expp -> expp LESSEQUAL m_exp .)
    PARENCLOSE      reduce using rule 79 (expp -> expp LESSEQUAL m_exp .)
    COLON           reduce using rule 79 (expp -> expp LESSEQUAL m_exp .)
    BRACECLOSE      reduce using rule 79 (expp -> expp LESSEQUAL m_exp .)
    TO              reduce using rule 79 (expp -> expp LESSEQUAL m_exp .)
    PLUS            shift and go to state 162
    MINUS           shift and go to state 163


state 206

    (80) expp -> expp DIFFERENT m_exp .
    (83) m_exp -> m_exp . PLUS termino
    (84) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 80 (expp -> expp DIFFERENT m_exp .)
    LESSTHAN        reduce using rule 80 (expp -> expp DIFFERENT m_exp .)
    GREATHEREQUAL   reduce using rule 80 (expp -> expp DIFFERENT m_exp .)
    LESSEQUAL       reduce using rule 80 (expp -> expp DIFFERENT m_exp .)
    DIFFERENT       reduce using rule 80 (expp -> expp DIFFERENT m_exp .)
    SAME            reduce using rule 80 (expp -> expp DIFFERENT m_exp .)
    SEMICOLON       reduce using rule 80 (expp -> expp DIFFERENT m_exp .)
    AND             reduce using rule 80 (expp -> expp DIFFERENT m_exp .)
    OR              reduce using rule 80 (expp -> expp DIFFERENT m_exp .)
    PARENCLOSE      reduce using rule 80 (expp -> expp DIFFERENT m_exp .)
    COLON           reduce using rule 80 (expp -> expp DIFFERENT m_exp .)
    BRACECLOSE      reduce using rule 80 (expp -> expp DIFFERENT m_exp .)
    TO              reduce using rule 80 (expp -> expp DIFFERENT m_exp .)
    PLUS            shift and go to state 162
    MINUS           shift and go to state 163


state 207

    (81) expp -> expp SAME m_exp .
    (83) m_exp -> m_exp . PLUS termino
    (84) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 81 (expp -> expp SAME m_exp .)
    LESSTHAN        reduce using rule 81 (expp -> expp SAME m_exp .)
    GREATHEREQUAL   reduce using rule 81 (expp -> expp SAME m_exp .)
    LESSEQUAL       reduce using rule 81 (expp -> expp SAME m_exp .)
    DIFFERENT       reduce using rule 81 (expp -> expp SAME m_exp .)
    SAME            reduce using rule 81 (expp -> expp SAME m_exp .)
    SEMICOLON       reduce using rule 81 (expp -> expp SAME m_exp .)
    AND             reduce using rule 81 (expp -> expp SAME m_exp .)
    OR              reduce using rule 81 (expp -> expp SAME m_exp .)
    PARENCLOSE      reduce using rule 81 (expp -> expp SAME m_exp .)
    COLON           reduce using rule 81 (expp -> expp SAME m_exp .)
    BRACECLOSE      reduce using rule 81 (expp -> expp SAME m_exp .)
    TO              reduce using rule 81 (expp -> expp SAME m_exp .)
    PLUS            shift and go to state 162
    MINUS           shift and go to state 163


state 208

    (83) m_exp -> m_exp PLUS termino .
    (86) termino -> termino . MULTIPLY factor
    (87) termino -> termino . DIVIDE factor

    PLUS            reduce using rule 83 (m_exp -> m_exp PLUS termino .)
    MINUS           reduce using rule 83 (m_exp -> m_exp PLUS termino .)
    GREATHERTHAN    reduce using rule 83 (m_exp -> m_exp PLUS termino .)
    LESSTHAN        reduce using rule 83 (m_exp -> m_exp PLUS termino .)
    GREATHEREQUAL   reduce using rule 83 (m_exp -> m_exp PLUS termino .)
    LESSEQUAL       reduce using rule 83 (m_exp -> m_exp PLUS termino .)
    DIFFERENT       reduce using rule 83 (m_exp -> m_exp PLUS termino .)
    SAME            reduce using rule 83 (m_exp -> m_exp PLUS termino .)
    SEMICOLON       reduce using rule 83 (m_exp -> m_exp PLUS termino .)
    AND             reduce using rule 83 (m_exp -> m_exp PLUS termino .)
    OR              reduce using rule 83 (m_exp -> m_exp PLUS termino .)
    PARENCLOSE      reduce using rule 83 (m_exp -> m_exp PLUS termino .)
    COLON           reduce using rule 83 (m_exp -> m_exp PLUS termino .)
    BRACECLOSE      reduce using rule 83 (m_exp -> m_exp PLUS termino .)
    TO              reduce using rule 83 (m_exp -> m_exp PLUS termino .)
    MULTIPLY        shift and go to state 164
    DIVIDE          shift and go to state 165


state 209

    (84) m_exp -> m_exp MINUS termino .
    (86) termino -> termino . MULTIPLY factor
    (87) termino -> termino . DIVIDE factor

    PLUS            reduce using rule 84 (m_exp -> m_exp MINUS termino .)
    MINUS           reduce using rule 84 (m_exp -> m_exp MINUS termino .)
    GREATHERTHAN    reduce using rule 84 (m_exp -> m_exp MINUS termino .)
    LESSTHAN        reduce using rule 84 (m_exp -> m_exp MINUS termino .)
    GREATHEREQUAL   reduce using rule 84 (m_exp -> m_exp MINUS termino .)
    LESSEQUAL       reduce using rule 84 (m_exp -> m_exp MINUS termino .)
    DIFFERENT       reduce using rule 84 (m_exp -> m_exp MINUS termino .)
    SAME            reduce using rule 84 (m_exp -> m_exp MINUS termino .)
    SEMICOLON       reduce using rule 84 (m_exp -> m_exp MINUS termino .)
    AND             reduce using rule 84 (m_exp -> m_exp MINUS termino .)
    OR              reduce using rule 84 (m_exp -> m_exp MINUS termino .)
    PARENCLOSE      reduce using rule 84 (m_exp -> m_exp MINUS termino .)
    COLON           reduce using rule 84 (m_exp -> m_exp MINUS termino .)
    BRACECLOSE      reduce using rule 84 (m_exp -> m_exp MINUS termino .)
    TO              reduce using rule 84 (m_exp -> m_exp MINUS termino .)
    MULTIPLY        shift and go to state 164
    DIVIDE          shift and go to state 165


state 210

    (86) termino -> termino MULTIPLY factor .

    MULTIPLY        reduce using rule 86 (termino -> termino MULTIPLY factor .)
    DIVIDE          reduce using rule 86 (termino -> termino MULTIPLY factor .)
    PLUS            reduce using rule 86 (termino -> termino MULTIPLY factor .)
    MINUS           reduce using rule 86 (termino -> termino MULTIPLY factor .)
    GREATHERTHAN    reduce using rule 86 (termino -> termino MULTIPLY factor .)
    LESSTHAN        reduce using rule 86 (termino -> termino MULTIPLY factor .)
    GREATHEREQUAL   reduce using rule 86 (termino -> termino MULTIPLY factor .)
    LESSEQUAL       reduce using rule 86 (termino -> termino MULTIPLY factor .)
    DIFFERENT       reduce using rule 86 (termino -> termino MULTIPLY factor .)
    SAME            reduce using rule 86 (termino -> termino MULTIPLY factor .)
    SEMICOLON       reduce using rule 86 (termino -> termino MULTIPLY factor .)
    AND             reduce using rule 86 (termino -> termino MULTIPLY factor .)
    OR              reduce using rule 86 (termino -> termino MULTIPLY factor .)
    PARENCLOSE      reduce using rule 86 (termino -> termino MULTIPLY factor .)
    COLON           reduce using rule 86 (termino -> termino MULTIPLY factor .)
    BRACECLOSE      reduce using rule 86 (termino -> termino MULTIPLY factor .)
    TO              reduce using rule 86 (termino -> termino MULTIPLY factor .)


state 211

    (87) termino -> termino DIVIDE factor .

    MULTIPLY        reduce using rule 87 (termino -> termino DIVIDE factor .)
    DIVIDE          reduce using rule 87 (termino -> termino DIVIDE factor .)
    PLUS            reduce using rule 87 (termino -> termino DIVIDE factor .)
    MINUS           reduce using rule 87 (termino -> termino DIVIDE factor .)
    GREATHERTHAN    reduce using rule 87 (termino -> termino DIVIDE factor .)
    LESSTHAN        reduce using rule 87 (termino -> termino DIVIDE factor .)
    GREATHEREQUAL   reduce using rule 87 (termino -> termino DIVIDE factor .)
    LESSEQUAL       reduce using rule 87 (termino -> termino DIVIDE factor .)
    DIFFERENT       reduce using rule 87 (termino -> termino DIVIDE factor .)
    SAME            reduce using rule 87 (termino -> termino DIVIDE factor .)
    SEMICOLON       reduce using rule 87 (termino -> termino DIVIDE factor .)
    AND             reduce using rule 87 (termino -> termino DIVIDE factor .)
    OR              reduce using rule 87 (termino -> termino DIVIDE factor .)
    PARENCLOSE      reduce using rule 87 (termino -> termino DIVIDE factor .)
    COLON           reduce using rule 87 (termino -> termino DIVIDE factor .)
    BRACECLOSE      reduce using rule 87 (termino -> termino DIVIDE factor .)
    TO              reduce using rule 87 (termino -> termino DIVIDE factor .)


state 212

    (93) factor -> PARENOPEN exp PARENCLOSE .

    MULTIPLY        reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)
    DIVIDE          reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)
    PLUS            reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)
    MINUS           reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)
    GREATHERTHAN    reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)
    LESSTHAN        reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)
    GREATHEREQUAL   reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)
    LESSEQUAL       reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)
    DIFFERENT       reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)
    SAME            reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)
    SEMICOLON       reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)
    AND             reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)
    OR              reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)
    PARENCLOSE      reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)
    COLON           reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)
    BRACECLOSE      reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)
    TO              reduce using rule 93 (factor -> PARENOPEN exp PARENCLOSE .)


state 213

    (117) while_loop -> WHILE whileMigaja PARENOPEN exp . PARENCLOSE whileEval body whileEnd
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 238
    AND             shift and go to state 154
    OR              shift and go to state 155


state 214

    (121) for_loop -> FOR PARENOPEN ID EQUAL . exp guardarValorFor TO exp PARENCLOSE body forEnd
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 239
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 215

    (125) max -> MAX PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 240


state 216

    (126) min -> MIN PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 241


state 217

    (127) sum -> SUM PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 242


state 218

    (133) normal -> NORMAL PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 243


state 219

    (129) param_dist -> variable COLON . param_dist
    (128) param_dist -> . variable
    (129) param_dist -> . variable COLON param_dist
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 109

    variable                       shift and go to state 177
    param_dist                     shift and go to state 244

state 220

    (132) uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 245


state 221

    (131) poisson -> POISSON PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 246


state 222

    (130) binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 247


state 223

    (56) dec_variabless -> type guardarTipo dec_mvar SEMICOLON . dec_variabless
    (57) dec_variabless -> type guardarTipo dec_mvar SEMICOLON .
    (56) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON dec_variabless
    (57) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON
    (31) type -> . INT
    (32) type -> . FLOAT
    (33) type -> . CHAR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    IF              reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    PRINT           reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    READ            reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    ID              reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    PLOT            reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    RETURN          reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    WHILE           reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    FOR             reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    MAX             reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    MIN             reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    SUM             reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    NORMAL          reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    UNIFORME        reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    POISSON         reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    BINOMIAL        reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    BRACKETCLOSE    reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

  ! INT             [ reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .) ]
  ! CHAR            [ reduce using rule 57 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .) ]

    type                           shift and go to state 96
    dec_variabless                 shift and go to state 248

state 224

    (58) dec_mvar -> ID COLON . dec_mvar
    (58) dec_mvar -> . ID COLON dec_mvar
    (59) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (60) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (61) dec_mvar -> . ID
    (62) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (63) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 182

    dec_mvar                       shift and go to state 249

state 225

    (59) dec_mvar -> ID BRACEOPEN . CTEINT BRACECLOSE COLON dec_mvar
    (60) dec_mvar -> ID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (62) dec_mvar -> ID BRACEOPEN . CTEINT BRACECLOSE
    (63) dec_mvar -> ID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    CTEINT          shift and go to state 250


state 226

    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON . mvar
    (15) mvar -> . ID COLON mvar
    (16) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> . ID
    (19) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (20) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 34

    mvar                           shift and go to state 251

state 227

    (102) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF . body ifEnd
    (103) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF . body cuadruploElse ELSE body ifEndElse
    (34) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 252

state 228

    (104) cuadruploIF -> empty .

    BRACKETOPEN     reduce using rule 104 (cuadruploIF -> empty .)


state 229

    (108) writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .

    IF              reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    READ            reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    ID              reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    INT             reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 108 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)


state 230

    (110) writingg -> exp COLON writingg .

    PARENCLOSE      reduce using rule 110 (writingg -> exp COLON writingg .)


state 231

    (112) writingg -> auxString COLON writingg .

    PARENCLOSE      reduce using rule 112 (writingg -> auxString COLON writingg .)


state 232

    (97) variable -> ID BRACEOPEN exp BRACECLOSE .
    (98) variable -> ID BRACEOPEN exp BRACECLOSE . BRACEOPEN exp BRACECLOSE

    COLON           reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    SEMICOLON       reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    MULTIPLY        reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    DIVIDE          reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    PLUS            reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    MINUS           reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    GREATHERTHAN    reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    LESSTHAN        reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    GREATHEREQUAL   reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    LESSEQUAL       reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    DIFFERENT       reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    SAME            reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    AND             reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    OR              reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    PARENCLOSE      reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    BRACECLOSE      reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    TO              reduce using rule 97 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    BRACEOPEN       shift and go to state 253


state 233

    (65) call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .

    IF              reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    PRINT           reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    READ            reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    ID              reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    PLOT            reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    RETURN          reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    WHILE           reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    FOR             reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    MAX             reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    MIN             reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    SUM             reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    NORMAL          reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    UNIFORME        reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    POISSON         reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    BINOMIAL        reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    INT             reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    FLOAT           reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    CHAR            reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    BRACKETCLOSE    reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    MULTIPLY        reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    DIVIDE          reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    PLUS            reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    MINUS           reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    GREATHERTHAN    reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    LESSTHAN        reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    GREATHEREQUAL   reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    LESSEQUAL       reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    DIFFERENT       reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    SAME            reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    SEMICOLON       reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    AND             reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    OR              reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    PARENCLOSE      reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    COLON           reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    BRACECLOSE      reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    TO              reduce using rule 65 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)


state 234

    (67) call_funcc -> exp mandarParam .
    (68) call_funcc -> exp mandarParam . COLON call_funcc

    PARENCLOSE      reduce using rule 67 (call_funcc -> exp mandarParam .)
    COLON           shift and go to state 254


state 235

    (70) mandarParam -> empty .

    COLON           reduce using rule 70 (mandarParam -> empty .)
    PARENCLOSE      reduce using rule 70 (mandarParam -> empty .)


state 236

    (101) variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN . exp BRACECLOSE
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 255
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 237

    (71) graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 71 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)


state 238

    (117) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE . whileEval body whileEnd
    (119) whileEval -> . empty
    (134) empty -> .

    BRACKETOPEN     reduce using rule 134 (empty -> .)

    whileEval                      shift and go to state 256
    empty                          shift and go to state 257

state 239

    (121) for_loop -> FOR PARENOPEN ID EQUAL exp . guardarValorFor TO exp PARENCLOSE body forEnd
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp
    (122) guardarValorFor -> . empty
    (134) empty -> .

    AND             shift and go to state 154
    OR              shift and go to state 155
    TO              reduce using rule 134 (empty -> .)

    guardarValorFor                shift and go to state 258
    empty                          shift and go to state 259

state 240

    (125) max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 125 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)


state 241

    (126) min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 126 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)


state 242

    (127) sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 127 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)


state 243

    (133) normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 133 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 244

    (129) param_dist -> variable COLON param_dist .

    PARENCLOSE      reduce using rule 129 (param_dist -> variable COLON param_dist .)


state 245

    (132) uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 132 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 246

    (131) poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 131 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 247

    (130) binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 130 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 248

    (56) dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .

    IF              reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    PRINT           reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    READ            reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    ID              reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    PLOT            reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    RETURN          reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    WHILE           reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    FOR             reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    MAX             reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    MIN             reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    SUM             reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    NORMAL          reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    UNIFORME        reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    POISSON         reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    BINOMIAL        reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    INT             reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    FLOAT           reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    CHAR            reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    BRACKETCLOSE    reduce using rule 56 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)


state 249

    (58) dec_mvar -> ID COLON dec_mvar .

    SEMICOLON       reduce using rule 58 (dec_mvar -> ID COLON dec_mvar .)


state 250

    (59) dec_mvar -> ID BRACEOPEN CTEINT . BRACECLOSE COLON dec_mvar
    (60) dec_mvar -> ID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (62) dec_mvar -> ID BRACEOPEN CTEINT . BRACECLOSE
    (63) dec_mvar -> ID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    BRACECLOSE      shift and go to state 260


state 251

    (17) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar .

    SEMICOLON       reduce using rule 17 (mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar .)


state 252

    (102) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body . ifEnd
    (103) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body . cuadruploElse ELSE body ifEndElse
    (105) ifEnd -> . empty
    (106) cuadruploElse -> . empty
    (134) empty -> .

    IF              reduce using rule 134 (empty -> .)
    PRINT           reduce using rule 134 (empty -> .)
    READ            reduce using rule 134 (empty -> .)
    ID              reduce using rule 134 (empty -> .)
    PLOT            reduce using rule 134 (empty -> .)
    RETURN          reduce using rule 134 (empty -> .)
    WHILE           reduce using rule 134 (empty -> .)
    FOR             reduce using rule 134 (empty -> .)
    MAX             reduce using rule 134 (empty -> .)
    MIN             reduce using rule 134 (empty -> .)
    SUM             reduce using rule 134 (empty -> .)
    NORMAL          reduce using rule 134 (empty -> .)
    UNIFORME        reduce using rule 134 (empty -> .)
    POISSON         reduce using rule 134 (empty -> .)
    BINOMIAL        reduce using rule 134 (empty -> .)
    INT             reduce using rule 134 (empty -> .)
    FLOAT           reduce using rule 134 (empty -> .)
    CHAR            reduce using rule 134 (empty -> .)
    BRACKETCLOSE    reduce using rule 134 (empty -> .)
    ELSE            reduce using rule 134 (empty -> .)

    ifEnd                          shift and go to state 261
    cuadruploElse                  shift and go to state 262
    empty                          shift and go to state 263

state 253

    (98) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN . exp BRACECLOSE
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 264
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 254

    (68) call_funcc -> exp mandarParam COLON . call_funcc
    (67) call_funcc -> . exp mandarParam
    (68) call_funcc -> . exp mandarParam COLON call_funcc
    (69) call_funcc -> . empty
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (134) empty -> .
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    PARENCLOSE      reduce using rule 134 (empty -> .)
    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 196
    call_funcc                     shift and go to state 265
    empty                          shift and go to state 197
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 255

    (101) variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp . BRACECLOSE
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp

    BRACECLOSE      shift and go to state 266
    AND             shift and go to state 154
    OR              shift and go to state 155


state 256

    (117) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval . body whileEnd
    (34) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 267

state 257

    (119) whileEval -> empty .

    BRACKETOPEN     reduce using rule 119 (whileEval -> empty .)


state 258

    (121) for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor . TO exp PARENCLOSE body forEnd

    TO              shift and go to state 268


state 259

    (122) guardarValorFor -> empty .

    TO              reduce using rule 122 (guardarValorFor -> empty .)


state 260

    (59) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE . COLON dec_mvar
    (60) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (62) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE .
    (63) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 270
    BRACEOPEN       shift and go to state 269
    SEMICOLON       reduce using rule 62 (dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE .)


state 261

    (102) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .

    IF              reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    PRINT           reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    READ            reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    ID              reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    PLOT            reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    RETURN          reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    WHILE           reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    FOR             reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    MAX             reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    MIN             reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    SUM             reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    NORMAL          reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    UNIFORME        reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    POISSON         reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    BINOMIAL        reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    INT             reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    FLOAT           reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    CHAR            reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    BRACKETCLOSE    reduce using rule 102 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)


state 262

    (103) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse . ELSE body ifEndElse

    ELSE            shift and go to state 271


state 263

    (105) ifEnd -> empty .
    (106) cuadruploElse -> empty .

    IF              reduce using rule 105 (ifEnd -> empty .)
    PRINT           reduce using rule 105 (ifEnd -> empty .)
    READ            reduce using rule 105 (ifEnd -> empty .)
    ID              reduce using rule 105 (ifEnd -> empty .)
    PLOT            reduce using rule 105 (ifEnd -> empty .)
    RETURN          reduce using rule 105 (ifEnd -> empty .)
    WHILE           reduce using rule 105 (ifEnd -> empty .)
    FOR             reduce using rule 105 (ifEnd -> empty .)
    MAX             reduce using rule 105 (ifEnd -> empty .)
    MIN             reduce using rule 105 (ifEnd -> empty .)
    SUM             reduce using rule 105 (ifEnd -> empty .)
    NORMAL          reduce using rule 105 (ifEnd -> empty .)
    UNIFORME        reduce using rule 105 (ifEnd -> empty .)
    POISSON         reduce using rule 105 (ifEnd -> empty .)
    BINOMIAL        reduce using rule 105 (ifEnd -> empty .)
    INT             reduce using rule 105 (ifEnd -> empty .)
    FLOAT           reduce using rule 105 (ifEnd -> empty .)
    CHAR            reduce using rule 105 (ifEnd -> empty .)
    BRACKETCLOSE    reduce using rule 105 (ifEnd -> empty .)
    ELSE            reduce using rule 106 (cuadruploElse -> empty .)


state 264

    (98) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp . BRACECLOSE
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp

    BRACECLOSE      shift and go to state 272
    AND             shift and go to state 154
    OR              shift and go to state 155


state 265

    (68) call_funcc -> exp mandarParam COLON call_funcc .

    PARENCLOSE      reduce using rule 68 (call_funcc -> exp mandarParam COLON call_funcc .)


state 266

    (101) variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .

    EQUAL           reduce using rule 101 (variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)


state 267

    (117) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body . whileEnd
    (120) whileEnd -> . empty
    (134) empty -> .

    IF              reduce using rule 134 (empty -> .)
    PRINT           reduce using rule 134 (empty -> .)
    READ            reduce using rule 134 (empty -> .)
    ID              reduce using rule 134 (empty -> .)
    PLOT            reduce using rule 134 (empty -> .)
    RETURN          reduce using rule 134 (empty -> .)
    WHILE           reduce using rule 134 (empty -> .)
    FOR             reduce using rule 134 (empty -> .)
    MAX             reduce using rule 134 (empty -> .)
    MIN             reduce using rule 134 (empty -> .)
    SUM             reduce using rule 134 (empty -> .)
    NORMAL          reduce using rule 134 (empty -> .)
    UNIFORME        reduce using rule 134 (empty -> .)
    POISSON         reduce using rule 134 (empty -> .)
    BINOMIAL        reduce using rule 134 (empty -> .)
    INT             reduce using rule 134 (empty -> .)
    FLOAT           reduce using rule 134 (empty -> .)
    CHAR            reduce using rule 134 (empty -> .)
    BRACKETCLOSE    reduce using rule 134 (empty -> .)

    whileEnd                       shift and go to state 273
    empty                          shift and go to state 274

state 268

    (121) for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO . exp PARENCLOSE body forEnd
    (72) exp -> . expp
    (73) exp -> . exp AND expp
    (74) exp -> . exp OR expp
    (75) expp -> . m_exp
    (76) expp -> . expp GREATHERTHAN m_exp
    (77) expp -> . expp LESSTHAN m_exp
    (78) expp -> . expp GREATHEREQUAL m_exp
    (79) expp -> . expp LESSEQUAL m_exp
    (80) expp -> . expp DIFFERENT m_exp
    (81) expp -> . expp SAME m_exp
    (82) m_exp -> . termino
    (83) m_exp -> . m_exp PLUS termino
    (84) m_exp -> . m_exp MINUS termino
    (85) termino -> . factor
    (86) termino -> . termino MULTIPLY factor
    (87) termino -> . termino DIVIDE factor
    (88) factor -> . ID
    (89) factor -> . CTEINT guardarConstanteInt
    (90) factor -> . CTFLOAT guardarConstanteFloat
    (91) factor -> . variable
    (92) factor -> . call_func
    (93) factor -> . PARENOPEN exp PARENCLOSE
    (96) variable -> . ID
    (97) variable -> . ID BRACEOPEN exp BRACECLOSE
    (98) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (65) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 119
    CTEINT          shift and go to state 120
    CTFLOAT         shift and go to state 121
    PARENOPEN       shift and go to state 124

    exp                            shift and go to state 275
    expp                           shift and go to state 115
    m_exp                          shift and go to state 116
    termino                        shift and go to state 117
    factor                         shift and go to state 118
    variable                       shift and go to state 122
    call_func                      shift and go to state 123

state 269

    (60) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE COLON dec_mvar
    (63) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE

    CTEINT          shift and go to state 276


state 270

    (59) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON . dec_mvar
    (58) dec_mvar -> . ID COLON dec_mvar
    (59) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (60) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (61) dec_mvar -> . ID
    (62) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (63) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 182

    dec_mvar                       shift and go to state 277

state 271

    (103) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE . body ifEndElse
    (34) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 278

state 272

    (98) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .

    COLON           reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    SEMICOLON       reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    MULTIPLY        reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    DIVIDE          reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    PLUS            reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    MINUS           reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    GREATHERTHAN    reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    LESSTHAN        reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    GREATHEREQUAL   reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    LESSEQUAL       reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    DIFFERENT       reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    SAME            reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    AND             reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    OR              reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    PARENCLOSE      reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    BRACECLOSE      reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    TO              reduce using rule 98 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)


state 273

    (117) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .

    IF              reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    PRINT           reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    READ            reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    ID              reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    PLOT            reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    RETURN          reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    WHILE           reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    FOR             reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    MAX             reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    MIN             reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    SUM             reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    NORMAL          reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    UNIFORME        reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    POISSON         reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    BINOMIAL        reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    INT             reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    FLOAT           reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    CHAR            reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    BRACKETCLOSE    reduce using rule 117 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)


state 274

    (120) whileEnd -> empty .

    IF              reduce using rule 120 (whileEnd -> empty .)
    PRINT           reduce using rule 120 (whileEnd -> empty .)
    READ            reduce using rule 120 (whileEnd -> empty .)
    ID              reduce using rule 120 (whileEnd -> empty .)
    PLOT            reduce using rule 120 (whileEnd -> empty .)
    RETURN          reduce using rule 120 (whileEnd -> empty .)
    WHILE           reduce using rule 120 (whileEnd -> empty .)
    FOR             reduce using rule 120 (whileEnd -> empty .)
    MAX             reduce using rule 120 (whileEnd -> empty .)
    MIN             reduce using rule 120 (whileEnd -> empty .)
    SUM             reduce using rule 120 (whileEnd -> empty .)
    NORMAL          reduce using rule 120 (whileEnd -> empty .)
    UNIFORME        reduce using rule 120 (whileEnd -> empty .)
    POISSON         reduce using rule 120 (whileEnd -> empty .)
    BINOMIAL        reduce using rule 120 (whileEnd -> empty .)
    INT             reduce using rule 120 (whileEnd -> empty .)
    FLOAT           reduce using rule 120 (whileEnd -> empty .)
    CHAR            reduce using rule 120 (whileEnd -> empty .)
    BRACKETCLOSE    reduce using rule 120 (whileEnd -> empty .)


state 275

    (121) for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp . PARENCLOSE body forEnd
    (73) exp -> exp . AND expp
    (74) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 279
    AND             shift and go to state 154
    OR              shift and go to state 155


state 276

    (60) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE COLON dec_mvar
    (63) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE

    BRACECLOSE      shift and go to state 280


state 277

    (59) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .

    SEMICOLON       reduce using rule 59 (dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .)


state 278

    (103) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body . ifEndElse
    (107) ifEndElse -> . empty
    (134) empty -> .

    IF              reduce using rule 134 (empty -> .)
    PRINT           reduce using rule 134 (empty -> .)
    READ            reduce using rule 134 (empty -> .)
    ID              reduce using rule 134 (empty -> .)
    PLOT            reduce using rule 134 (empty -> .)
    RETURN          reduce using rule 134 (empty -> .)
    WHILE           reduce using rule 134 (empty -> .)
    FOR             reduce using rule 134 (empty -> .)
    MAX             reduce using rule 134 (empty -> .)
    MIN             reduce using rule 134 (empty -> .)
    SUM             reduce using rule 134 (empty -> .)
    NORMAL          reduce using rule 134 (empty -> .)
    UNIFORME        reduce using rule 134 (empty -> .)
    POISSON         reduce using rule 134 (empty -> .)
    BINOMIAL        reduce using rule 134 (empty -> .)
    INT             reduce using rule 134 (empty -> .)
    FLOAT           reduce using rule 134 (empty -> .)
    CHAR            reduce using rule 134 (empty -> .)
    BRACKETCLOSE    reduce using rule 134 (empty -> .)

    ifEndElse                      shift and go to state 281
    empty                          shift and go to state 282

state 279

    (121) for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE . body forEnd
    (34) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 50

    body                           shift and go to state 283

state 280

    (60) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE . COLON dec_mvar
    (63) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .

    COLON           shift and go to state 284
    SEMICOLON       reduce using rule 63 (dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .)


state 281

    (103) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .

    IF              reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    PRINT           reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    READ            reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    ID              reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    PLOT            reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    RETURN          reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    WHILE           reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    FOR             reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    MAX             reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    MIN             reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    SUM             reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    NORMAL          reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    UNIFORME        reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    POISSON         reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    BINOMIAL        reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    INT             reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    FLOAT           reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    CHAR            reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    BRACKETCLOSE    reduce using rule 103 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)


state 282

    (107) ifEndElse -> empty .

    IF              reduce using rule 107 (ifEndElse -> empty .)
    PRINT           reduce using rule 107 (ifEndElse -> empty .)
    READ            reduce using rule 107 (ifEndElse -> empty .)
    ID              reduce using rule 107 (ifEndElse -> empty .)
    PLOT            reduce using rule 107 (ifEndElse -> empty .)
    RETURN          reduce using rule 107 (ifEndElse -> empty .)
    WHILE           reduce using rule 107 (ifEndElse -> empty .)
    FOR             reduce using rule 107 (ifEndElse -> empty .)
    MAX             reduce using rule 107 (ifEndElse -> empty .)
    MIN             reduce using rule 107 (ifEndElse -> empty .)
    SUM             reduce using rule 107 (ifEndElse -> empty .)
    NORMAL          reduce using rule 107 (ifEndElse -> empty .)
    UNIFORME        reduce using rule 107 (ifEndElse -> empty .)
    POISSON         reduce using rule 107 (ifEndElse -> empty .)
    BINOMIAL        reduce using rule 107 (ifEndElse -> empty .)
    INT             reduce using rule 107 (ifEndElse -> empty .)
    FLOAT           reduce using rule 107 (ifEndElse -> empty .)
    CHAR            reduce using rule 107 (ifEndElse -> empty .)
    BRACKETCLOSE    reduce using rule 107 (ifEndElse -> empty .)


state 283

    (121) for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body . forEnd
    (123) forEnd -> . empty
    (134) empty -> .

    IF              reduce using rule 134 (empty -> .)
    PRINT           reduce using rule 134 (empty -> .)
    READ            reduce using rule 134 (empty -> .)
    ID              reduce using rule 134 (empty -> .)
    PLOT            reduce using rule 134 (empty -> .)
    RETURN          reduce using rule 134 (empty -> .)
    WHILE           reduce using rule 134 (empty -> .)
    FOR             reduce using rule 134 (empty -> .)
    MAX             reduce using rule 134 (empty -> .)
    MIN             reduce using rule 134 (empty -> .)
    SUM             reduce using rule 134 (empty -> .)
    NORMAL          reduce using rule 134 (empty -> .)
    UNIFORME        reduce using rule 134 (empty -> .)
    POISSON         reduce using rule 134 (empty -> .)
    BINOMIAL        reduce using rule 134 (empty -> .)
    INT             reduce using rule 134 (empty -> .)
    FLOAT           reduce using rule 134 (empty -> .)
    CHAR            reduce using rule 134 (empty -> .)
    BRACKETCLOSE    reduce using rule 134 (empty -> .)

    forEnd                         shift and go to state 285
    empty                          shift and go to state 286

state 284

    (60) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON . dec_mvar
    (58) dec_mvar -> . ID COLON dec_mvar
    (59) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (60) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (61) dec_mvar -> . ID
    (62) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (63) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 182

    dec_mvar                       shift and go to state 287

state 285

    (121) for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .

    IF              reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    PRINT           reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    READ            reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    ID              reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    PLOT            reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    RETURN          reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    WHILE           reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    FOR             reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    MAX             reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    MIN             reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    SUM             reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    NORMAL          reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    UNIFORME        reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    POISSON         reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    BINOMIAL        reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    INT             reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    FLOAT           reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    CHAR            reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    BRACKETCLOSE    reduce using rule 121 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)


state 286

    (123) forEnd -> empty .

    IF              reduce using rule 123 (forEnd -> empty .)
    PRINT           reduce using rule 123 (forEnd -> empty .)
    READ            reduce using rule 123 (forEnd -> empty .)
    ID              reduce using rule 123 (forEnd -> empty .)
    PLOT            reduce using rule 123 (forEnd -> empty .)
    RETURN          reduce using rule 123 (forEnd -> empty .)
    WHILE           reduce using rule 123 (forEnd -> empty .)
    FOR             reduce using rule 123 (forEnd -> empty .)
    MAX             reduce using rule 123 (forEnd -> empty .)
    MIN             reduce using rule 123 (forEnd -> empty .)
    SUM             reduce using rule 123 (forEnd -> empty .)
    NORMAL          reduce using rule 123 (forEnd -> empty .)
    UNIFORME        reduce using rule 123 (forEnd -> empty .)
    POISSON         reduce using rule 123 (forEnd -> empty .)
    BINOMIAL        reduce using rule 123 (forEnd -> empty .)
    INT             reduce using rule 123 (forEnd -> empty .)
    FLOAT           reduce using rule 123 (forEnd -> empty .)
    CHAR            reduce using rule 123 (forEnd -> empty .)
    BRACKETCLOSE    reduce using rule 123 (forEnd -> empty .)


state 287

    (60) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .

    SEMICOLON       reduce using rule 60 (dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 223 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 223 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 223 resolved as shift
WARNING: reduce/reduce conflict in state 60 resolved using rule (bodyy -> statement)
WARNING: rejected rule (empty -> <empty>) in state 60
WARNING: reduce/reduce conflict in state 119 resolved using rule (factor -> ID)
WARNING: rejected rule (variable -> ID) in state 119
