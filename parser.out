Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start_program
Rule 1     start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body end
Rule 2     start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body end
Rule 3     start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body end
Rule 4     start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body end
Rule 5     cuadruploMain -> empty
Rule 6     main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body
Rule 7     crearTablaMain -> empty
Rule 8     gotoMain -> empty
Rule 9     end -> empty
Rule 10    vars -> VAR varss
Rule 11    varss -> type guardarTipo mvar SEMICOLON varss
Rule 12    varss -> type guardarTipo mvar SEMICOLON
Rule 13    guardarTipo -> empty
Rule 14    mvar -> ID guardarIDvar COLON mvar
Rule 15    mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON mvar
Rule 16    mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
Rule 17    mvar -> ID guardarIDvar
Rule 18    mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE
Rule 19    mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE
Rule 20    guardarIDvar -> empty
Rule 21    multiple_funcs -> dec_func
Rule 22    multiple_funcs -> dec_func multiple_funcs
Rule 23    dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
Rule 24    dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
Rule 25    crearSymbolTable -> empty
Rule 26    param -> typeParam ID
Rule 27    param -> typeParam ID COLON param
Rule 28    param -> empty
Rule 29    typeParam -> INT
Rule 30    typeParam -> FLOAT
Rule 31    typeParam -> CHAR
Rule 32    numeroParam -> empty
Rule 33    startFunc -> empty
Rule 34    exitFunc -> empty
Rule 35    type -> INT
Rule 36    type -> FLOAT
Rule 37    type -> CHAR
Rule 38    body -> BRACKETOPEN bodyy BRACKETCLOSE
Rule 39    bodyy -> statement
Rule 40    bodyy -> statement bodyy
Rule 41    bodyy -> empty
Rule 42    statement -> dec_variables
Rule 43    statement -> assignment
Rule 44    statement -> condition
Rule 45    statement -> writing
Rule 46    statement -> reading
Rule 47    statement -> call_func
Rule 48    statement -> graph
Rule 49    statement -> return
Rule 50    statement -> while_loop
Rule 51    statement -> for_loop
Rule 52    statement -> max
Rule 53    statement -> min
Rule 54    statement -> sum
Rule 55    statement -> normal
Rule 56    statement -> uniforme
Rule 57    statement -> poisson
Rule 58    statement -> binomial
Rule 59    dec_variables -> dec_variabless
Rule 60    dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless
Rule 61    dec_variabless -> type guardarTipo dec_mvar SEMICOLON
Rule 62    dec_mvar -> ID guardarID COLON dec_mvar
Rule 63    dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
Rule 64    dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
Rule 65    dec_mvar -> ID guardarID
Rule 66    dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE
Rule 67    dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE
Rule 68    guardarID -> empty
Rule 69    assignment -> variableAssignment EQUAL exp SEMICOLON
Rule 70    call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE
Rule 71    generarERA -> empty
Rule 72    call_funcc -> exp mandarParam
Rule 73    call_funcc -> exp mandarParam COLON call_funcc
Rule 74    call_funcc -> empty
Rule 75    mandarParam -> empty
Rule 76    exp -> expp
Rule 77    exp -> exp AND expp
Rule 78    exp -> exp OR expp
Rule 79    expp -> m_exp
Rule 80    expp -> expp GREATHERTHAN m_exp
Rule 81    expp -> expp LESSTHAN m_exp
Rule 82    expp -> expp GREATHEREQUAL m_exp
Rule 83    expp -> expp LESSEQUAL m_exp
Rule 84    expp -> expp DIFFERENT m_exp
Rule 85    expp -> expp SAME m_exp
Rule 86    m_exp -> termino
Rule 87    m_exp -> m_exp PLUS termino
Rule 88    m_exp -> m_exp MINUS termino
Rule 89    termino -> factor
Rule 90    termino -> termino MULTIPLY factor
Rule 91    termino -> termino DIVIDE factor
Rule 92    factor -> ID
Rule 93    factor -> CTEINT guardarConstanteInt
Rule 94    factor -> CTFLOAT guardarConstanteFloat
Rule 95    factor -> CTECHAR guardarConstanteChar
Rule 96    factor -> variable
Rule 97    factor -> call_func
Rule 98    factor -> PARENOPEN exp PARENCLOSE
Rule 99    guardarConstanteInt -> empty
Rule 100   guardarConstanteFloat -> empty
Rule 101   guardarConstanteChar -> empty
Rule 102   variable -> ID
Rule 103   variable -> ID BRACEOPEN exp BRACECLOSE
Rule 104   variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
Rule 105   variableAssignment -> ID
Rule 106   variableAssignment -> ID BRACEOPEN exp BRACECLOSE
Rule 107   variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
Rule 108   condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
Rule 109   condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
Rule 110   cuadruploIF -> empty
Rule 111   ifEnd -> empty
Rule 112   cuadruploElse -> empty
Rule 113   ifEndElse -> empty
Rule 114   writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
Rule 115   writingg -> exp
Rule 116   writingg -> exp COLON writingg
Rule 117   writingg -> auxString
Rule 118   writingg -> auxString COLON writingg
Rule 119   auxString -> CTESTRING
Rule 120   reading -> READ multivariables SEMICOLON
Rule 121   multivariables -> variable
Rule 122   multivariables -> variable COLON multivariables
Rule 123   while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
Rule 124   whileMigaja -> empty
Rule 125   whileEval -> empty
Rule 126   whileEnd -> empty
Rule 127   for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd
Rule 128   guardarValorFor -> empty
Rule 129   forEnd -> empty
Rule 130   return -> RETURN exp SEMICOLON
Rule 131   graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON
Rule 132   max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON
Rule 133   min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON
Rule 134   sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON
Rule 135   param_dist -> variable
Rule 136   param_dist -> variable COLON param_dist
Rule 137   binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 138   poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 139   uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 140   normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 141   empty -> <empty>

Terminals, with rules where they appear

AND                  : 77
BINOMIAL             : 137
BRACECLOSE           : 15 16 16 18 19 19 63 64 64 66 67 67 103 104 104 106 107 107
BRACEOPEN            : 15 16 16 18 19 19 63 64 64 66 67 67 103 104 104 106 107 107
BRACKETCLOSE         : 38
BRACKETOPEN          : 38
CHAR                 : 31 37
COLON                : 14 15 16 27 62 63 64 73 116 118 122 136
CTECHAR              : 95
CTEINT               : 15 16 16 18 19 19 63 64 64 66 67 67 93
CTESTRING            : 119
CTFLOAT              : 94
DIFFERENT            : 84
DIVIDE               : 91
ELSE                 : 109
EQUAL                : 69 127
FLOAT                : 30 36
FOR                  : 127
FUNCTION             : 23 24
GREATHEREQUAL        : 82
GREATHERTHAN         : 80
ID                   : 1 2 3 4 14 15 16 17 18 19 23 24 26 27 62 63 64 65 66 67 70 92 102 103 104 105 106 107 127
IF                   : 108 109
INT                  : 29 35
LESSEQUAL            : 83
LESSTHAN             : 81
MAIN                 : 6
MAX                  : 132
MIN                  : 133
MINUS                : 88
MULTIPLY             : 90
NORMAL               : 140
OR                   : 78
PARENCLOSE           : 6 23 24 70 98 108 109 114 123 127 131 132 133 134 137 138 139 140
PARENOPEN            : 6 23 24 70 98 108 109 114 123 127 131 132 133 134 137 138 139 140
PLOT                 : 131
PLUS                 : 87
POISSON              : 138
PRINT                : 114
PROGRAM              : 1 2 3 4
READ                 : 120
RETURN               : 130
SAME                 : 85
SEMICOLON            : 1 2 3 4 11 12 60 61 69 114 120 130 131 132 133 134 137 138 139 140
SUM                  : 134
TO                   : 127
UNIFORME             : 139
VAR                  : 10
VOID                 : 24
WHILE                : 123
error                : 

Nonterminals, with rules where they appear

assignment           : 43
auxString            : 117 118
binomial             : 58
body                 : 6 23 24 108 109 109 123 127
bodyy                : 38 40
call_func            : 47 97
call_funcc           : 70 73
condition            : 44
crearSymbolTable     : 23 24
crearTablaMain       : 6
cuadruploElse        : 109
cuadruploIF          : 108 109
cuadruploMain        : 1 2 3 4
dec_func             : 21 22
dec_mvar             : 60 61 62 63 64
dec_variables        : 42
dec_variabless       : 59 60
empty                : 5 7 8 9 13 20 25 28 32 33 34 41 68 71 74 75 99 100 101 110 111 112 113 124 125 126 128 129
end                  : 1 2 3 4
exitFunc             : 23 24
exp                  : 69 72 73 77 78 98 103 104 104 106 107 107 108 109 115 116 123 127 127 130 131 132 133 134
expp                 : 76 77 78 80 81 82 83 84 85
factor               : 89 90 91
forEnd               : 127
for_loop             : 51
generarERA           : 70
gotoMain             : 6
graph                : 48
guardarConstanteChar : 95
guardarConstanteFloat : 94
guardarConstanteInt  : 93
guardarID            : 62 63 64 65 66 67
guardarIDvar         : 14 15 16 17 18 19
guardarTipo          : 11 12 60 61
guardarValorFor      : 127
ifEnd                : 108
ifEndElse            : 109
m_exp                : 79 80 81 82 83 84 85 87 88
main_body            : 1 2 3 4
mandarParam          : 72 73
max                  : 52
min                  : 53
multiple_funcs       : 1 3 22
multivariables       : 120 122
mvar                 : 11 12 14 15 16
normal               : 55
numeroParam          : 23 24
param                : 23 24 27
param_dist           : 136 137 138 139 140
poisson              : 57
reading              : 46
return               : 49
startFunc            : 23 24
start_program        : 0
statement            : 39 40
sum                  : 54
termino              : 86 87 88 90 91
type                 : 11 12 23 60 61
typeParam            : 26 27
uniforme             : 56
variable             : 96 121 122 135 136
variableAssignment   : 69
vars                 : 1 2
varss                : 10 11
whileEnd             : 123
whileEval            : 123
whileMigaja          : 123
while_loop           : 50
writing              : 45
writingg             : 114 116 118

Parsing method: LALR

state 0

    (0) S' -> . start_program
    (1) start_program -> . cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body end
    (2) start_program -> . cuadruploMain PROGRAM ID SEMICOLON vars main_body end
    (3) start_program -> . cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body end
    (4) start_program -> . cuadruploMain PROGRAM ID SEMICOLON main_body end
    (5) cuadruploMain -> . empty
    (141) empty -> .

    PROGRAM         reduce using rule 141 (empty -> .)

    start_program                  shift and go to state 1
    cuadruploMain                  shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> start_program .



state 2

    (1) start_program -> cuadruploMain . PROGRAM ID SEMICOLON vars multiple_funcs main_body end
    (2) start_program -> cuadruploMain . PROGRAM ID SEMICOLON vars main_body end
    (3) start_program -> cuadruploMain . PROGRAM ID SEMICOLON multiple_funcs main_body end
    (4) start_program -> cuadruploMain . PROGRAM ID SEMICOLON main_body end

    PROGRAM         shift and go to state 4


state 3

    (5) cuadruploMain -> empty .

    PROGRAM         reduce using rule 5 (cuadruploMain -> empty .)


state 4

    (1) start_program -> cuadruploMain PROGRAM . ID SEMICOLON vars multiple_funcs main_body end
    (2) start_program -> cuadruploMain PROGRAM . ID SEMICOLON vars main_body end
    (3) start_program -> cuadruploMain PROGRAM . ID SEMICOLON multiple_funcs main_body end
    (4) start_program -> cuadruploMain PROGRAM . ID SEMICOLON main_body end

    ID              shift and go to state 5


state 5

    (1) start_program -> cuadruploMain PROGRAM ID . SEMICOLON vars multiple_funcs main_body end
    (2) start_program -> cuadruploMain PROGRAM ID . SEMICOLON vars main_body end
    (3) start_program -> cuadruploMain PROGRAM ID . SEMICOLON multiple_funcs main_body end
    (4) start_program -> cuadruploMain PROGRAM ID . SEMICOLON main_body end

    SEMICOLON       shift and go to state 6


state 6

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON . vars multiple_funcs main_body end
    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON . vars main_body end
    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON . multiple_funcs main_body end
    (4) start_program -> cuadruploMain PROGRAM ID SEMICOLON . main_body end
    (10) vars -> . VAR varss
    (21) multiple_funcs -> . dec_func
    (22) multiple_funcs -> . dec_func multiple_funcs
    (6) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body
    (23) dec_func -> . FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
    (24) dec_func -> . FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc

    VAR             shift and go to state 10
    MAIN            shift and go to state 12
    FUNCTION        shift and go to state 13

    vars                           shift and go to state 7
    multiple_funcs                 shift and go to state 8
    main_body                      shift and go to state 9
    dec_func                       shift and go to state 11

state 7

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars . multiple_funcs main_body end
    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars . main_body end
    (21) multiple_funcs -> . dec_func
    (22) multiple_funcs -> . dec_func multiple_funcs
    (6) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body
    (23) dec_func -> . FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
    (24) dec_func -> . FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc

    MAIN            shift and go to state 12
    FUNCTION        shift and go to state 13

    multiple_funcs                 shift and go to state 14
    main_body                      shift and go to state 15
    dec_func                       shift and go to state 11

state 8

    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs . main_body end
    (6) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body

    MAIN            shift and go to state 12

    main_body                      shift and go to state 16

state 9

    (4) start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body . end
    (9) end -> . empty
    (141) empty -> .

    $end            reduce using rule 141 (empty -> .)

    end                            shift and go to state 17
    empty                          shift and go to state 18

state 10

    (10) vars -> VAR . varss
    (11) varss -> . type guardarTipo mvar SEMICOLON varss
    (12) varss -> . type guardarTipo mvar SEMICOLON
    (35) type -> . INT
    (36) type -> . FLOAT
    (37) type -> . CHAR

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    varss                          shift and go to state 19
    type                           shift and go to state 20

state 11

    (21) multiple_funcs -> dec_func .
    (22) multiple_funcs -> dec_func . multiple_funcs
    (21) multiple_funcs -> . dec_func
    (22) multiple_funcs -> . dec_func multiple_funcs
    (23) dec_func -> . FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
    (24) dec_func -> . FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc

    MAIN            reduce using rule 21 (multiple_funcs -> dec_func .)
    FUNCTION        shift and go to state 13

    dec_func                       shift and go to state 11
    multiple_funcs                 shift and go to state 24

state 12

    (6) main_body -> MAIN . crearTablaMain PARENOPEN PARENCLOSE gotoMain body
    (7) crearTablaMain -> . empty
    (141) empty -> .

    PARENOPEN       reduce using rule 141 (empty -> .)

    crearTablaMain                 shift and go to state 25
    empty                          shift and go to state 26

state 13

    (23) dec_func -> FUNCTION . type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
    (24) dec_func -> FUNCTION . VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
    (35) type -> . INT
    (36) type -> . FLOAT
    (37) type -> . CHAR

    VOID            shift and go to state 28
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    type                           shift and go to state 27

state 14

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs . main_body end
    (6) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body

    MAIN            shift and go to state 12

    main_body                      shift and go to state 29

state 15

    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body . end
    (9) end -> . empty
    (141) empty -> .

    $end            reduce using rule 141 (empty -> .)

    end                            shift and go to state 30
    empty                          shift and go to state 18

state 16

    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body . end
    (9) end -> . empty
    (141) empty -> .

    $end            reduce using rule 141 (empty -> .)

    end                            shift and go to state 31
    empty                          shift and go to state 18

state 17

    (4) start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body end .

    $end            reduce using rule 4 (start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body end .)


state 18

    (9) end -> empty .

    $end            reduce using rule 9 (end -> empty .)


state 19

    (10) vars -> VAR varss .

    MAIN            reduce using rule 10 (vars -> VAR varss .)
    FUNCTION        reduce using rule 10 (vars -> VAR varss .)


state 20

    (11) varss -> type . guardarTipo mvar SEMICOLON varss
    (12) varss -> type . guardarTipo mvar SEMICOLON
    (13) guardarTipo -> . empty
    (141) empty -> .

    ID              reduce using rule 141 (empty -> .)

    guardarTipo                    shift and go to state 32
    empty                          shift and go to state 33

state 21

    (35) type -> INT .

    ID              reduce using rule 35 (type -> INT .)


state 22

    (36) type -> FLOAT .

    ID              reduce using rule 36 (type -> FLOAT .)


state 23

    (37) type -> CHAR .

    ID              reduce using rule 37 (type -> CHAR .)


state 24

    (22) multiple_funcs -> dec_func multiple_funcs .

    MAIN            reduce using rule 22 (multiple_funcs -> dec_func multiple_funcs .)


state 25

    (6) main_body -> MAIN crearTablaMain . PARENOPEN PARENCLOSE gotoMain body

    PARENOPEN       shift and go to state 34


state 26

    (7) crearTablaMain -> empty .

    PARENOPEN       reduce using rule 7 (crearTablaMain -> empty .)


state 27

    (23) dec_func -> FUNCTION type . ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc

    ID              shift and go to state 35


state 28

    (24) dec_func -> FUNCTION VOID . ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc

    ID              shift and go to state 36


state 29

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body . end
    (9) end -> . empty
    (141) empty -> .

    $end            reduce using rule 141 (empty -> .)

    end                            shift and go to state 37
    empty                          shift and go to state 18

state 30

    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body end .

    $end            reduce using rule 2 (start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body end .)


state 31

    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body end .

    $end            reduce using rule 3 (start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body end .)


state 32

    (11) varss -> type guardarTipo . mvar SEMICOLON varss
    (12) varss -> type guardarTipo . mvar SEMICOLON
    (14) mvar -> . ID guardarIDvar COLON mvar
    (15) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (16) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID guardarIDvar
    (18) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE
    (19) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 39

    mvar                           shift and go to state 38

state 33

    (13) guardarTipo -> empty .

    ID              reduce using rule 13 (guardarTipo -> empty .)


state 34

    (6) main_body -> MAIN crearTablaMain PARENOPEN . PARENCLOSE gotoMain body

    PARENCLOSE      shift and go to state 40


state 35

    (23) dec_func -> FUNCTION type ID . crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
    (25) crearSymbolTable -> . empty
    (141) empty -> .

    PARENOPEN       reduce using rule 141 (empty -> .)

    crearSymbolTable               shift and go to state 41
    empty                          shift and go to state 42

state 36

    (24) dec_func -> FUNCTION VOID ID . crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
    (25) crearSymbolTable -> . empty
    (141) empty -> .

    PARENOPEN       reduce using rule 141 (empty -> .)

    crearSymbolTable               shift and go to state 43
    empty                          shift and go to state 42

state 37

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body end .

    $end            reduce using rule 1 (start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body end .)


state 38

    (11) varss -> type guardarTipo mvar . SEMICOLON varss
    (12) varss -> type guardarTipo mvar . SEMICOLON

    SEMICOLON       shift and go to state 44


state 39

    (14) mvar -> ID . guardarIDvar COLON mvar
    (15) mvar -> ID . guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (16) mvar -> ID . guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> ID . guardarIDvar
    (18) mvar -> ID . guardarIDvar BRACEOPEN CTEINT BRACECLOSE
    (19) mvar -> ID . guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE
    (20) guardarIDvar -> . empty
    (141) empty -> .

    COLON           reduce using rule 141 (empty -> .)
    BRACEOPEN       reduce using rule 141 (empty -> .)
    SEMICOLON       reduce using rule 141 (empty -> .)

    guardarIDvar                   shift and go to state 45
    empty                          shift and go to state 46

state 40

    (6) main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE . gotoMain body
    (8) gotoMain -> . empty
    (141) empty -> .

    BRACKETOPEN     reduce using rule 141 (empty -> .)

    gotoMain                       shift and go to state 47
    empty                          shift and go to state 48

state 41

    (23) dec_func -> FUNCTION type ID crearSymbolTable . PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc

    PARENOPEN       shift and go to state 49


state 42

    (25) crearSymbolTable -> empty .

    PARENOPEN       reduce using rule 25 (crearSymbolTable -> empty .)


state 43

    (24) dec_func -> FUNCTION VOID ID crearSymbolTable . PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc

    PARENOPEN       shift and go to state 50


state 44

    (11) varss -> type guardarTipo mvar SEMICOLON . varss
    (12) varss -> type guardarTipo mvar SEMICOLON .
    (11) varss -> . type guardarTipo mvar SEMICOLON varss
    (12) varss -> . type guardarTipo mvar SEMICOLON
    (35) type -> . INT
    (36) type -> . FLOAT
    (37) type -> . CHAR

    MAIN            reduce using rule 12 (varss -> type guardarTipo mvar SEMICOLON .)
    FUNCTION        reduce using rule 12 (varss -> type guardarTipo mvar SEMICOLON .)
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    type                           shift and go to state 20
    varss                          shift and go to state 51

state 45

    (14) mvar -> ID guardarIDvar . COLON mvar
    (15) mvar -> ID guardarIDvar . BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (16) mvar -> ID guardarIDvar . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> ID guardarIDvar .
    (18) mvar -> ID guardarIDvar . BRACEOPEN CTEINT BRACECLOSE
    (19) mvar -> ID guardarIDvar . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 52
    BRACEOPEN       shift and go to state 53
    SEMICOLON       reduce using rule 17 (mvar -> ID guardarIDvar .)


state 46

    (20) guardarIDvar -> empty .

    COLON           reduce using rule 20 (guardarIDvar -> empty .)
    BRACEOPEN       reduce using rule 20 (guardarIDvar -> empty .)
    SEMICOLON       reduce using rule 20 (guardarIDvar -> empty .)


state 47

    (6) main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain . body
    (38) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 55

    body                           shift and go to state 54

state 48

    (8) gotoMain -> empty .

    BRACKETOPEN     reduce using rule 8 (gotoMain -> empty .)


state 49

    (23) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN . param numeroParam PARENCLOSE startFunc body exitFunc
    (26) param -> . typeParam ID
    (27) param -> . typeParam ID COLON param
    (28) param -> . empty
    (29) typeParam -> . INT
    (30) typeParam -> . FLOAT
    (31) typeParam -> . CHAR
    (141) empty -> .

    INT             shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    PARENCLOSE      reduce using rule 141 (empty -> .)

    param                          shift and go to state 56
    typeParam                      shift and go to state 57
    empty                          shift and go to state 58

state 50

    (24) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN . param numeroParam PARENCLOSE startFunc body exitFunc
    (26) param -> . typeParam ID
    (27) param -> . typeParam ID COLON param
    (28) param -> . empty
    (29) typeParam -> . INT
    (30) typeParam -> . FLOAT
    (31) typeParam -> . CHAR
    (141) empty -> .

    INT             shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    PARENCLOSE      reduce using rule 141 (empty -> .)

    param                          shift and go to state 62
    typeParam                      shift and go to state 57
    empty                          shift and go to state 58

state 51

    (11) varss -> type guardarTipo mvar SEMICOLON varss .

    MAIN            reduce using rule 11 (varss -> type guardarTipo mvar SEMICOLON varss .)
    FUNCTION        reduce using rule 11 (varss -> type guardarTipo mvar SEMICOLON varss .)


state 52

    (14) mvar -> ID guardarIDvar COLON . mvar
    (14) mvar -> . ID guardarIDvar COLON mvar
    (15) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (16) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID guardarIDvar
    (18) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE
    (19) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 39

    mvar                           shift and go to state 63

state 53

    (15) mvar -> ID guardarIDvar BRACEOPEN . CTEINT BRACECLOSE COLON mvar
    (16) mvar -> ID guardarIDvar BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> ID guardarIDvar BRACEOPEN . CTEINT BRACECLOSE
    (19) mvar -> ID guardarIDvar BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    CTEINT          shift and go to state 64


state 54

    (6) main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body .

    $end            reduce using rule 6 (main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body .)


state 55

    (38) body -> BRACKETOPEN . bodyy BRACKETCLOSE
    (39) bodyy -> . statement
    (40) bodyy -> . statement bodyy
    (41) bodyy -> . empty
    (42) statement -> . dec_variables
    (43) statement -> . assignment
    (44) statement -> . condition
    (45) statement -> . writing
    (46) statement -> . reading
    (47) statement -> . call_func
    (48) statement -> . graph
    (49) statement -> . return
    (50) statement -> . while_loop
    (51) statement -> . for_loop
    (52) statement -> . max
    (53) statement -> . min
    (54) statement -> . sum
    (55) statement -> . normal
    (56) statement -> . uniforme
    (57) statement -> . poisson
    (58) statement -> . binomial
    (141) empty -> .
    (59) dec_variables -> . dec_variabless
    (69) assignment -> . variableAssignment EQUAL exp SEMICOLON
    (108) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
    (109) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (114) writing -> . PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
    (120) reading -> . READ multivariables SEMICOLON
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE
    (131) graph -> . PLOT PARENOPEN exp PARENCLOSE SEMICOLON
    (130) return -> . RETURN exp SEMICOLON
    (123) while_loop -> . WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (127) for_loop -> . FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd
    (132) max -> . MAX PARENOPEN exp PARENCLOSE SEMICOLON
    (133) min -> . MIN PARENOPEN exp PARENCLOSE SEMICOLON
    (134) sum -> . SUM PARENOPEN exp PARENCLOSE SEMICOLON
    (140) normal -> . NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (139) uniforme -> . UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON
    (138) poisson -> . POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON
    (137) binomial -> . BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (60) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON dec_variabless
    (61) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON
    (105) variableAssignment -> . ID
    (106) variableAssignment -> . ID BRACEOPEN exp BRACECLOSE
    (107) variableAssignment -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (35) type -> . INT
    (36) type -> . FLOAT
    (37) type -> . CHAR

    BRACKETCLOSE    reduce using rule 141 (empty -> .)
    IF              shift and go to state 87
    PRINT           shift and go to state 88
    READ            shift and go to state 89
    ID              shift and go to state 90
    PLOT            shift and go to state 91
    RETURN          shift and go to state 92
    WHILE           shift and go to state 93
    FOR             shift and go to state 94
    MAX             shift and go to state 95
    MIN             shift and go to state 96
    SUM             shift and go to state 97
    NORMAL          shift and go to state 98
    UNIFORME        shift and go to state 99
    POISSON         shift and go to state 100
    BINOMIAL        shift and go to state 101
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    bodyy                          shift and go to state 65
    statement                      shift and go to state 66
    empty                          shift and go to state 67
    dec_variables                  shift and go to state 68
    assignment                     shift and go to state 69
    condition                      shift and go to state 70
    writing                        shift and go to state 71
    reading                        shift and go to state 72
    call_func                      shift and go to state 73
    graph                          shift and go to state 74
    return                         shift and go to state 75
    while_loop                     shift and go to state 76
    for_loop                       shift and go to state 77
    max                            shift and go to state 78
    min                            shift and go to state 79
    sum                            shift and go to state 80
    normal                         shift and go to state 81
    uniforme                       shift and go to state 82
    poisson                        shift and go to state 83
    binomial                       shift and go to state 84
    dec_variabless                 shift and go to state 85
    variableAssignment             shift and go to state 86
    type                           shift and go to state 102

state 56

    (23) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param . numeroParam PARENCLOSE startFunc body exitFunc
    (32) numeroParam -> . empty
    (141) empty -> .

    PARENCLOSE      reduce using rule 141 (empty -> .)

    numeroParam                    shift and go to state 103
    empty                          shift and go to state 104

state 57

    (26) param -> typeParam . ID
    (27) param -> typeParam . ID COLON param

    ID              shift and go to state 105


state 58

    (28) param -> empty .

    PARENCLOSE      reduce using rule 28 (param -> empty .)


state 59

    (29) typeParam -> INT .

    ID              reduce using rule 29 (typeParam -> INT .)


state 60

    (30) typeParam -> FLOAT .

    ID              reduce using rule 30 (typeParam -> FLOAT .)


state 61

    (31) typeParam -> CHAR .

    ID              reduce using rule 31 (typeParam -> CHAR .)


state 62

    (24) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param . numeroParam PARENCLOSE startFunc body exitFunc
    (32) numeroParam -> . empty
    (141) empty -> .

    PARENCLOSE      reduce using rule 141 (empty -> .)

    numeroParam                    shift and go to state 106
    empty                          shift and go to state 104

state 63

    (14) mvar -> ID guardarIDvar COLON mvar .

    SEMICOLON       reduce using rule 14 (mvar -> ID guardarIDvar COLON mvar .)


state 64

    (15) mvar -> ID guardarIDvar BRACEOPEN CTEINT . BRACECLOSE COLON mvar
    (16) mvar -> ID guardarIDvar BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> ID guardarIDvar BRACEOPEN CTEINT . BRACECLOSE
    (19) mvar -> ID guardarIDvar BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    BRACECLOSE      shift and go to state 107


state 65

    (38) body -> BRACKETOPEN bodyy . BRACKETCLOSE

    BRACKETCLOSE    shift and go to state 108


state 66

    (39) bodyy -> statement .
    (40) bodyy -> statement . bodyy
    (39) bodyy -> . statement
    (40) bodyy -> . statement bodyy
    (41) bodyy -> . empty
    (42) statement -> . dec_variables
    (43) statement -> . assignment
    (44) statement -> . condition
    (45) statement -> . writing
    (46) statement -> . reading
    (47) statement -> . call_func
    (48) statement -> . graph
    (49) statement -> . return
    (50) statement -> . while_loop
    (51) statement -> . for_loop
    (52) statement -> . max
    (53) statement -> . min
    (54) statement -> . sum
    (55) statement -> . normal
    (56) statement -> . uniforme
    (57) statement -> . poisson
    (58) statement -> . binomial
    (141) empty -> .
    (59) dec_variables -> . dec_variabless
    (69) assignment -> . variableAssignment EQUAL exp SEMICOLON
    (108) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
    (109) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (114) writing -> . PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
    (120) reading -> . READ multivariables SEMICOLON
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE
    (131) graph -> . PLOT PARENOPEN exp PARENCLOSE SEMICOLON
    (130) return -> . RETURN exp SEMICOLON
    (123) while_loop -> . WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (127) for_loop -> . FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd
    (132) max -> . MAX PARENOPEN exp PARENCLOSE SEMICOLON
    (133) min -> . MIN PARENOPEN exp PARENCLOSE SEMICOLON
    (134) sum -> . SUM PARENOPEN exp PARENCLOSE SEMICOLON
    (140) normal -> . NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (139) uniforme -> . UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON
    (138) poisson -> . POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON
    (137) binomial -> . BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (60) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON dec_variabless
    (61) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON
    (105) variableAssignment -> . ID
    (106) variableAssignment -> . ID BRACEOPEN exp BRACECLOSE
    (107) variableAssignment -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (35) type -> . INT
    (36) type -> . FLOAT
    (37) type -> . CHAR

  ! reduce/reduce conflict for BRACKETCLOSE resolved using rule 39 (bodyy -> statement .)
    BRACKETCLOSE    reduce using rule 39 (bodyy -> statement .)
    IF              shift and go to state 87
    PRINT           shift and go to state 88
    READ            shift and go to state 89
    ID              shift and go to state 90
    PLOT            shift and go to state 91
    RETURN          shift and go to state 92
    WHILE           shift and go to state 93
    FOR             shift and go to state 94
    MAX             shift and go to state 95
    MIN             shift and go to state 96
    SUM             shift and go to state 97
    NORMAL          shift and go to state 98
    UNIFORME        shift and go to state 99
    POISSON         shift and go to state 100
    BINOMIAL        shift and go to state 101
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

  ! BRACKETCLOSE    [ reduce using rule 141 (empty -> .) ]

    statement                      shift and go to state 66
    bodyy                          shift and go to state 109
    empty                          shift and go to state 67
    dec_variables                  shift and go to state 68
    assignment                     shift and go to state 69
    condition                      shift and go to state 70
    writing                        shift and go to state 71
    reading                        shift and go to state 72
    call_func                      shift and go to state 73
    graph                          shift and go to state 74
    return                         shift and go to state 75
    while_loop                     shift and go to state 76
    for_loop                       shift and go to state 77
    max                            shift and go to state 78
    min                            shift and go to state 79
    sum                            shift and go to state 80
    normal                         shift and go to state 81
    uniforme                       shift and go to state 82
    poisson                        shift and go to state 83
    binomial                       shift and go to state 84
    dec_variabless                 shift and go to state 85
    variableAssignment             shift and go to state 86
    type                           shift and go to state 102

state 67

    (41) bodyy -> empty .

    BRACKETCLOSE    reduce using rule 41 (bodyy -> empty .)


state 68

    (42) statement -> dec_variables .

    IF              reduce using rule 42 (statement -> dec_variables .)
    PRINT           reduce using rule 42 (statement -> dec_variables .)
    READ            reduce using rule 42 (statement -> dec_variables .)
    ID              reduce using rule 42 (statement -> dec_variables .)
    PLOT            reduce using rule 42 (statement -> dec_variables .)
    RETURN          reduce using rule 42 (statement -> dec_variables .)
    WHILE           reduce using rule 42 (statement -> dec_variables .)
    FOR             reduce using rule 42 (statement -> dec_variables .)
    MAX             reduce using rule 42 (statement -> dec_variables .)
    MIN             reduce using rule 42 (statement -> dec_variables .)
    SUM             reduce using rule 42 (statement -> dec_variables .)
    NORMAL          reduce using rule 42 (statement -> dec_variables .)
    UNIFORME        reduce using rule 42 (statement -> dec_variables .)
    POISSON         reduce using rule 42 (statement -> dec_variables .)
    BINOMIAL        reduce using rule 42 (statement -> dec_variables .)
    INT             reduce using rule 42 (statement -> dec_variables .)
    FLOAT           reduce using rule 42 (statement -> dec_variables .)
    CHAR            reduce using rule 42 (statement -> dec_variables .)
    BRACKETCLOSE    reduce using rule 42 (statement -> dec_variables .)


state 69

    (43) statement -> assignment .

    IF              reduce using rule 43 (statement -> assignment .)
    PRINT           reduce using rule 43 (statement -> assignment .)
    READ            reduce using rule 43 (statement -> assignment .)
    ID              reduce using rule 43 (statement -> assignment .)
    PLOT            reduce using rule 43 (statement -> assignment .)
    RETURN          reduce using rule 43 (statement -> assignment .)
    WHILE           reduce using rule 43 (statement -> assignment .)
    FOR             reduce using rule 43 (statement -> assignment .)
    MAX             reduce using rule 43 (statement -> assignment .)
    MIN             reduce using rule 43 (statement -> assignment .)
    SUM             reduce using rule 43 (statement -> assignment .)
    NORMAL          reduce using rule 43 (statement -> assignment .)
    UNIFORME        reduce using rule 43 (statement -> assignment .)
    POISSON         reduce using rule 43 (statement -> assignment .)
    BINOMIAL        reduce using rule 43 (statement -> assignment .)
    INT             reduce using rule 43 (statement -> assignment .)
    FLOAT           reduce using rule 43 (statement -> assignment .)
    CHAR            reduce using rule 43 (statement -> assignment .)
    BRACKETCLOSE    reduce using rule 43 (statement -> assignment .)


state 70

    (44) statement -> condition .

    IF              reduce using rule 44 (statement -> condition .)
    PRINT           reduce using rule 44 (statement -> condition .)
    READ            reduce using rule 44 (statement -> condition .)
    ID              reduce using rule 44 (statement -> condition .)
    PLOT            reduce using rule 44 (statement -> condition .)
    RETURN          reduce using rule 44 (statement -> condition .)
    WHILE           reduce using rule 44 (statement -> condition .)
    FOR             reduce using rule 44 (statement -> condition .)
    MAX             reduce using rule 44 (statement -> condition .)
    MIN             reduce using rule 44 (statement -> condition .)
    SUM             reduce using rule 44 (statement -> condition .)
    NORMAL          reduce using rule 44 (statement -> condition .)
    UNIFORME        reduce using rule 44 (statement -> condition .)
    POISSON         reduce using rule 44 (statement -> condition .)
    BINOMIAL        reduce using rule 44 (statement -> condition .)
    INT             reduce using rule 44 (statement -> condition .)
    FLOAT           reduce using rule 44 (statement -> condition .)
    CHAR            reduce using rule 44 (statement -> condition .)
    BRACKETCLOSE    reduce using rule 44 (statement -> condition .)


state 71

    (45) statement -> writing .

    IF              reduce using rule 45 (statement -> writing .)
    PRINT           reduce using rule 45 (statement -> writing .)
    READ            reduce using rule 45 (statement -> writing .)
    ID              reduce using rule 45 (statement -> writing .)
    PLOT            reduce using rule 45 (statement -> writing .)
    RETURN          reduce using rule 45 (statement -> writing .)
    WHILE           reduce using rule 45 (statement -> writing .)
    FOR             reduce using rule 45 (statement -> writing .)
    MAX             reduce using rule 45 (statement -> writing .)
    MIN             reduce using rule 45 (statement -> writing .)
    SUM             reduce using rule 45 (statement -> writing .)
    NORMAL          reduce using rule 45 (statement -> writing .)
    UNIFORME        reduce using rule 45 (statement -> writing .)
    POISSON         reduce using rule 45 (statement -> writing .)
    BINOMIAL        reduce using rule 45 (statement -> writing .)
    INT             reduce using rule 45 (statement -> writing .)
    FLOAT           reduce using rule 45 (statement -> writing .)
    CHAR            reduce using rule 45 (statement -> writing .)
    BRACKETCLOSE    reduce using rule 45 (statement -> writing .)


state 72

    (46) statement -> reading .

    IF              reduce using rule 46 (statement -> reading .)
    PRINT           reduce using rule 46 (statement -> reading .)
    READ            reduce using rule 46 (statement -> reading .)
    ID              reduce using rule 46 (statement -> reading .)
    PLOT            reduce using rule 46 (statement -> reading .)
    RETURN          reduce using rule 46 (statement -> reading .)
    WHILE           reduce using rule 46 (statement -> reading .)
    FOR             reduce using rule 46 (statement -> reading .)
    MAX             reduce using rule 46 (statement -> reading .)
    MIN             reduce using rule 46 (statement -> reading .)
    SUM             reduce using rule 46 (statement -> reading .)
    NORMAL          reduce using rule 46 (statement -> reading .)
    UNIFORME        reduce using rule 46 (statement -> reading .)
    POISSON         reduce using rule 46 (statement -> reading .)
    BINOMIAL        reduce using rule 46 (statement -> reading .)
    INT             reduce using rule 46 (statement -> reading .)
    FLOAT           reduce using rule 46 (statement -> reading .)
    CHAR            reduce using rule 46 (statement -> reading .)
    BRACKETCLOSE    reduce using rule 46 (statement -> reading .)


state 73

    (47) statement -> call_func .

    IF              reduce using rule 47 (statement -> call_func .)
    PRINT           reduce using rule 47 (statement -> call_func .)
    READ            reduce using rule 47 (statement -> call_func .)
    ID              reduce using rule 47 (statement -> call_func .)
    PLOT            reduce using rule 47 (statement -> call_func .)
    RETURN          reduce using rule 47 (statement -> call_func .)
    WHILE           reduce using rule 47 (statement -> call_func .)
    FOR             reduce using rule 47 (statement -> call_func .)
    MAX             reduce using rule 47 (statement -> call_func .)
    MIN             reduce using rule 47 (statement -> call_func .)
    SUM             reduce using rule 47 (statement -> call_func .)
    NORMAL          reduce using rule 47 (statement -> call_func .)
    UNIFORME        reduce using rule 47 (statement -> call_func .)
    POISSON         reduce using rule 47 (statement -> call_func .)
    BINOMIAL        reduce using rule 47 (statement -> call_func .)
    INT             reduce using rule 47 (statement -> call_func .)
    FLOAT           reduce using rule 47 (statement -> call_func .)
    CHAR            reduce using rule 47 (statement -> call_func .)
    BRACKETCLOSE    reduce using rule 47 (statement -> call_func .)


state 74

    (48) statement -> graph .

    IF              reduce using rule 48 (statement -> graph .)
    PRINT           reduce using rule 48 (statement -> graph .)
    READ            reduce using rule 48 (statement -> graph .)
    ID              reduce using rule 48 (statement -> graph .)
    PLOT            reduce using rule 48 (statement -> graph .)
    RETURN          reduce using rule 48 (statement -> graph .)
    WHILE           reduce using rule 48 (statement -> graph .)
    FOR             reduce using rule 48 (statement -> graph .)
    MAX             reduce using rule 48 (statement -> graph .)
    MIN             reduce using rule 48 (statement -> graph .)
    SUM             reduce using rule 48 (statement -> graph .)
    NORMAL          reduce using rule 48 (statement -> graph .)
    UNIFORME        reduce using rule 48 (statement -> graph .)
    POISSON         reduce using rule 48 (statement -> graph .)
    BINOMIAL        reduce using rule 48 (statement -> graph .)
    INT             reduce using rule 48 (statement -> graph .)
    FLOAT           reduce using rule 48 (statement -> graph .)
    CHAR            reduce using rule 48 (statement -> graph .)
    BRACKETCLOSE    reduce using rule 48 (statement -> graph .)


state 75

    (49) statement -> return .

    IF              reduce using rule 49 (statement -> return .)
    PRINT           reduce using rule 49 (statement -> return .)
    READ            reduce using rule 49 (statement -> return .)
    ID              reduce using rule 49 (statement -> return .)
    PLOT            reduce using rule 49 (statement -> return .)
    RETURN          reduce using rule 49 (statement -> return .)
    WHILE           reduce using rule 49 (statement -> return .)
    FOR             reduce using rule 49 (statement -> return .)
    MAX             reduce using rule 49 (statement -> return .)
    MIN             reduce using rule 49 (statement -> return .)
    SUM             reduce using rule 49 (statement -> return .)
    NORMAL          reduce using rule 49 (statement -> return .)
    UNIFORME        reduce using rule 49 (statement -> return .)
    POISSON         reduce using rule 49 (statement -> return .)
    BINOMIAL        reduce using rule 49 (statement -> return .)
    INT             reduce using rule 49 (statement -> return .)
    FLOAT           reduce using rule 49 (statement -> return .)
    CHAR            reduce using rule 49 (statement -> return .)
    BRACKETCLOSE    reduce using rule 49 (statement -> return .)


state 76

    (50) statement -> while_loop .

    IF              reduce using rule 50 (statement -> while_loop .)
    PRINT           reduce using rule 50 (statement -> while_loop .)
    READ            reduce using rule 50 (statement -> while_loop .)
    ID              reduce using rule 50 (statement -> while_loop .)
    PLOT            reduce using rule 50 (statement -> while_loop .)
    RETURN          reduce using rule 50 (statement -> while_loop .)
    WHILE           reduce using rule 50 (statement -> while_loop .)
    FOR             reduce using rule 50 (statement -> while_loop .)
    MAX             reduce using rule 50 (statement -> while_loop .)
    MIN             reduce using rule 50 (statement -> while_loop .)
    SUM             reduce using rule 50 (statement -> while_loop .)
    NORMAL          reduce using rule 50 (statement -> while_loop .)
    UNIFORME        reduce using rule 50 (statement -> while_loop .)
    POISSON         reduce using rule 50 (statement -> while_loop .)
    BINOMIAL        reduce using rule 50 (statement -> while_loop .)
    INT             reduce using rule 50 (statement -> while_loop .)
    FLOAT           reduce using rule 50 (statement -> while_loop .)
    CHAR            reduce using rule 50 (statement -> while_loop .)
    BRACKETCLOSE    reduce using rule 50 (statement -> while_loop .)


state 77

    (51) statement -> for_loop .

    IF              reduce using rule 51 (statement -> for_loop .)
    PRINT           reduce using rule 51 (statement -> for_loop .)
    READ            reduce using rule 51 (statement -> for_loop .)
    ID              reduce using rule 51 (statement -> for_loop .)
    PLOT            reduce using rule 51 (statement -> for_loop .)
    RETURN          reduce using rule 51 (statement -> for_loop .)
    WHILE           reduce using rule 51 (statement -> for_loop .)
    FOR             reduce using rule 51 (statement -> for_loop .)
    MAX             reduce using rule 51 (statement -> for_loop .)
    MIN             reduce using rule 51 (statement -> for_loop .)
    SUM             reduce using rule 51 (statement -> for_loop .)
    NORMAL          reduce using rule 51 (statement -> for_loop .)
    UNIFORME        reduce using rule 51 (statement -> for_loop .)
    POISSON         reduce using rule 51 (statement -> for_loop .)
    BINOMIAL        reduce using rule 51 (statement -> for_loop .)
    INT             reduce using rule 51 (statement -> for_loop .)
    FLOAT           reduce using rule 51 (statement -> for_loop .)
    CHAR            reduce using rule 51 (statement -> for_loop .)
    BRACKETCLOSE    reduce using rule 51 (statement -> for_loop .)


state 78

    (52) statement -> max .

    IF              reduce using rule 52 (statement -> max .)
    PRINT           reduce using rule 52 (statement -> max .)
    READ            reduce using rule 52 (statement -> max .)
    ID              reduce using rule 52 (statement -> max .)
    PLOT            reduce using rule 52 (statement -> max .)
    RETURN          reduce using rule 52 (statement -> max .)
    WHILE           reduce using rule 52 (statement -> max .)
    FOR             reduce using rule 52 (statement -> max .)
    MAX             reduce using rule 52 (statement -> max .)
    MIN             reduce using rule 52 (statement -> max .)
    SUM             reduce using rule 52 (statement -> max .)
    NORMAL          reduce using rule 52 (statement -> max .)
    UNIFORME        reduce using rule 52 (statement -> max .)
    POISSON         reduce using rule 52 (statement -> max .)
    BINOMIAL        reduce using rule 52 (statement -> max .)
    INT             reduce using rule 52 (statement -> max .)
    FLOAT           reduce using rule 52 (statement -> max .)
    CHAR            reduce using rule 52 (statement -> max .)
    BRACKETCLOSE    reduce using rule 52 (statement -> max .)


state 79

    (53) statement -> min .

    IF              reduce using rule 53 (statement -> min .)
    PRINT           reduce using rule 53 (statement -> min .)
    READ            reduce using rule 53 (statement -> min .)
    ID              reduce using rule 53 (statement -> min .)
    PLOT            reduce using rule 53 (statement -> min .)
    RETURN          reduce using rule 53 (statement -> min .)
    WHILE           reduce using rule 53 (statement -> min .)
    FOR             reduce using rule 53 (statement -> min .)
    MAX             reduce using rule 53 (statement -> min .)
    MIN             reduce using rule 53 (statement -> min .)
    SUM             reduce using rule 53 (statement -> min .)
    NORMAL          reduce using rule 53 (statement -> min .)
    UNIFORME        reduce using rule 53 (statement -> min .)
    POISSON         reduce using rule 53 (statement -> min .)
    BINOMIAL        reduce using rule 53 (statement -> min .)
    INT             reduce using rule 53 (statement -> min .)
    FLOAT           reduce using rule 53 (statement -> min .)
    CHAR            reduce using rule 53 (statement -> min .)
    BRACKETCLOSE    reduce using rule 53 (statement -> min .)


state 80

    (54) statement -> sum .

    IF              reduce using rule 54 (statement -> sum .)
    PRINT           reduce using rule 54 (statement -> sum .)
    READ            reduce using rule 54 (statement -> sum .)
    ID              reduce using rule 54 (statement -> sum .)
    PLOT            reduce using rule 54 (statement -> sum .)
    RETURN          reduce using rule 54 (statement -> sum .)
    WHILE           reduce using rule 54 (statement -> sum .)
    FOR             reduce using rule 54 (statement -> sum .)
    MAX             reduce using rule 54 (statement -> sum .)
    MIN             reduce using rule 54 (statement -> sum .)
    SUM             reduce using rule 54 (statement -> sum .)
    NORMAL          reduce using rule 54 (statement -> sum .)
    UNIFORME        reduce using rule 54 (statement -> sum .)
    POISSON         reduce using rule 54 (statement -> sum .)
    BINOMIAL        reduce using rule 54 (statement -> sum .)
    INT             reduce using rule 54 (statement -> sum .)
    FLOAT           reduce using rule 54 (statement -> sum .)
    CHAR            reduce using rule 54 (statement -> sum .)
    BRACKETCLOSE    reduce using rule 54 (statement -> sum .)


state 81

    (55) statement -> normal .

    IF              reduce using rule 55 (statement -> normal .)
    PRINT           reduce using rule 55 (statement -> normal .)
    READ            reduce using rule 55 (statement -> normal .)
    ID              reduce using rule 55 (statement -> normal .)
    PLOT            reduce using rule 55 (statement -> normal .)
    RETURN          reduce using rule 55 (statement -> normal .)
    WHILE           reduce using rule 55 (statement -> normal .)
    FOR             reduce using rule 55 (statement -> normal .)
    MAX             reduce using rule 55 (statement -> normal .)
    MIN             reduce using rule 55 (statement -> normal .)
    SUM             reduce using rule 55 (statement -> normal .)
    NORMAL          reduce using rule 55 (statement -> normal .)
    UNIFORME        reduce using rule 55 (statement -> normal .)
    POISSON         reduce using rule 55 (statement -> normal .)
    BINOMIAL        reduce using rule 55 (statement -> normal .)
    INT             reduce using rule 55 (statement -> normal .)
    FLOAT           reduce using rule 55 (statement -> normal .)
    CHAR            reduce using rule 55 (statement -> normal .)
    BRACKETCLOSE    reduce using rule 55 (statement -> normal .)


state 82

    (56) statement -> uniforme .

    IF              reduce using rule 56 (statement -> uniforme .)
    PRINT           reduce using rule 56 (statement -> uniforme .)
    READ            reduce using rule 56 (statement -> uniforme .)
    ID              reduce using rule 56 (statement -> uniforme .)
    PLOT            reduce using rule 56 (statement -> uniforme .)
    RETURN          reduce using rule 56 (statement -> uniforme .)
    WHILE           reduce using rule 56 (statement -> uniforme .)
    FOR             reduce using rule 56 (statement -> uniforme .)
    MAX             reduce using rule 56 (statement -> uniforme .)
    MIN             reduce using rule 56 (statement -> uniforme .)
    SUM             reduce using rule 56 (statement -> uniforme .)
    NORMAL          reduce using rule 56 (statement -> uniforme .)
    UNIFORME        reduce using rule 56 (statement -> uniforme .)
    POISSON         reduce using rule 56 (statement -> uniforme .)
    BINOMIAL        reduce using rule 56 (statement -> uniforme .)
    INT             reduce using rule 56 (statement -> uniforme .)
    FLOAT           reduce using rule 56 (statement -> uniforme .)
    CHAR            reduce using rule 56 (statement -> uniforme .)
    BRACKETCLOSE    reduce using rule 56 (statement -> uniforme .)


state 83

    (57) statement -> poisson .

    IF              reduce using rule 57 (statement -> poisson .)
    PRINT           reduce using rule 57 (statement -> poisson .)
    READ            reduce using rule 57 (statement -> poisson .)
    ID              reduce using rule 57 (statement -> poisson .)
    PLOT            reduce using rule 57 (statement -> poisson .)
    RETURN          reduce using rule 57 (statement -> poisson .)
    WHILE           reduce using rule 57 (statement -> poisson .)
    FOR             reduce using rule 57 (statement -> poisson .)
    MAX             reduce using rule 57 (statement -> poisson .)
    MIN             reduce using rule 57 (statement -> poisson .)
    SUM             reduce using rule 57 (statement -> poisson .)
    NORMAL          reduce using rule 57 (statement -> poisson .)
    UNIFORME        reduce using rule 57 (statement -> poisson .)
    POISSON         reduce using rule 57 (statement -> poisson .)
    BINOMIAL        reduce using rule 57 (statement -> poisson .)
    INT             reduce using rule 57 (statement -> poisson .)
    FLOAT           reduce using rule 57 (statement -> poisson .)
    CHAR            reduce using rule 57 (statement -> poisson .)
    BRACKETCLOSE    reduce using rule 57 (statement -> poisson .)


state 84

    (58) statement -> binomial .

    IF              reduce using rule 58 (statement -> binomial .)
    PRINT           reduce using rule 58 (statement -> binomial .)
    READ            reduce using rule 58 (statement -> binomial .)
    ID              reduce using rule 58 (statement -> binomial .)
    PLOT            reduce using rule 58 (statement -> binomial .)
    RETURN          reduce using rule 58 (statement -> binomial .)
    WHILE           reduce using rule 58 (statement -> binomial .)
    FOR             reduce using rule 58 (statement -> binomial .)
    MAX             reduce using rule 58 (statement -> binomial .)
    MIN             reduce using rule 58 (statement -> binomial .)
    SUM             reduce using rule 58 (statement -> binomial .)
    NORMAL          reduce using rule 58 (statement -> binomial .)
    UNIFORME        reduce using rule 58 (statement -> binomial .)
    POISSON         reduce using rule 58 (statement -> binomial .)
    BINOMIAL        reduce using rule 58 (statement -> binomial .)
    INT             reduce using rule 58 (statement -> binomial .)
    FLOAT           reduce using rule 58 (statement -> binomial .)
    CHAR            reduce using rule 58 (statement -> binomial .)
    BRACKETCLOSE    reduce using rule 58 (statement -> binomial .)


state 85

    (59) dec_variables -> dec_variabless .

    IF              reduce using rule 59 (dec_variables -> dec_variabless .)
    PRINT           reduce using rule 59 (dec_variables -> dec_variabless .)
    READ            reduce using rule 59 (dec_variables -> dec_variabless .)
    ID              reduce using rule 59 (dec_variables -> dec_variabless .)
    PLOT            reduce using rule 59 (dec_variables -> dec_variabless .)
    RETURN          reduce using rule 59 (dec_variables -> dec_variabless .)
    WHILE           reduce using rule 59 (dec_variables -> dec_variabless .)
    FOR             reduce using rule 59 (dec_variables -> dec_variabless .)
    MAX             reduce using rule 59 (dec_variables -> dec_variabless .)
    MIN             reduce using rule 59 (dec_variables -> dec_variabless .)
    SUM             reduce using rule 59 (dec_variables -> dec_variabless .)
    NORMAL          reduce using rule 59 (dec_variables -> dec_variabless .)
    UNIFORME        reduce using rule 59 (dec_variables -> dec_variabless .)
    POISSON         reduce using rule 59 (dec_variables -> dec_variabless .)
    BINOMIAL        reduce using rule 59 (dec_variables -> dec_variabless .)
    INT             reduce using rule 59 (dec_variables -> dec_variabless .)
    FLOAT           reduce using rule 59 (dec_variables -> dec_variabless .)
    CHAR            reduce using rule 59 (dec_variables -> dec_variabless .)
    BRACKETCLOSE    reduce using rule 59 (dec_variables -> dec_variabless .)


state 86

    (69) assignment -> variableAssignment . EQUAL exp SEMICOLON

    EQUAL           shift and go to state 110


state 87

    (108) condition -> IF . PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
    (109) condition -> IF . PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse

    PARENOPEN       shift and go to state 111


state 88

    (114) writing -> PRINT . PARENOPEN writingg PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 112


state 89

    (120) reading -> READ . multivariables SEMICOLON
    (121) multivariables -> . variable
    (122) multivariables -> . variable COLON multivariables
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 115

    multivariables                 shift and go to state 113
    variable                       shift and go to state 114

state 90

    (70) call_func -> ID . generarERA PARENOPEN call_funcc PARENCLOSE
    (105) variableAssignment -> ID .
    (106) variableAssignment -> ID . BRACEOPEN exp BRACECLOSE
    (107) variableAssignment -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (71) generarERA -> . empty
    (141) empty -> .

    EQUAL           reduce using rule 105 (variableAssignment -> ID .)
    BRACEOPEN       shift and go to state 117
    PARENOPEN       reduce using rule 141 (empty -> .)

    generarERA                     shift and go to state 116
    empty                          shift and go to state 118

state 91

    (131) graph -> PLOT . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 119


state 92

    (130) return -> RETURN . exp SEMICOLON
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 120
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 93

    (123) while_loop -> WHILE . whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (124) whileMigaja -> . empty
    (141) empty -> .

    PARENOPEN       reduce using rule 141 (empty -> .)

    whileMigaja                    shift and go to state 132
    empty                          shift and go to state 133

state 94

    (127) for_loop -> FOR . PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd

    PARENOPEN       shift and go to state 134


state 95

    (132) max -> MAX . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 135


state 96

    (133) min -> MIN . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 136


state 97

    (134) sum -> SUM . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 137


state 98

    (140) normal -> NORMAL . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 138


state 99

    (139) uniforme -> UNIFORME . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 139


state 100

    (138) poisson -> POISSON . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 140


state 101

    (137) binomial -> BINOMIAL . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 141


state 102

    (60) dec_variabless -> type . guardarTipo dec_mvar SEMICOLON dec_variabless
    (61) dec_variabless -> type . guardarTipo dec_mvar SEMICOLON
    (13) guardarTipo -> . empty
    (141) empty -> .

    ID              reduce using rule 141 (empty -> .)

    guardarTipo                    shift and go to state 142
    empty                          shift and go to state 33

state 103

    (23) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam . PARENCLOSE startFunc body exitFunc

    PARENCLOSE      shift and go to state 143


state 104

    (32) numeroParam -> empty .

    PARENCLOSE      reduce using rule 32 (numeroParam -> empty .)


state 105

    (26) param -> typeParam ID .
    (27) param -> typeParam ID . COLON param

    PARENCLOSE      reduce using rule 26 (param -> typeParam ID .)
    COLON           shift and go to state 144


state 106

    (24) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam . PARENCLOSE startFunc body exitFunc

    PARENCLOSE      shift and go to state 145


state 107

    (15) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE . COLON mvar
    (16) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE .
    (19) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 147
    BRACEOPEN       shift and go to state 146
    SEMICOLON       reduce using rule 18 (mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE .)


state 108

    (38) body -> BRACKETOPEN bodyy BRACKETCLOSE .

    $end            reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FUNCTION        reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MAIN            reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    ELSE            reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    IF              reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    PRINT           reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    READ            reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    ID              reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    PLOT            reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    RETURN          reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    WHILE           reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FOR             reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MAX             reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MIN             reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    SUM             reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    NORMAL          reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    UNIFORME        reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    POISSON         reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    BINOMIAL        reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    INT             reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FLOAT           reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    CHAR            reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    BRACKETCLOSE    reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)


state 109

    (40) bodyy -> statement bodyy .

    BRACKETCLOSE    reduce using rule 40 (bodyy -> statement bodyy .)


state 110

    (69) assignment -> variableAssignment EQUAL . exp SEMICOLON
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 148
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 111

    (108) condition -> IF PARENOPEN . exp PARENCLOSE cuadruploIF body ifEnd
    (109) condition -> IF PARENOPEN . exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 149
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 112

    (114) writing -> PRINT PARENOPEN . writingg PARENCLOSE SEMICOLON
    (115) writingg -> . exp
    (116) writingg -> . exp COLON writingg
    (117) writingg -> . auxString
    (118) writingg -> . auxString COLON writingg
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (119) auxString -> . CTESTRING
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 153
    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    writingg                       shift and go to state 150
    exp                            shift and go to state 151
    auxString                      shift and go to state 152
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 113

    (120) reading -> READ multivariables . SEMICOLON

    SEMICOLON       shift and go to state 154


state 114

    (121) multivariables -> variable .
    (122) multivariables -> variable . COLON multivariables

    SEMICOLON       reduce using rule 121 (multivariables -> variable .)
    COLON           shift and go to state 155


state 115

    (102) variable -> ID .
    (103) variable -> ID . BRACEOPEN exp BRACECLOSE
    (104) variable -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    COLON           reduce using rule 102 (variable -> ID .)
    SEMICOLON       reduce using rule 102 (variable -> ID .)
    PARENCLOSE      reduce using rule 102 (variable -> ID .)
    BRACEOPEN       shift and go to state 156


state 116

    (70) call_func -> ID generarERA . PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 157


state 117

    (106) variableAssignment -> ID BRACEOPEN . exp BRACECLOSE
    (107) variableAssignment -> ID BRACEOPEN . exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 158
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 118

    (71) generarERA -> empty .

    PARENOPEN       reduce using rule 71 (generarERA -> empty .)


state 119

    (131) graph -> PLOT PARENOPEN . exp PARENCLOSE SEMICOLON
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 159
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 120

    (130) return -> RETURN exp . SEMICOLON
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp

    SEMICOLON       shift and go to state 160
    AND             shift and go to state 161
    OR              shift and go to state 162


state 121

    (76) exp -> expp .
    (80) expp -> expp . GREATHERTHAN m_exp
    (81) expp -> expp . LESSTHAN m_exp
    (82) expp -> expp . GREATHEREQUAL m_exp
    (83) expp -> expp . LESSEQUAL m_exp
    (84) expp -> expp . DIFFERENT m_exp
    (85) expp -> expp . SAME m_exp

    SEMICOLON       reduce using rule 76 (exp -> expp .)
    AND             reduce using rule 76 (exp -> expp .)
    OR              reduce using rule 76 (exp -> expp .)
    PARENCLOSE      reduce using rule 76 (exp -> expp .)
    COLON           reduce using rule 76 (exp -> expp .)
    BRACECLOSE      reduce using rule 76 (exp -> expp .)
    TO              reduce using rule 76 (exp -> expp .)
    GREATHERTHAN    shift and go to state 163
    LESSTHAN        shift and go to state 164
    GREATHEREQUAL   shift and go to state 165
    LESSEQUAL       shift and go to state 166
    DIFFERENT       shift and go to state 167
    SAME            shift and go to state 168


state 122

    (79) expp -> m_exp .
    (87) m_exp -> m_exp . PLUS termino
    (88) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 79 (expp -> m_exp .)
    LESSTHAN        reduce using rule 79 (expp -> m_exp .)
    GREATHEREQUAL   reduce using rule 79 (expp -> m_exp .)
    LESSEQUAL       reduce using rule 79 (expp -> m_exp .)
    DIFFERENT       reduce using rule 79 (expp -> m_exp .)
    SAME            reduce using rule 79 (expp -> m_exp .)
    SEMICOLON       reduce using rule 79 (expp -> m_exp .)
    AND             reduce using rule 79 (expp -> m_exp .)
    OR              reduce using rule 79 (expp -> m_exp .)
    PARENCLOSE      reduce using rule 79 (expp -> m_exp .)
    COLON           reduce using rule 79 (expp -> m_exp .)
    BRACECLOSE      reduce using rule 79 (expp -> m_exp .)
    TO              reduce using rule 79 (expp -> m_exp .)
    PLUS            shift and go to state 169
    MINUS           shift and go to state 170


state 123

    (86) m_exp -> termino .
    (90) termino -> termino . MULTIPLY factor
    (91) termino -> termino . DIVIDE factor

    PLUS            reduce using rule 86 (m_exp -> termino .)
    MINUS           reduce using rule 86 (m_exp -> termino .)
    GREATHERTHAN    reduce using rule 86 (m_exp -> termino .)
    LESSTHAN        reduce using rule 86 (m_exp -> termino .)
    GREATHEREQUAL   reduce using rule 86 (m_exp -> termino .)
    LESSEQUAL       reduce using rule 86 (m_exp -> termino .)
    DIFFERENT       reduce using rule 86 (m_exp -> termino .)
    SAME            reduce using rule 86 (m_exp -> termino .)
    SEMICOLON       reduce using rule 86 (m_exp -> termino .)
    AND             reduce using rule 86 (m_exp -> termino .)
    OR              reduce using rule 86 (m_exp -> termino .)
    PARENCLOSE      reduce using rule 86 (m_exp -> termino .)
    COLON           reduce using rule 86 (m_exp -> termino .)
    BRACECLOSE      reduce using rule 86 (m_exp -> termino .)
    TO              reduce using rule 86 (m_exp -> termino .)
    MULTIPLY        shift and go to state 171
    DIVIDE          shift and go to state 172


state 124

    (89) termino -> factor .

    MULTIPLY        reduce using rule 89 (termino -> factor .)
    DIVIDE          reduce using rule 89 (termino -> factor .)
    PLUS            reduce using rule 89 (termino -> factor .)
    MINUS           reduce using rule 89 (termino -> factor .)
    GREATHERTHAN    reduce using rule 89 (termino -> factor .)
    LESSTHAN        reduce using rule 89 (termino -> factor .)
    GREATHEREQUAL   reduce using rule 89 (termino -> factor .)
    LESSEQUAL       reduce using rule 89 (termino -> factor .)
    DIFFERENT       reduce using rule 89 (termino -> factor .)
    SAME            reduce using rule 89 (termino -> factor .)
    SEMICOLON       reduce using rule 89 (termino -> factor .)
    AND             reduce using rule 89 (termino -> factor .)
    OR              reduce using rule 89 (termino -> factor .)
    PARENCLOSE      reduce using rule 89 (termino -> factor .)
    COLON           reduce using rule 89 (termino -> factor .)
    BRACECLOSE      reduce using rule 89 (termino -> factor .)
    TO              reduce using rule 89 (termino -> factor .)


state 125

    (92) factor -> ID .
    (102) variable -> ID .
    (103) variable -> ID . BRACEOPEN exp BRACECLOSE
    (104) variable -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> ID . generarERA PARENOPEN call_funcc PARENCLOSE
    (71) generarERA -> . empty
    (141) empty -> .

  ! reduce/reduce conflict for MULTIPLY resolved using rule 92 (factor -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 92 (factor -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 92 (factor -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 92 (factor -> ID .)
  ! reduce/reduce conflict for GREATHERTHAN resolved using rule 92 (factor -> ID .)
  ! reduce/reduce conflict for LESSTHAN resolved using rule 92 (factor -> ID .)
  ! reduce/reduce conflict for GREATHEREQUAL resolved using rule 92 (factor -> ID .)
  ! reduce/reduce conflict for LESSEQUAL resolved using rule 92 (factor -> ID .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 92 (factor -> ID .)
  ! reduce/reduce conflict for SAME resolved using rule 92 (factor -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 92 (factor -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 92 (factor -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 92 (factor -> ID .)
  ! reduce/reduce conflict for PARENCLOSE resolved using rule 92 (factor -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 92 (factor -> ID .)
  ! reduce/reduce conflict for BRACECLOSE resolved using rule 92 (factor -> ID .)
  ! reduce/reduce conflict for TO resolved using rule 92 (factor -> ID .)
    MULTIPLY        reduce using rule 92 (factor -> ID .)
    DIVIDE          reduce using rule 92 (factor -> ID .)
    PLUS            reduce using rule 92 (factor -> ID .)
    MINUS           reduce using rule 92 (factor -> ID .)
    GREATHERTHAN    reduce using rule 92 (factor -> ID .)
    LESSTHAN        reduce using rule 92 (factor -> ID .)
    GREATHEREQUAL   reduce using rule 92 (factor -> ID .)
    LESSEQUAL       reduce using rule 92 (factor -> ID .)
    DIFFERENT       reduce using rule 92 (factor -> ID .)
    SAME            reduce using rule 92 (factor -> ID .)
    SEMICOLON       reduce using rule 92 (factor -> ID .)
    AND             reduce using rule 92 (factor -> ID .)
    OR              reduce using rule 92 (factor -> ID .)
    PARENCLOSE      reduce using rule 92 (factor -> ID .)
    COLON           reduce using rule 92 (factor -> ID .)
    BRACECLOSE      reduce using rule 92 (factor -> ID .)
    TO              reduce using rule 92 (factor -> ID .)
    BRACEOPEN       shift and go to state 156
    PARENOPEN       reduce using rule 141 (empty -> .)

  ! MULTIPLY        [ reduce using rule 102 (variable -> ID .) ]
  ! DIVIDE          [ reduce using rule 102 (variable -> ID .) ]
  ! PLUS            [ reduce using rule 102 (variable -> ID .) ]
  ! MINUS           [ reduce using rule 102 (variable -> ID .) ]
  ! GREATHERTHAN    [ reduce using rule 102 (variable -> ID .) ]
  ! LESSTHAN        [ reduce using rule 102 (variable -> ID .) ]
  ! GREATHEREQUAL   [ reduce using rule 102 (variable -> ID .) ]
  ! LESSEQUAL       [ reduce using rule 102 (variable -> ID .) ]
  ! DIFFERENT       [ reduce using rule 102 (variable -> ID .) ]
  ! SAME            [ reduce using rule 102 (variable -> ID .) ]
  ! SEMICOLON       [ reduce using rule 102 (variable -> ID .) ]
  ! AND             [ reduce using rule 102 (variable -> ID .) ]
  ! OR              [ reduce using rule 102 (variable -> ID .) ]
  ! PARENCLOSE      [ reduce using rule 102 (variable -> ID .) ]
  ! COLON           [ reduce using rule 102 (variable -> ID .) ]
  ! BRACECLOSE      [ reduce using rule 102 (variable -> ID .) ]
  ! TO              [ reduce using rule 102 (variable -> ID .) ]

    generarERA                     shift and go to state 116
    empty                          shift and go to state 118

state 126

    (93) factor -> CTEINT . guardarConstanteInt
    (99) guardarConstanteInt -> . empty
    (141) empty -> .

    MULTIPLY        reduce using rule 141 (empty -> .)
    DIVIDE          reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    GREATHERTHAN    reduce using rule 141 (empty -> .)
    LESSTHAN        reduce using rule 141 (empty -> .)
    GREATHEREQUAL   reduce using rule 141 (empty -> .)
    LESSEQUAL       reduce using rule 141 (empty -> .)
    DIFFERENT       reduce using rule 141 (empty -> .)
    SAME            reduce using rule 141 (empty -> .)
    SEMICOLON       reduce using rule 141 (empty -> .)
    AND             reduce using rule 141 (empty -> .)
    OR              reduce using rule 141 (empty -> .)
    PARENCLOSE      reduce using rule 141 (empty -> .)
    COLON           reduce using rule 141 (empty -> .)
    BRACECLOSE      reduce using rule 141 (empty -> .)
    TO              reduce using rule 141 (empty -> .)

    guardarConstanteInt            shift and go to state 173
    empty                          shift and go to state 174

state 127

    (94) factor -> CTFLOAT . guardarConstanteFloat
    (100) guardarConstanteFloat -> . empty
    (141) empty -> .

    MULTIPLY        reduce using rule 141 (empty -> .)
    DIVIDE          reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    GREATHERTHAN    reduce using rule 141 (empty -> .)
    LESSTHAN        reduce using rule 141 (empty -> .)
    GREATHEREQUAL   reduce using rule 141 (empty -> .)
    LESSEQUAL       reduce using rule 141 (empty -> .)
    DIFFERENT       reduce using rule 141 (empty -> .)
    SAME            reduce using rule 141 (empty -> .)
    SEMICOLON       reduce using rule 141 (empty -> .)
    AND             reduce using rule 141 (empty -> .)
    OR              reduce using rule 141 (empty -> .)
    PARENCLOSE      reduce using rule 141 (empty -> .)
    COLON           reduce using rule 141 (empty -> .)
    BRACECLOSE      reduce using rule 141 (empty -> .)
    TO              reduce using rule 141 (empty -> .)

    guardarConstanteFloat          shift and go to state 175
    empty                          shift and go to state 176

state 128

    (95) factor -> CTECHAR . guardarConstanteChar
    (101) guardarConstanteChar -> . empty
    (141) empty -> .

    MULTIPLY        reduce using rule 141 (empty -> .)
    DIVIDE          reduce using rule 141 (empty -> .)
    PLUS            reduce using rule 141 (empty -> .)
    MINUS           reduce using rule 141 (empty -> .)
    GREATHERTHAN    reduce using rule 141 (empty -> .)
    LESSTHAN        reduce using rule 141 (empty -> .)
    GREATHEREQUAL   reduce using rule 141 (empty -> .)
    LESSEQUAL       reduce using rule 141 (empty -> .)
    DIFFERENT       reduce using rule 141 (empty -> .)
    SAME            reduce using rule 141 (empty -> .)
    SEMICOLON       reduce using rule 141 (empty -> .)
    AND             reduce using rule 141 (empty -> .)
    OR              reduce using rule 141 (empty -> .)
    PARENCLOSE      reduce using rule 141 (empty -> .)
    COLON           reduce using rule 141 (empty -> .)
    BRACECLOSE      reduce using rule 141 (empty -> .)
    TO              reduce using rule 141 (empty -> .)

    guardarConstanteChar           shift and go to state 177
    empty                          shift and go to state 178

state 129

    (96) factor -> variable .

    MULTIPLY        reduce using rule 96 (factor -> variable .)
    DIVIDE          reduce using rule 96 (factor -> variable .)
    PLUS            reduce using rule 96 (factor -> variable .)
    MINUS           reduce using rule 96 (factor -> variable .)
    GREATHERTHAN    reduce using rule 96 (factor -> variable .)
    LESSTHAN        reduce using rule 96 (factor -> variable .)
    GREATHEREQUAL   reduce using rule 96 (factor -> variable .)
    LESSEQUAL       reduce using rule 96 (factor -> variable .)
    DIFFERENT       reduce using rule 96 (factor -> variable .)
    SAME            reduce using rule 96 (factor -> variable .)
    SEMICOLON       reduce using rule 96 (factor -> variable .)
    AND             reduce using rule 96 (factor -> variable .)
    OR              reduce using rule 96 (factor -> variable .)
    PARENCLOSE      reduce using rule 96 (factor -> variable .)
    COLON           reduce using rule 96 (factor -> variable .)
    BRACECLOSE      reduce using rule 96 (factor -> variable .)
    TO              reduce using rule 96 (factor -> variable .)


state 130

    (97) factor -> call_func .

    MULTIPLY        reduce using rule 97 (factor -> call_func .)
    DIVIDE          reduce using rule 97 (factor -> call_func .)
    PLUS            reduce using rule 97 (factor -> call_func .)
    MINUS           reduce using rule 97 (factor -> call_func .)
    GREATHERTHAN    reduce using rule 97 (factor -> call_func .)
    LESSTHAN        reduce using rule 97 (factor -> call_func .)
    GREATHEREQUAL   reduce using rule 97 (factor -> call_func .)
    LESSEQUAL       reduce using rule 97 (factor -> call_func .)
    DIFFERENT       reduce using rule 97 (factor -> call_func .)
    SAME            reduce using rule 97 (factor -> call_func .)
    SEMICOLON       reduce using rule 97 (factor -> call_func .)
    AND             reduce using rule 97 (factor -> call_func .)
    OR              reduce using rule 97 (factor -> call_func .)
    PARENCLOSE      reduce using rule 97 (factor -> call_func .)
    COLON           reduce using rule 97 (factor -> call_func .)
    BRACECLOSE      reduce using rule 97 (factor -> call_func .)
    TO              reduce using rule 97 (factor -> call_func .)


state 131

    (98) factor -> PARENOPEN . exp PARENCLOSE
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 179
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 132

    (123) while_loop -> WHILE whileMigaja . PARENOPEN exp PARENCLOSE whileEval body whileEnd

    PARENOPEN       shift and go to state 180


state 133

    (124) whileMigaja -> empty .

    PARENOPEN       reduce using rule 124 (whileMigaja -> empty .)


state 134

    (127) for_loop -> FOR PARENOPEN . ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd

    ID              shift and go to state 181


state 135

    (132) max -> MAX PARENOPEN . exp PARENCLOSE SEMICOLON
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 182
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 136

    (133) min -> MIN PARENOPEN . exp PARENCLOSE SEMICOLON
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 183
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 137

    (134) sum -> SUM PARENOPEN . exp PARENCLOSE SEMICOLON
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 184
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 138

    (140) normal -> NORMAL PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (135) param_dist -> . variable
    (136) param_dist -> . variable COLON param_dist
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 115

    param_dist                     shift and go to state 185
    variable                       shift and go to state 186

state 139

    (139) uniforme -> UNIFORME PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (135) param_dist -> . variable
    (136) param_dist -> . variable COLON param_dist
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 115

    param_dist                     shift and go to state 187
    variable                       shift and go to state 186

state 140

    (138) poisson -> POISSON PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (135) param_dist -> . variable
    (136) param_dist -> . variable COLON param_dist
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 115

    param_dist                     shift and go to state 188
    variable                       shift and go to state 186

state 141

    (137) binomial -> BINOMIAL PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (135) param_dist -> . variable
    (136) param_dist -> . variable COLON param_dist
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 115

    param_dist                     shift and go to state 189
    variable                       shift and go to state 186

state 142

    (60) dec_variabless -> type guardarTipo . dec_mvar SEMICOLON dec_variabless
    (61) dec_variabless -> type guardarTipo . dec_mvar SEMICOLON
    (62) dec_mvar -> . ID guardarID COLON dec_mvar
    (63) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (64) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (65) dec_mvar -> . ID guardarID
    (66) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE
    (67) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 191

    dec_mvar                       shift and go to state 190

state 143

    (23) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE . startFunc body exitFunc
    (33) startFunc -> . empty
    (141) empty -> .

    BRACKETOPEN     reduce using rule 141 (empty -> .)

    startFunc                      shift and go to state 192
    empty                          shift and go to state 193

state 144

    (27) param -> typeParam ID COLON . param
    (26) param -> . typeParam ID
    (27) param -> . typeParam ID COLON param
    (28) param -> . empty
    (29) typeParam -> . INT
    (30) typeParam -> . FLOAT
    (31) typeParam -> . CHAR
    (141) empty -> .

    INT             shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    PARENCLOSE      reduce using rule 141 (empty -> .)

    typeParam                      shift and go to state 57
    param                          shift and go to state 194
    empty                          shift and go to state 58

state 145

    (24) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE . startFunc body exitFunc
    (33) startFunc -> . empty
    (141) empty -> .

    BRACKETOPEN     reduce using rule 141 (empty -> .)

    startFunc                      shift and go to state 195
    empty                          shift and go to state 193

state 146

    (16) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE COLON mvar
    (19) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE

    CTEINT          shift and go to state 196


state 147

    (15) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON . mvar
    (14) mvar -> . ID guardarIDvar COLON mvar
    (15) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (16) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID guardarIDvar
    (18) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE
    (19) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 39

    mvar                           shift and go to state 197

state 148

    (69) assignment -> variableAssignment EQUAL exp . SEMICOLON
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp

    SEMICOLON       shift and go to state 198
    AND             shift and go to state 161
    OR              shift and go to state 162


state 149

    (108) condition -> IF PARENOPEN exp . PARENCLOSE cuadruploIF body ifEnd
    (109) condition -> IF PARENOPEN exp . PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 199
    AND             shift and go to state 161
    OR              shift and go to state 162


state 150

    (114) writing -> PRINT PARENOPEN writingg . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 200


state 151

    (115) writingg -> exp .
    (116) writingg -> exp . COLON writingg
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp

    PARENCLOSE      reduce using rule 115 (writingg -> exp .)
    COLON           shift and go to state 201
    AND             shift and go to state 161
    OR              shift and go to state 162


state 152

    (117) writingg -> auxString .
    (118) writingg -> auxString . COLON writingg

    PARENCLOSE      reduce using rule 117 (writingg -> auxString .)
    COLON           shift and go to state 202


state 153

    (119) auxString -> CTESTRING .

    COLON           reduce using rule 119 (auxString -> CTESTRING .)
    PARENCLOSE      reduce using rule 119 (auxString -> CTESTRING .)


state 154

    (120) reading -> READ multivariables SEMICOLON .

    IF              reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    PRINT           reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    READ            reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    ID              reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    PLOT            reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    RETURN          reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    WHILE           reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    FOR             reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    MAX             reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    MIN             reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    SUM             reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    NORMAL          reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    UNIFORME        reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    POISSON         reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    BINOMIAL        reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    INT             reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    FLOAT           reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    CHAR            reduce using rule 120 (reading -> READ multivariables SEMICOLON .)
    BRACKETCLOSE    reduce using rule 120 (reading -> READ multivariables SEMICOLON .)


state 155

    (122) multivariables -> variable COLON . multivariables
    (121) multivariables -> . variable
    (122) multivariables -> . variable COLON multivariables
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 115

    variable                       shift and go to state 114
    multivariables                 shift and go to state 203

state 156

    (103) variable -> ID BRACEOPEN . exp BRACECLOSE
    (104) variable -> ID BRACEOPEN . exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 204
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 157

    (70) call_func -> ID generarERA PARENOPEN . call_funcc PARENCLOSE
    (72) call_funcc -> . exp mandarParam
    (73) call_funcc -> . exp mandarParam COLON call_funcc
    (74) call_funcc -> . empty
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (141) empty -> .
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    PARENCLOSE      reduce using rule 141 (empty -> .)
    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    call_funcc                     shift and go to state 205
    exp                            shift and go to state 206
    empty                          shift and go to state 207
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 158

    (106) variableAssignment -> ID BRACEOPEN exp . BRACECLOSE
    (107) variableAssignment -> ID BRACEOPEN exp . BRACECLOSE BRACEOPEN exp BRACECLOSE
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp

    BRACECLOSE      shift and go to state 208
    AND             shift and go to state 161
    OR              shift and go to state 162


state 159

    (131) graph -> PLOT PARENOPEN exp . PARENCLOSE SEMICOLON
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 209
    AND             shift and go to state 161
    OR              shift and go to state 162


state 160

    (130) return -> RETURN exp SEMICOLON .

    IF              reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    PRINT           reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    READ            reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    ID              reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    PLOT            reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    RETURN          reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    WHILE           reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    FOR             reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    MAX             reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    MIN             reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    SUM             reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    NORMAL          reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    UNIFORME        reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    POISSON         reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    BINOMIAL        reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    INT             reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    FLOAT           reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    CHAR            reduce using rule 130 (return -> RETURN exp SEMICOLON .)
    BRACKETCLOSE    reduce using rule 130 (return -> RETURN exp SEMICOLON .)


state 161

    (77) exp -> exp AND . expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    expp                           shift and go to state 210
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 162

    (78) exp -> exp OR . expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    expp                           shift and go to state 211
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 163

    (80) expp -> expp GREATHERTHAN . m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    m_exp                          shift and go to state 212
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 164

    (81) expp -> expp LESSTHAN . m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    m_exp                          shift and go to state 213
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 165

    (82) expp -> expp GREATHEREQUAL . m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    m_exp                          shift and go to state 214
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 166

    (83) expp -> expp LESSEQUAL . m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    m_exp                          shift and go to state 215
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 167

    (84) expp -> expp DIFFERENT . m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    m_exp                          shift and go to state 216
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 168

    (85) expp -> expp SAME . m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    m_exp                          shift and go to state 217
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 169

    (87) m_exp -> m_exp PLUS . termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    termino                        shift and go to state 218
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 170

    (88) m_exp -> m_exp MINUS . termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    termino                        shift and go to state 219
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 171

    (90) termino -> termino MULTIPLY . factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    factor                         shift and go to state 220
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 172

    (91) termino -> termino DIVIDE . factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    factor                         shift and go to state 221
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 173

    (93) factor -> CTEINT guardarConstanteInt .

    MULTIPLY        reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)
    DIVIDE          reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)
    PLUS            reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)
    MINUS           reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)
    GREATHERTHAN    reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)
    LESSTHAN        reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)
    GREATHEREQUAL   reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)
    LESSEQUAL       reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)
    DIFFERENT       reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)
    SAME            reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)
    SEMICOLON       reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)
    AND             reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)
    OR              reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)
    PARENCLOSE      reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)
    COLON           reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)
    BRACECLOSE      reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)
    TO              reduce using rule 93 (factor -> CTEINT guardarConstanteInt .)


state 174

    (99) guardarConstanteInt -> empty .

    MULTIPLY        reduce using rule 99 (guardarConstanteInt -> empty .)
    DIVIDE          reduce using rule 99 (guardarConstanteInt -> empty .)
    PLUS            reduce using rule 99 (guardarConstanteInt -> empty .)
    MINUS           reduce using rule 99 (guardarConstanteInt -> empty .)
    GREATHERTHAN    reduce using rule 99 (guardarConstanteInt -> empty .)
    LESSTHAN        reduce using rule 99 (guardarConstanteInt -> empty .)
    GREATHEREQUAL   reduce using rule 99 (guardarConstanteInt -> empty .)
    LESSEQUAL       reduce using rule 99 (guardarConstanteInt -> empty .)
    DIFFERENT       reduce using rule 99 (guardarConstanteInt -> empty .)
    SAME            reduce using rule 99 (guardarConstanteInt -> empty .)
    SEMICOLON       reduce using rule 99 (guardarConstanteInt -> empty .)
    AND             reduce using rule 99 (guardarConstanteInt -> empty .)
    OR              reduce using rule 99 (guardarConstanteInt -> empty .)
    PARENCLOSE      reduce using rule 99 (guardarConstanteInt -> empty .)
    COLON           reduce using rule 99 (guardarConstanteInt -> empty .)
    BRACECLOSE      reduce using rule 99 (guardarConstanteInt -> empty .)
    TO              reduce using rule 99 (guardarConstanteInt -> empty .)


state 175

    (94) factor -> CTFLOAT guardarConstanteFloat .

    MULTIPLY        reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)
    DIVIDE          reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)
    PLUS            reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)
    MINUS           reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)
    GREATHERTHAN    reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)
    LESSTHAN        reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)
    GREATHEREQUAL   reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)
    LESSEQUAL       reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)
    DIFFERENT       reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)
    SAME            reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)
    SEMICOLON       reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)
    AND             reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)
    OR              reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)
    PARENCLOSE      reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)
    COLON           reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)
    BRACECLOSE      reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)
    TO              reduce using rule 94 (factor -> CTFLOAT guardarConstanteFloat .)


state 176

    (100) guardarConstanteFloat -> empty .

    MULTIPLY        reduce using rule 100 (guardarConstanteFloat -> empty .)
    DIVIDE          reduce using rule 100 (guardarConstanteFloat -> empty .)
    PLUS            reduce using rule 100 (guardarConstanteFloat -> empty .)
    MINUS           reduce using rule 100 (guardarConstanteFloat -> empty .)
    GREATHERTHAN    reduce using rule 100 (guardarConstanteFloat -> empty .)
    LESSTHAN        reduce using rule 100 (guardarConstanteFloat -> empty .)
    GREATHEREQUAL   reduce using rule 100 (guardarConstanteFloat -> empty .)
    LESSEQUAL       reduce using rule 100 (guardarConstanteFloat -> empty .)
    DIFFERENT       reduce using rule 100 (guardarConstanteFloat -> empty .)
    SAME            reduce using rule 100 (guardarConstanteFloat -> empty .)
    SEMICOLON       reduce using rule 100 (guardarConstanteFloat -> empty .)
    AND             reduce using rule 100 (guardarConstanteFloat -> empty .)
    OR              reduce using rule 100 (guardarConstanteFloat -> empty .)
    PARENCLOSE      reduce using rule 100 (guardarConstanteFloat -> empty .)
    COLON           reduce using rule 100 (guardarConstanteFloat -> empty .)
    BRACECLOSE      reduce using rule 100 (guardarConstanteFloat -> empty .)
    TO              reduce using rule 100 (guardarConstanteFloat -> empty .)


state 177

    (95) factor -> CTECHAR guardarConstanteChar .

    MULTIPLY        reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)
    DIVIDE          reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)
    PLUS            reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)
    MINUS           reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)
    GREATHERTHAN    reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)
    LESSTHAN        reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)
    GREATHEREQUAL   reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)
    LESSEQUAL       reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)
    DIFFERENT       reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)
    SAME            reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)
    SEMICOLON       reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)
    AND             reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)
    OR              reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)
    PARENCLOSE      reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)
    COLON           reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)
    BRACECLOSE      reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)
    TO              reduce using rule 95 (factor -> CTECHAR guardarConstanteChar .)


state 178

    (101) guardarConstanteChar -> empty .

    MULTIPLY        reduce using rule 101 (guardarConstanteChar -> empty .)
    DIVIDE          reduce using rule 101 (guardarConstanteChar -> empty .)
    PLUS            reduce using rule 101 (guardarConstanteChar -> empty .)
    MINUS           reduce using rule 101 (guardarConstanteChar -> empty .)
    GREATHERTHAN    reduce using rule 101 (guardarConstanteChar -> empty .)
    LESSTHAN        reduce using rule 101 (guardarConstanteChar -> empty .)
    GREATHEREQUAL   reduce using rule 101 (guardarConstanteChar -> empty .)
    LESSEQUAL       reduce using rule 101 (guardarConstanteChar -> empty .)
    DIFFERENT       reduce using rule 101 (guardarConstanteChar -> empty .)
    SAME            reduce using rule 101 (guardarConstanteChar -> empty .)
    SEMICOLON       reduce using rule 101 (guardarConstanteChar -> empty .)
    AND             reduce using rule 101 (guardarConstanteChar -> empty .)
    OR              reduce using rule 101 (guardarConstanteChar -> empty .)
    PARENCLOSE      reduce using rule 101 (guardarConstanteChar -> empty .)
    COLON           reduce using rule 101 (guardarConstanteChar -> empty .)
    BRACECLOSE      reduce using rule 101 (guardarConstanteChar -> empty .)
    TO              reduce using rule 101 (guardarConstanteChar -> empty .)


state 179

    (98) factor -> PARENOPEN exp . PARENCLOSE
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 222
    AND             shift and go to state 161
    OR              shift and go to state 162


state 180

    (123) while_loop -> WHILE whileMigaja PARENOPEN . exp PARENCLOSE whileEval body whileEnd
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 223
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 181

    (127) for_loop -> FOR PARENOPEN ID . EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd

    EQUAL           shift and go to state 224


state 182

    (132) max -> MAX PARENOPEN exp . PARENCLOSE SEMICOLON
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 225
    AND             shift and go to state 161
    OR              shift and go to state 162


state 183

    (133) min -> MIN PARENOPEN exp . PARENCLOSE SEMICOLON
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 226
    AND             shift and go to state 161
    OR              shift and go to state 162


state 184

    (134) sum -> SUM PARENOPEN exp . PARENCLOSE SEMICOLON
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 227
    AND             shift and go to state 161
    OR              shift and go to state 162


state 185

    (140) normal -> NORMAL PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 228


state 186

    (135) param_dist -> variable .
    (136) param_dist -> variable . COLON param_dist

    PARENCLOSE      reduce using rule 135 (param_dist -> variable .)
    COLON           shift and go to state 229


state 187

    (139) uniforme -> UNIFORME PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 230


state 188

    (138) poisson -> POISSON PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 231


state 189

    (137) binomial -> BINOMIAL PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 232


state 190

    (60) dec_variabless -> type guardarTipo dec_mvar . SEMICOLON dec_variabless
    (61) dec_variabless -> type guardarTipo dec_mvar . SEMICOLON

    SEMICOLON       shift and go to state 233


state 191

    (62) dec_mvar -> ID . guardarID COLON dec_mvar
    (63) dec_mvar -> ID . guardarID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (64) dec_mvar -> ID . guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (65) dec_mvar -> ID . guardarID
    (66) dec_mvar -> ID . guardarID BRACEOPEN CTEINT BRACECLOSE
    (67) dec_mvar -> ID . guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE
    (68) guardarID -> . empty
    (141) empty -> .

    COLON           reduce using rule 141 (empty -> .)
    BRACEOPEN       reduce using rule 141 (empty -> .)
    SEMICOLON       reduce using rule 141 (empty -> .)

    guardarID                      shift and go to state 234
    empty                          shift and go to state 235

state 192

    (23) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc . body exitFunc
    (38) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 55

    body                           shift and go to state 236

state 193

    (33) startFunc -> empty .

    BRACKETOPEN     reduce using rule 33 (startFunc -> empty .)


state 194

    (27) param -> typeParam ID COLON param .

    PARENCLOSE      reduce using rule 27 (param -> typeParam ID COLON param .)


state 195

    (24) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc . body exitFunc
    (38) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 55

    body                           shift and go to state 237

state 196

    (16) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE COLON mvar
    (19) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE

    BRACECLOSE      shift and go to state 238


state 197

    (15) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON mvar .

    SEMICOLON       reduce using rule 15 (mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON mvar .)


state 198

    (69) assignment -> variableAssignment EQUAL exp SEMICOLON .

    IF              reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    PRINT           reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    READ            reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    ID              reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    PLOT            reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    RETURN          reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    WHILE           reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    FOR             reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    MAX             reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    MIN             reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    SUM             reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    NORMAL          reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    UNIFORME        reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    POISSON         reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    BINOMIAL        reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    INT             reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    FLOAT           reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    CHAR            reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    BRACKETCLOSE    reduce using rule 69 (assignment -> variableAssignment EQUAL exp SEMICOLON .)


state 199

    (108) condition -> IF PARENOPEN exp PARENCLOSE . cuadruploIF body ifEnd
    (109) condition -> IF PARENOPEN exp PARENCLOSE . cuadruploIF body cuadruploElse ELSE body ifEndElse
    (110) cuadruploIF -> . empty
    (141) empty -> .

    BRACKETOPEN     reduce using rule 141 (empty -> .)

    cuadruploIF                    shift and go to state 239
    empty                          shift and go to state 240

state 200

    (114) writing -> PRINT PARENOPEN writingg PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 241


state 201

    (116) writingg -> exp COLON . writingg
    (115) writingg -> . exp
    (116) writingg -> . exp COLON writingg
    (117) writingg -> . auxString
    (118) writingg -> . auxString COLON writingg
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (119) auxString -> . CTESTRING
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 153
    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 151
    writingg                       shift and go to state 242
    auxString                      shift and go to state 152
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 202

    (118) writingg -> auxString COLON . writingg
    (115) writingg -> . exp
    (116) writingg -> . exp COLON writingg
    (117) writingg -> . auxString
    (118) writingg -> . auxString COLON writingg
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (119) auxString -> . CTESTRING
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 153
    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    auxString                      shift and go to state 152
    writingg                       shift and go to state 243
    exp                            shift and go to state 151
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 203

    (122) multivariables -> variable COLON multivariables .

    SEMICOLON       reduce using rule 122 (multivariables -> variable COLON multivariables .)


state 204

    (103) variable -> ID BRACEOPEN exp . BRACECLOSE
    (104) variable -> ID BRACEOPEN exp . BRACECLOSE BRACEOPEN exp BRACECLOSE
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp

    BRACECLOSE      shift and go to state 244
    AND             shift and go to state 161
    OR              shift and go to state 162


state 205

    (70) call_func -> ID generarERA PARENOPEN call_funcc . PARENCLOSE

    PARENCLOSE      shift and go to state 245


state 206

    (72) call_funcc -> exp . mandarParam
    (73) call_funcc -> exp . mandarParam COLON call_funcc
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp
    (75) mandarParam -> . empty
    (141) empty -> .

    AND             shift and go to state 161
    OR              shift and go to state 162
    COLON           reduce using rule 141 (empty -> .)
    PARENCLOSE      reduce using rule 141 (empty -> .)

    mandarParam                    shift and go to state 246
    empty                          shift and go to state 247

state 207

    (74) call_funcc -> empty .

    PARENCLOSE      reduce using rule 74 (call_funcc -> empty .)


state 208

    (106) variableAssignment -> ID BRACEOPEN exp BRACECLOSE .
    (107) variableAssignment -> ID BRACEOPEN exp BRACECLOSE . BRACEOPEN exp BRACECLOSE

    EQUAL           reduce using rule 106 (variableAssignment -> ID BRACEOPEN exp BRACECLOSE .)
    BRACEOPEN       shift and go to state 248


state 209

    (131) graph -> PLOT PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 249


state 210

    (77) exp -> exp AND expp .
    (80) expp -> expp . GREATHERTHAN m_exp
    (81) expp -> expp . LESSTHAN m_exp
    (82) expp -> expp . GREATHEREQUAL m_exp
    (83) expp -> expp . LESSEQUAL m_exp
    (84) expp -> expp . DIFFERENT m_exp
    (85) expp -> expp . SAME m_exp

    SEMICOLON       reduce using rule 77 (exp -> exp AND expp .)
    AND             reduce using rule 77 (exp -> exp AND expp .)
    OR              reduce using rule 77 (exp -> exp AND expp .)
    PARENCLOSE      reduce using rule 77 (exp -> exp AND expp .)
    COLON           reduce using rule 77 (exp -> exp AND expp .)
    BRACECLOSE      reduce using rule 77 (exp -> exp AND expp .)
    TO              reduce using rule 77 (exp -> exp AND expp .)
    GREATHERTHAN    shift and go to state 163
    LESSTHAN        shift and go to state 164
    GREATHEREQUAL   shift and go to state 165
    LESSEQUAL       shift and go to state 166
    DIFFERENT       shift and go to state 167
    SAME            shift and go to state 168


state 211

    (78) exp -> exp OR expp .
    (80) expp -> expp . GREATHERTHAN m_exp
    (81) expp -> expp . LESSTHAN m_exp
    (82) expp -> expp . GREATHEREQUAL m_exp
    (83) expp -> expp . LESSEQUAL m_exp
    (84) expp -> expp . DIFFERENT m_exp
    (85) expp -> expp . SAME m_exp

    SEMICOLON       reduce using rule 78 (exp -> exp OR expp .)
    AND             reduce using rule 78 (exp -> exp OR expp .)
    OR              reduce using rule 78 (exp -> exp OR expp .)
    PARENCLOSE      reduce using rule 78 (exp -> exp OR expp .)
    COLON           reduce using rule 78 (exp -> exp OR expp .)
    BRACECLOSE      reduce using rule 78 (exp -> exp OR expp .)
    TO              reduce using rule 78 (exp -> exp OR expp .)
    GREATHERTHAN    shift and go to state 163
    LESSTHAN        shift and go to state 164
    GREATHEREQUAL   shift and go to state 165
    LESSEQUAL       shift and go to state 166
    DIFFERENT       shift and go to state 167
    SAME            shift and go to state 168


state 212

    (80) expp -> expp GREATHERTHAN m_exp .
    (87) m_exp -> m_exp . PLUS termino
    (88) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 80 (expp -> expp GREATHERTHAN m_exp .)
    LESSTHAN        reduce using rule 80 (expp -> expp GREATHERTHAN m_exp .)
    GREATHEREQUAL   reduce using rule 80 (expp -> expp GREATHERTHAN m_exp .)
    LESSEQUAL       reduce using rule 80 (expp -> expp GREATHERTHAN m_exp .)
    DIFFERENT       reduce using rule 80 (expp -> expp GREATHERTHAN m_exp .)
    SAME            reduce using rule 80 (expp -> expp GREATHERTHAN m_exp .)
    SEMICOLON       reduce using rule 80 (expp -> expp GREATHERTHAN m_exp .)
    AND             reduce using rule 80 (expp -> expp GREATHERTHAN m_exp .)
    OR              reduce using rule 80 (expp -> expp GREATHERTHAN m_exp .)
    PARENCLOSE      reduce using rule 80 (expp -> expp GREATHERTHAN m_exp .)
    COLON           reduce using rule 80 (expp -> expp GREATHERTHAN m_exp .)
    BRACECLOSE      reduce using rule 80 (expp -> expp GREATHERTHAN m_exp .)
    TO              reduce using rule 80 (expp -> expp GREATHERTHAN m_exp .)
    PLUS            shift and go to state 169
    MINUS           shift and go to state 170


state 213

    (81) expp -> expp LESSTHAN m_exp .
    (87) m_exp -> m_exp . PLUS termino
    (88) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 81 (expp -> expp LESSTHAN m_exp .)
    LESSTHAN        reduce using rule 81 (expp -> expp LESSTHAN m_exp .)
    GREATHEREQUAL   reduce using rule 81 (expp -> expp LESSTHAN m_exp .)
    LESSEQUAL       reduce using rule 81 (expp -> expp LESSTHAN m_exp .)
    DIFFERENT       reduce using rule 81 (expp -> expp LESSTHAN m_exp .)
    SAME            reduce using rule 81 (expp -> expp LESSTHAN m_exp .)
    SEMICOLON       reduce using rule 81 (expp -> expp LESSTHAN m_exp .)
    AND             reduce using rule 81 (expp -> expp LESSTHAN m_exp .)
    OR              reduce using rule 81 (expp -> expp LESSTHAN m_exp .)
    PARENCLOSE      reduce using rule 81 (expp -> expp LESSTHAN m_exp .)
    COLON           reduce using rule 81 (expp -> expp LESSTHAN m_exp .)
    BRACECLOSE      reduce using rule 81 (expp -> expp LESSTHAN m_exp .)
    TO              reduce using rule 81 (expp -> expp LESSTHAN m_exp .)
    PLUS            shift and go to state 169
    MINUS           shift and go to state 170


state 214

    (82) expp -> expp GREATHEREQUAL m_exp .
    (87) m_exp -> m_exp . PLUS termino
    (88) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 82 (expp -> expp GREATHEREQUAL m_exp .)
    LESSTHAN        reduce using rule 82 (expp -> expp GREATHEREQUAL m_exp .)
    GREATHEREQUAL   reduce using rule 82 (expp -> expp GREATHEREQUAL m_exp .)
    LESSEQUAL       reduce using rule 82 (expp -> expp GREATHEREQUAL m_exp .)
    DIFFERENT       reduce using rule 82 (expp -> expp GREATHEREQUAL m_exp .)
    SAME            reduce using rule 82 (expp -> expp GREATHEREQUAL m_exp .)
    SEMICOLON       reduce using rule 82 (expp -> expp GREATHEREQUAL m_exp .)
    AND             reduce using rule 82 (expp -> expp GREATHEREQUAL m_exp .)
    OR              reduce using rule 82 (expp -> expp GREATHEREQUAL m_exp .)
    PARENCLOSE      reduce using rule 82 (expp -> expp GREATHEREQUAL m_exp .)
    COLON           reduce using rule 82 (expp -> expp GREATHEREQUAL m_exp .)
    BRACECLOSE      reduce using rule 82 (expp -> expp GREATHEREQUAL m_exp .)
    TO              reduce using rule 82 (expp -> expp GREATHEREQUAL m_exp .)
    PLUS            shift and go to state 169
    MINUS           shift and go to state 170


state 215

    (83) expp -> expp LESSEQUAL m_exp .
    (87) m_exp -> m_exp . PLUS termino
    (88) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 83 (expp -> expp LESSEQUAL m_exp .)
    LESSTHAN        reduce using rule 83 (expp -> expp LESSEQUAL m_exp .)
    GREATHEREQUAL   reduce using rule 83 (expp -> expp LESSEQUAL m_exp .)
    LESSEQUAL       reduce using rule 83 (expp -> expp LESSEQUAL m_exp .)
    DIFFERENT       reduce using rule 83 (expp -> expp LESSEQUAL m_exp .)
    SAME            reduce using rule 83 (expp -> expp LESSEQUAL m_exp .)
    SEMICOLON       reduce using rule 83 (expp -> expp LESSEQUAL m_exp .)
    AND             reduce using rule 83 (expp -> expp LESSEQUAL m_exp .)
    OR              reduce using rule 83 (expp -> expp LESSEQUAL m_exp .)
    PARENCLOSE      reduce using rule 83 (expp -> expp LESSEQUAL m_exp .)
    COLON           reduce using rule 83 (expp -> expp LESSEQUAL m_exp .)
    BRACECLOSE      reduce using rule 83 (expp -> expp LESSEQUAL m_exp .)
    TO              reduce using rule 83 (expp -> expp LESSEQUAL m_exp .)
    PLUS            shift and go to state 169
    MINUS           shift and go to state 170


state 216

    (84) expp -> expp DIFFERENT m_exp .
    (87) m_exp -> m_exp . PLUS termino
    (88) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 84 (expp -> expp DIFFERENT m_exp .)
    LESSTHAN        reduce using rule 84 (expp -> expp DIFFERENT m_exp .)
    GREATHEREQUAL   reduce using rule 84 (expp -> expp DIFFERENT m_exp .)
    LESSEQUAL       reduce using rule 84 (expp -> expp DIFFERENT m_exp .)
    DIFFERENT       reduce using rule 84 (expp -> expp DIFFERENT m_exp .)
    SAME            reduce using rule 84 (expp -> expp DIFFERENT m_exp .)
    SEMICOLON       reduce using rule 84 (expp -> expp DIFFERENT m_exp .)
    AND             reduce using rule 84 (expp -> expp DIFFERENT m_exp .)
    OR              reduce using rule 84 (expp -> expp DIFFERENT m_exp .)
    PARENCLOSE      reduce using rule 84 (expp -> expp DIFFERENT m_exp .)
    COLON           reduce using rule 84 (expp -> expp DIFFERENT m_exp .)
    BRACECLOSE      reduce using rule 84 (expp -> expp DIFFERENT m_exp .)
    TO              reduce using rule 84 (expp -> expp DIFFERENT m_exp .)
    PLUS            shift and go to state 169
    MINUS           shift and go to state 170


state 217

    (85) expp -> expp SAME m_exp .
    (87) m_exp -> m_exp . PLUS termino
    (88) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 85 (expp -> expp SAME m_exp .)
    LESSTHAN        reduce using rule 85 (expp -> expp SAME m_exp .)
    GREATHEREQUAL   reduce using rule 85 (expp -> expp SAME m_exp .)
    LESSEQUAL       reduce using rule 85 (expp -> expp SAME m_exp .)
    DIFFERENT       reduce using rule 85 (expp -> expp SAME m_exp .)
    SAME            reduce using rule 85 (expp -> expp SAME m_exp .)
    SEMICOLON       reduce using rule 85 (expp -> expp SAME m_exp .)
    AND             reduce using rule 85 (expp -> expp SAME m_exp .)
    OR              reduce using rule 85 (expp -> expp SAME m_exp .)
    PARENCLOSE      reduce using rule 85 (expp -> expp SAME m_exp .)
    COLON           reduce using rule 85 (expp -> expp SAME m_exp .)
    BRACECLOSE      reduce using rule 85 (expp -> expp SAME m_exp .)
    TO              reduce using rule 85 (expp -> expp SAME m_exp .)
    PLUS            shift and go to state 169
    MINUS           shift and go to state 170


state 218

    (87) m_exp -> m_exp PLUS termino .
    (90) termino -> termino . MULTIPLY factor
    (91) termino -> termino . DIVIDE factor

    PLUS            reduce using rule 87 (m_exp -> m_exp PLUS termino .)
    MINUS           reduce using rule 87 (m_exp -> m_exp PLUS termino .)
    GREATHERTHAN    reduce using rule 87 (m_exp -> m_exp PLUS termino .)
    LESSTHAN        reduce using rule 87 (m_exp -> m_exp PLUS termino .)
    GREATHEREQUAL   reduce using rule 87 (m_exp -> m_exp PLUS termino .)
    LESSEQUAL       reduce using rule 87 (m_exp -> m_exp PLUS termino .)
    DIFFERENT       reduce using rule 87 (m_exp -> m_exp PLUS termino .)
    SAME            reduce using rule 87 (m_exp -> m_exp PLUS termino .)
    SEMICOLON       reduce using rule 87 (m_exp -> m_exp PLUS termino .)
    AND             reduce using rule 87 (m_exp -> m_exp PLUS termino .)
    OR              reduce using rule 87 (m_exp -> m_exp PLUS termino .)
    PARENCLOSE      reduce using rule 87 (m_exp -> m_exp PLUS termino .)
    COLON           reduce using rule 87 (m_exp -> m_exp PLUS termino .)
    BRACECLOSE      reduce using rule 87 (m_exp -> m_exp PLUS termino .)
    TO              reduce using rule 87 (m_exp -> m_exp PLUS termino .)
    MULTIPLY        shift and go to state 171
    DIVIDE          shift and go to state 172


state 219

    (88) m_exp -> m_exp MINUS termino .
    (90) termino -> termino . MULTIPLY factor
    (91) termino -> termino . DIVIDE factor

    PLUS            reduce using rule 88 (m_exp -> m_exp MINUS termino .)
    MINUS           reduce using rule 88 (m_exp -> m_exp MINUS termino .)
    GREATHERTHAN    reduce using rule 88 (m_exp -> m_exp MINUS termino .)
    LESSTHAN        reduce using rule 88 (m_exp -> m_exp MINUS termino .)
    GREATHEREQUAL   reduce using rule 88 (m_exp -> m_exp MINUS termino .)
    LESSEQUAL       reduce using rule 88 (m_exp -> m_exp MINUS termino .)
    DIFFERENT       reduce using rule 88 (m_exp -> m_exp MINUS termino .)
    SAME            reduce using rule 88 (m_exp -> m_exp MINUS termino .)
    SEMICOLON       reduce using rule 88 (m_exp -> m_exp MINUS termino .)
    AND             reduce using rule 88 (m_exp -> m_exp MINUS termino .)
    OR              reduce using rule 88 (m_exp -> m_exp MINUS termino .)
    PARENCLOSE      reduce using rule 88 (m_exp -> m_exp MINUS termino .)
    COLON           reduce using rule 88 (m_exp -> m_exp MINUS termino .)
    BRACECLOSE      reduce using rule 88 (m_exp -> m_exp MINUS termino .)
    TO              reduce using rule 88 (m_exp -> m_exp MINUS termino .)
    MULTIPLY        shift and go to state 171
    DIVIDE          shift and go to state 172


state 220

    (90) termino -> termino MULTIPLY factor .

    MULTIPLY        reduce using rule 90 (termino -> termino MULTIPLY factor .)
    DIVIDE          reduce using rule 90 (termino -> termino MULTIPLY factor .)
    PLUS            reduce using rule 90 (termino -> termino MULTIPLY factor .)
    MINUS           reduce using rule 90 (termino -> termino MULTIPLY factor .)
    GREATHERTHAN    reduce using rule 90 (termino -> termino MULTIPLY factor .)
    LESSTHAN        reduce using rule 90 (termino -> termino MULTIPLY factor .)
    GREATHEREQUAL   reduce using rule 90 (termino -> termino MULTIPLY factor .)
    LESSEQUAL       reduce using rule 90 (termino -> termino MULTIPLY factor .)
    DIFFERENT       reduce using rule 90 (termino -> termino MULTIPLY factor .)
    SAME            reduce using rule 90 (termino -> termino MULTIPLY factor .)
    SEMICOLON       reduce using rule 90 (termino -> termino MULTIPLY factor .)
    AND             reduce using rule 90 (termino -> termino MULTIPLY factor .)
    OR              reduce using rule 90 (termino -> termino MULTIPLY factor .)
    PARENCLOSE      reduce using rule 90 (termino -> termino MULTIPLY factor .)
    COLON           reduce using rule 90 (termino -> termino MULTIPLY factor .)
    BRACECLOSE      reduce using rule 90 (termino -> termino MULTIPLY factor .)
    TO              reduce using rule 90 (termino -> termino MULTIPLY factor .)


state 221

    (91) termino -> termino DIVIDE factor .

    MULTIPLY        reduce using rule 91 (termino -> termino DIVIDE factor .)
    DIVIDE          reduce using rule 91 (termino -> termino DIVIDE factor .)
    PLUS            reduce using rule 91 (termino -> termino DIVIDE factor .)
    MINUS           reduce using rule 91 (termino -> termino DIVIDE factor .)
    GREATHERTHAN    reduce using rule 91 (termino -> termino DIVIDE factor .)
    LESSTHAN        reduce using rule 91 (termino -> termino DIVIDE factor .)
    GREATHEREQUAL   reduce using rule 91 (termino -> termino DIVIDE factor .)
    LESSEQUAL       reduce using rule 91 (termino -> termino DIVIDE factor .)
    DIFFERENT       reduce using rule 91 (termino -> termino DIVIDE factor .)
    SAME            reduce using rule 91 (termino -> termino DIVIDE factor .)
    SEMICOLON       reduce using rule 91 (termino -> termino DIVIDE factor .)
    AND             reduce using rule 91 (termino -> termino DIVIDE factor .)
    OR              reduce using rule 91 (termino -> termino DIVIDE factor .)
    PARENCLOSE      reduce using rule 91 (termino -> termino DIVIDE factor .)
    COLON           reduce using rule 91 (termino -> termino DIVIDE factor .)
    BRACECLOSE      reduce using rule 91 (termino -> termino DIVIDE factor .)
    TO              reduce using rule 91 (termino -> termino DIVIDE factor .)


state 222

    (98) factor -> PARENOPEN exp PARENCLOSE .

    MULTIPLY        reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)
    DIVIDE          reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)
    PLUS            reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)
    MINUS           reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)
    GREATHERTHAN    reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)
    LESSTHAN        reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)
    GREATHEREQUAL   reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)
    LESSEQUAL       reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)
    DIFFERENT       reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)
    SAME            reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)
    SEMICOLON       reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)
    AND             reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)
    OR              reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)
    PARENCLOSE      reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)
    COLON           reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)
    BRACECLOSE      reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)
    TO              reduce using rule 98 (factor -> PARENOPEN exp PARENCLOSE .)


state 223

    (123) while_loop -> WHILE whileMigaja PARENOPEN exp . PARENCLOSE whileEval body whileEnd
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 250
    AND             shift and go to state 161
    OR              shift and go to state 162


state 224

    (127) for_loop -> FOR PARENOPEN ID EQUAL . exp guardarValorFor TO exp PARENCLOSE body forEnd
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 251
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 225

    (132) max -> MAX PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 252


state 226

    (133) min -> MIN PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 253


state 227

    (134) sum -> SUM PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 254


state 228

    (140) normal -> NORMAL PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 255


state 229

    (136) param_dist -> variable COLON . param_dist
    (135) param_dist -> . variable
    (136) param_dist -> . variable COLON param_dist
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 115

    variable                       shift and go to state 186
    param_dist                     shift and go to state 256

state 230

    (139) uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 257


state 231

    (138) poisson -> POISSON PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 258


state 232

    (137) binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 259


state 233

    (60) dec_variabless -> type guardarTipo dec_mvar SEMICOLON . dec_variabless
    (61) dec_variabless -> type guardarTipo dec_mvar SEMICOLON .
    (60) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON dec_variabless
    (61) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON
    (35) type -> . INT
    (36) type -> . FLOAT
    (37) type -> . CHAR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    IF              reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    PRINT           reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    READ            reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    ID              reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    PLOT            reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    RETURN          reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    WHILE           reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    FOR             reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    MAX             reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    MIN             reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    SUM             reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    NORMAL          reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    UNIFORME        reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    POISSON         reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    BINOMIAL        reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    BRACKETCLOSE    reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

  ! INT             [ reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .) ]
  ! CHAR            [ reduce using rule 61 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .) ]

    type                           shift and go to state 102
    dec_variabless                 shift and go to state 260

state 234

    (62) dec_mvar -> ID guardarID . COLON dec_mvar
    (63) dec_mvar -> ID guardarID . BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (64) dec_mvar -> ID guardarID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (65) dec_mvar -> ID guardarID .
    (66) dec_mvar -> ID guardarID . BRACEOPEN CTEINT BRACECLOSE
    (67) dec_mvar -> ID guardarID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 261
    BRACEOPEN       shift and go to state 262
    SEMICOLON       reduce using rule 65 (dec_mvar -> ID guardarID .)


state 235

    (68) guardarID -> empty .

    COLON           reduce using rule 68 (guardarID -> empty .)
    BRACEOPEN       reduce using rule 68 (guardarID -> empty .)
    SEMICOLON       reduce using rule 68 (guardarID -> empty .)


state 236

    (23) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body . exitFunc
    (34) exitFunc -> . empty
    (141) empty -> .

    FUNCTION        reduce using rule 141 (empty -> .)
    MAIN            reduce using rule 141 (empty -> .)

    exitFunc                       shift and go to state 263
    empty                          shift and go to state 264

state 237

    (24) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body . exitFunc
    (34) exitFunc -> . empty
    (141) empty -> .

    FUNCTION        reduce using rule 141 (empty -> .)
    MAIN            reduce using rule 141 (empty -> .)

    exitFunc                       shift and go to state 265
    empty                          shift and go to state 264

state 238

    (16) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE . COLON mvar
    (19) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .

    COLON           shift and go to state 266
    SEMICOLON       reduce using rule 19 (mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .)


state 239

    (108) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF . body ifEnd
    (109) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF . body cuadruploElse ELSE body ifEndElse
    (38) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 55

    body                           shift and go to state 267

state 240

    (110) cuadruploIF -> empty .

    BRACKETOPEN     reduce using rule 110 (cuadruploIF -> empty .)


state 241

    (114) writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .

    IF              reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    READ            reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    ID              reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    INT             reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 114 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)


state 242

    (116) writingg -> exp COLON writingg .

    PARENCLOSE      reduce using rule 116 (writingg -> exp COLON writingg .)


state 243

    (118) writingg -> auxString COLON writingg .

    PARENCLOSE      reduce using rule 118 (writingg -> auxString COLON writingg .)


state 244

    (103) variable -> ID BRACEOPEN exp BRACECLOSE .
    (104) variable -> ID BRACEOPEN exp BRACECLOSE . BRACEOPEN exp BRACECLOSE

    COLON           reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    SEMICOLON       reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    MULTIPLY        reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    DIVIDE          reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    PLUS            reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    MINUS           reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    GREATHERTHAN    reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    LESSTHAN        reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    GREATHEREQUAL   reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    LESSEQUAL       reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    DIFFERENT       reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    SAME            reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    AND             reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    OR              reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    PARENCLOSE      reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    BRACECLOSE      reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    TO              reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    BRACEOPEN       shift and go to state 268


state 245

    (70) call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .

    IF              reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    PRINT           reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    READ            reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    ID              reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    PLOT            reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    RETURN          reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    WHILE           reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    FOR             reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    MAX             reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    MIN             reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    SUM             reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    NORMAL          reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    UNIFORME        reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    POISSON         reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    BINOMIAL        reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    INT             reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    FLOAT           reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    CHAR            reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    BRACKETCLOSE    reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    MULTIPLY        reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    DIVIDE          reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    PLUS            reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    MINUS           reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    GREATHERTHAN    reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    LESSTHAN        reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    GREATHEREQUAL   reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    LESSEQUAL       reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    DIFFERENT       reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    SAME            reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    SEMICOLON       reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    AND             reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    OR              reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    PARENCLOSE      reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    COLON           reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    BRACECLOSE      reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    TO              reduce using rule 70 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)


state 246

    (72) call_funcc -> exp mandarParam .
    (73) call_funcc -> exp mandarParam . COLON call_funcc

    PARENCLOSE      reduce using rule 72 (call_funcc -> exp mandarParam .)
    COLON           shift and go to state 269


state 247

    (75) mandarParam -> empty .

    COLON           reduce using rule 75 (mandarParam -> empty .)
    PARENCLOSE      reduce using rule 75 (mandarParam -> empty .)


state 248

    (107) variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN . exp BRACECLOSE
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 270
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 249

    (131) graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 131 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)


state 250

    (123) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE . whileEval body whileEnd
    (125) whileEval -> . empty
    (141) empty -> .

    BRACKETOPEN     reduce using rule 141 (empty -> .)

    whileEval                      shift and go to state 271
    empty                          shift and go to state 272

state 251

    (127) for_loop -> FOR PARENOPEN ID EQUAL exp . guardarValorFor TO exp PARENCLOSE body forEnd
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp
    (128) guardarValorFor -> . empty
    (141) empty -> .

    AND             shift and go to state 161
    OR              shift and go to state 162
    TO              reduce using rule 141 (empty -> .)

    guardarValorFor                shift and go to state 273
    empty                          shift and go to state 274

state 252

    (132) max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 132 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)


state 253

    (133) min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 133 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)


state 254

    (134) sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 134 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)


state 255

    (140) normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 140 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 256

    (136) param_dist -> variable COLON param_dist .

    PARENCLOSE      reduce using rule 136 (param_dist -> variable COLON param_dist .)


state 257

    (139) uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 139 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 258

    (138) poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 138 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 259

    (137) binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 137 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 260

    (60) dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .

    IF              reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    PRINT           reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    READ            reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    ID              reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    PLOT            reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    RETURN          reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    WHILE           reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    FOR             reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    MAX             reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    MIN             reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    SUM             reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    NORMAL          reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    UNIFORME        reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    POISSON         reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    BINOMIAL        reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    INT             reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    FLOAT           reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    CHAR            reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    BRACKETCLOSE    reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)


state 261

    (62) dec_mvar -> ID guardarID COLON . dec_mvar
    (62) dec_mvar -> . ID guardarID COLON dec_mvar
    (63) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (64) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (65) dec_mvar -> . ID guardarID
    (66) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE
    (67) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 191

    dec_mvar                       shift and go to state 275

state 262

    (63) dec_mvar -> ID guardarID BRACEOPEN . CTEINT BRACECLOSE COLON dec_mvar
    (64) dec_mvar -> ID guardarID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (66) dec_mvar -> ID guardarID BRACEOPEN . CTEINT BRACECLOSE
    (67) dec_mvar -> ID guardarID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    CTEINT          shift and go to state 276


state 263

    (23) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc .

    FUNCTION        reduce using rule 23 (dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc .)
    MAIN            reduce using rule 23 (dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc .)


state 264

    (34) exitFunc -> empty .

    FUNCTION        reduce using rule 34 (exitFunc -> empty .)
    MAIN            reduce using rule 34 (exitFunc -> empty .)


state 265

    (24) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc .

    FUNCTION        reduce using rule 24 (dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc .)
    MAIN            reduce using rule 24 (dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc .)


state 266

    (16) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON . mvar
    (14) mvar -> . ID guardarIDvar COLON mvar
    (15) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (16) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID guardarIDvar
    (18) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE
    (19) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 39

    mvar                           shift and go to state 277

state 267

    (108) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body . ifEnd
    (109) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body . cuadruploElse ELSE body ifEndElse
    (111) ifEnd -> . empty
    (112) cuadruploElse -> . empty
    (141) empty -> .

    IF              reduce using rule 141 (empty -> .)
    PRINT           reduce using rule 141 (empty -> .)
    READ            reduce using rule 141 (empty -> .)
    ID              reduce using rule 141 (empty -> .)
    PLOT            reduce using rule 141 (empty -> .)
    RETURN          reduce using rule 141 (empty -> .)
    WHILE           reduce using rule 141 (empty -> .)
    FOR             reduce using rule 141 (empty -> .)
    MAX             reduce using rule 141 (empty -> .)
    MIN             reduce using rule 141 (empty -> .)
    SUM             reduce using rule 141 (empty -> .)
    NORMAL          reduce using rule 141 (empty -> .)
    UNIFORME        reduce using rule 141 (empty -> .)
    POISSON         reduce using rule 141 (empty -> .)
    BINOMIAL        reduce using rule 141 (empty -> .)
    INT             reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    CHAR            reduce using rule 141 (empty -> .)
    BRACKETCLOSE    reduce using rule 141 (empty -> .)
    ELSE            reduce using rule 141 (empty -> .)

    ifEnd                          shift and go to state 278
    cuadruploElse                  shift and go to state 279
    empty                          shift and go to state 280

state 268

    (104) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN . exp BRACECLOSE
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 281
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 269

    (73) call_funcc -> exp mandarParam COLON . call_funcc
    (72) call_funcc -> . exp mandarParam
    (73) call_funcc -> . exp mandarParam COLON call_funcc
    (74) call_funcc -> . empty
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (141) empty -> .
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    PARENCLOSE      reduce using rule 141 (empty -> .)
    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 206
    call_funcc                     shift and go to state 282
    empty                          shift and go to state 207
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 270

    (107) variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp . BRACECLOSE
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp

    BRACECLOSE      shift and go to state 283
    AND             shift and go to state 161
    OR              shift and go to state 162


state 271

    (123) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval . body whileEnd
    (38) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 55

    body                           shift and go to state 284

state 272

    (125) whileEval -> empty .

    BRACKETOPEN     reduce using rule 125 (whileEval -> empty .)


state 273

    (127) for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor . TO exp PARENCLOSE body forEnd

    TO              shift and go to state 285


state 274

    (128) guardarValorFor -> empty .

    TO              reduce using rule 128 (guardarValorFor -> empty .)


state 275

    (62) dec_mvar -> ID guardarID COLON dec_mvar .

    SEMICOLON       reduce using rule 62 (dec_mvar -> ID guardarID COLON dec_mvar .)


state 276

    (63) dec_mvar -> ID guardarID BRACEOPEN CTEINT . BRACECLOSE COLON dec_mvar
    (64) dec_mvar -> ID guardarID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (66) dec_mvar -> ID guardarID BRACEOPEN CTEINT . BRACECLOSE
    (67) dec_mvar -> ID guardarID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    BRACECLOSE      shift and go to state 286


state 277

    (16) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar .

    SEMICOLON       reduce using rule 16 (mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar .)


state 278

    (108) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .

    IF              reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    PRINT           reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    READ            reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    ID              reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    PLOT            reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    RETURN          reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    WHILE           reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    FOR             reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    MAX             reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    MIN             reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    SUM             reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    NORMAL          reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    UNIFORME        reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    POISSON         reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    BINOMIAL        reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    INT             reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    FLOAT           reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    CHAR            reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    BRACKETCLOSE    reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)


state 279

    (109) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse . ELSE body ifEndElse

    ELSE            shift and go to state 287


state 280

    (111) ifEnd -> empty .
    (112) cuadruploElse -> empty .

    IF              reduce using rule 111 (ifEnd -> empty .)
    PRINT           reduce using rule 111 (ifEnd -> empty .)
    READ            reduce using rule 111 (ifEnd -> empty .)
    ID              reduce using rule 111 (ifEnd -> empty .)
    PLOT            reduce using rule 111 (ifEnd -> empty .)
    RETURN          reduce using rule 111 (ifEnd -> empty .)
    WHILE           reduce using rule 111 (ifEnd -> empty .)
    FOR             reduce using rule 111 (ifEnd -> empty .)
    MAX             reduce using rule 111 (ifEnd -> empty .)
    MIN             reduce using rule 111 (ifEnd -> empty .)
    SUM             reduce using rule 111 (ifEnd -> empty .)
    NORMAL          reduce using rule 111 (ifEnd -> empty .)
    UNIFORME        reduce using rule 111 (ifEnd -> empty .)
    POISSON         reduce using rule 111 (ifEnd -> empty .)
    BINOMIAL        reduce using rule 111 (ifEnd -> empty .)
    INT             reduce using rule 111 (ifEnd -> empty .)
    FLOAT           reduce using rule 111 (ifEnd -> empty .)
    CHAR            reduce using rule 111 (ifEnd -> empty .)
    BRACKETCLOSE    reduce using rule 111 (ifEnd -> empty .)
    ELSE            reduce using rule 112 (cuadruploElse -> empty .)


state 281

    (104) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp . BRACECLOSE
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp

    BRACECLOSE      shift and go to state 288
    AND             shift and go to state 161
    OR              shift and go to state 162


state 282

    (73) call_funcc -> exp mandarParam COLON call_funcc .

    PARENCLOSE      reduce using rule 73 (call_funcc -> exp mandarParam COLON call_funcc .)


state 283

    (107) variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .

    EQUAL           reduce using rule 107 (variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)


state 284

    (123) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body . whileEnd
    (126) whileEnd -> . empty
    (141) empty -> .

    IF              reduce using rule 141 (empty -> .)
    PRINT           reduce using rule 141 (empty -> .)
    READ            reduce using rule 141 (empty -> .)
    ID              reduce using rule 141 (empty -> .)
    PLOT            reduce using rule 141 (empty -> .)
    RETURN          reduce using rule 141 (empty -> .)
    WHILE           reduce using rule 141 (empty -> .)
    FOR             reduce using rule 141 (empty -> .)
    MAX             reduce using rule 141 (empty -> .)
    MIN             reduce using rule 141 (empty -> .)
    SUM             reduce using rule 141 (empty -> .)
    NORMAL          reduce using rule 141 (empty -> .)
    UNIFORME        reduce using rule 141 (empty -> .)
    POISSON         reduce using rule 141 (empty -> .)
    BINOMIAL        reduce using rule 141 (empty -> .)
    INT             reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    CHAR            reduce using rule 141 (empty -> .)
    BRACKETCLOSE    reduce using rule 141 (empty -> .)

    whileEnd                       shift and go to state 289
    empty                          shift and go to state 290

state 285

    (127) for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO . exp PARENCLOSE body forEnd
    (76) exp -> . expp
    (77) exp -> . exp AND expp
    (78) exp -> . exp OR expp
    (79) expp -> . m_exp
    (80) expp -> . expp GREATHERTHAN m_exp
    (81) expp -> . expp LESSTHAN m_exp
    (82) expp -> . expp GREATHEREQUAL m_exp
    (83) expp -> . expp LESSEQUAL m_exp
    (84) expp -> . expp DIFFERENT m_exp
    (85) expp -> . expp SAME m_exp
    (86) m_exp -> . termino
    (87) m_exp -> . m_exp PLUS termino
    (88) m_exp -> . m_exp MINUS termino
    (89) termino -> . factor
    (90) termino -> . termino MULTIPLY factor
    (91) termino -> . termino DIVIDE factor
    (92) factor -> . ID
    (93) factor -> . CTEINT guardarConstanteInt
    (94) factor -> . CTFLOAT guardarConstanteFloat
    (95) factor -> . CTECHAR guardarConstanteChar
    (96) factor -> . variable
    (97) factor -> . call_func
    (98) factor -> . PARENOPEN exp PARENCLOSE
    (102) variable -> . ID
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE
    (104) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 125
    CTEINT          shift and go to state 126
    CTFLOAT         shift and go to state 127
    CTECHAR         shift and go to state 128
    PARENOPEN       shift and go to state 131

    exp                            shift and go to state 291
    expp                           shift and go to state 121
    m_exp                          shift and go to state 122
    termino                        shift and go to state 123
    factor                         shift and go to state 124
    variable                       shift and go to state 129
    call_func                      shift and go to state 130

state 286

    (63) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE . COLON dec_mvar
    (64) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (66) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE .
    (67) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 293
    BRACEOPEN       shift and go to state 292
    SEMICOLON       reduce using rule 66 (dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE .)


state 287

    (109) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE . body ifEndElse
    (38) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 55

    body                           shift and go to state 294

state 288

    (104) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .

    COLON           reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    SEMICOLON       reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    MULTIPLY        reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    DIVIDE          reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    PLUS            reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    MINUS           reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    GREATHERTHAN    reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    LESSTHAN        reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    GREATHEREQUAL   reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    LESSEQUAL       reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    DIFFERENT       reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    SAME            reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    AND             reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    OR              reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    PARENCLOSE      reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    BRACECLOSE      reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    TO              reduce using rule 104 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)


state 289

    (123) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .

    IF              reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    PRINT           reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    READ            reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    ID              reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    PLOT            reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    RETURN          reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    WHILE           reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    FOR             reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    MAX             reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    MIN             reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    SUM             reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    NORMAL          reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    UNIFORME        reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    POISSON         reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    BINOMIAL        reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    INT             reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    FLOAT           reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    CHAR            reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    BRACKETCLOSE    reduce using rule 123 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)


state 290

    (126) whileEnd -> empty .

    IF              reduce using rule 126 (whileEnd -> empty .)
    PRINT           reduce using rule 126 (whileEnd -> empty .)
    READ            reduce using rule 126 (whileEnd -> empty .)
    ID              reduce using rule 126 (whileEnd -> empty .)
    PLOT            reduce using rule 126 (whileEnd -> empty .)
    RETURN          reduce using rule 126 (whileEnd -> empty .)
    WHILE           reduce using rule 126 (whileEnd -> empty .)
    FOR             reduce using rule 126 (whileEnd -> empty .)
    MAX             reduce using rule 126 (whileEnd -> empty .)
    MIN             reduce using rule 126 (whileEnd -> empty .)
    SUM             reduce using rule 126 (whileEnd -> empty .)
    NORMAL          reduce using rule 126 (whileEnd -> empty .)
    UNIFORME        reduce using rule 126 (whileEnd -> empty .)
    POISSON         reduce using rule 126 (whileEnd -> empty .)
    BINOMIAL        reduce using rule 126 (whileEnd -> empty .)
    INT             reduce using rule 126 (whileEnd -> empty .)
    FLOAT           reduce using rule 126 (whileEnd -> empty .)
    CHAR            reduce using rule 126 (whileEnd -> empty .)
    BRACKETCLOSE    reduce using rule 126 (whileEnd -> empty .)


state 291

    (127) for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp . PARENCLOSE body forEnd
    (77) exp -> exp . AND expp
    (78) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 295
    AND             shift and go to state 161
    OR              shift and go to state 162


state 292

    (64) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE COLON dec_mvar
    (67) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE

    CTEINT          shift and go to state 296


state 293

    (63) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE COLON . dec_mvar
    (62) dec_mvar -> . ID guardarID COLON dec_mvar
    (63) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (64) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (65) dec_mvar -> . ID guardarID
    (66) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE
    (67) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 191

    dec_mvar                       shift and go to state 297

state 294

    (109) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body . ifEndElse
    (113) ifEndElse -> . empty
    (141) empty -> .

    IF              reduce using rule 141 (empty -> .)
    PRINT           reduce using rule 141 (empty -> .)
    READ            reduce using rule 141 (empty -> .)
    ID              reduce using rule 141 (empty -> .)
    PLOT            reduce using rule 141 (empty -> .)
    RETURN          reduce using rule 141 (empty -> .)
    WHILE           reduce using rule 141 (empty -> .)
    FOR             reduce using rule 141 (empty -> .)
    MAX             reduce using rule 141 (empty -> .)
    MIN             reduce using rule 141 (empty -> .)
    SUM             reduce using rule 141 (empty -> .)
    NORMAL          reduce using rule 141 (empty -> .)
    UNIFORME        reduce using rule 141 (empty -> .)
    POISSON         reduce using rule 141 (empty -> .)
    BINOMIAL        reduce using rule 141 (empty -> .)
    INT             reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    CHAR            reduce using rule 141 (empty -> .)
    BRACKETCLOSE    reduce using rule 141 (empty -> .)

    ifEndElse                      shift and go to state 298
    empty                          shift and go to state 299

state 295

    (127) for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE . body forEnd
    (38) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 55

    body                           shift and go to state 300

state 296

    (64) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE COLON dec_mvar
    (67) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE

    BRACECLOSE      shift and go to state 301


state 297

    (63) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .

    SEMICOLON       reduce using rule 63 (dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .)


state 298

    (109) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .

    IF              reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    PRINT           reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    READ            reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    ID              reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    PLOT            reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    RETURN          reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    WHILE           reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    FOR             reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    MAX             reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    MIN             reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    SUM             reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    NORMAL          reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    UNIFORME        reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    POISSON         reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    BINOMIAL        reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    INT             reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    FLOAT           reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    CHAR            reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    BRACKETCLOSE    reduce using rule 109 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)


state 299

    (113) ifEndElse -> empty .

    IF              reduce using rule 113 (ifEndElse -> empty .)
    PRINT           reduce using rule 113 (ifEndElse -> empty .)
    READ            reduce using rule 113 (ifEndElse -> empty .)
    ID              reduce using rule 113 (ifEndElse -> empty .)
    PLOT            reduce using rule 113 (ifEndElse -> empty .)
    RETURN          reduce using rule 113 (ifEndElse -> empty .)
    WHILE           reduce using rule 113 (ifEndElse -> empty .)
    FOR             reduce using rule 113 (ifEndElse -> empty .)
    MAX             reduce using rule 113 (ifEndElse -> empty .)
    MIN             reduce using rule 113 (ifEndElse -> empty .)
    SUM             reduce using rule 113 (ifEndElse -> empty .)
    NORMAL          reduce using rule 113 (ifEndElse -> empty .)
    UNIFORME        reduce using rule 113 (ifEndElse -> empty .)
    POISSON         reduce using rule 113 (ifEndElse -> empty .)
    BINOMIAL        reduce using rule 113 (ifEndElse -> empty .)
    INT             reduce using rule 113 (ifEndElse -> empty .)
    FLOAT           reduce using rule 113 (ifEndElse -> empty .)
    CHAR            reduce using rule 113 (ifEndElse -> empty .)
    BRACKETCLOSE    reduce using rule 113 (ifEndElse -> empty .)


state 300

    (127) for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body . forEnd
    (129) forEnd -> . empty
    (141) empty -> .

    IF              reduce using rule 141 (empty -> .)
    PRINT           reduce using rule 141 (empty -> .)
    READ            reduce using rule 141 (empty -> .)
    ID              reduce using rule 141 (empty -> .)
    PLOT            reduce using rule 141 (empty -> .)
    RETURN          reduce using rule 141 (empty -> .)
    WHILE           reduce using rule 141 (empty -> .)
    FOR             reduce using rule 141 (empty -> .)
    MAX             reduce using rule 141 (empty -> .)
    MIN             reduce using rule 141 (empty -> .)
    SUM             reduce using rule 141 (empty -> .)
    NORMAL          reduce using rule 141 (empty -> .)
    UNIFORME        reduce using rule 141 (empty -> .)
    POISSON         reduce using rule 141 (empty -> .)
    BINOMIAL        reduce using rule 141 (empty -> .)
    INT             reduce using rule 141 (empty -> .)
    FLOAT           reduce using rule 141 (empty -> .)
    CHAR            reduce using rule 141 (empty -> .)
    BRACKETCLOSE    reduce using rule 141 (empty -> .)

    forEnd                         shift and go to state 302
    empty                          shift and go to state 303

state 301

    (64) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE . COLON dec_mvar
    (67) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .

    COLON           shift and go to state 304
    SEMICOLON       reduce using rule 67 (dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .)


state 302

    (127) for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .

    IF              reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    PRINT           reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    READ            reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    ID              reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    PLOT            reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    RETURN          reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    WHILE           reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    FOR             reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    MAX             reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    MIN             reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    SUM             reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    NORMAL          reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    UNIFORME        reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    POISSON         reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    BINOMIAL        reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    INT             reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    FLOAT           reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    CHAR            reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)
    BRACKETCLOSE    reduce using rule 127 (for_loop -> FOR PARENOPEN ID EQUAL exp guardarValorFor TO exp PARENCLOSE body forEnd .)


state 303

    (129) forEnd -> empty .

    IF              reduce using rule 129 (forEnd -> empty .)
    PRINT           reduce using rule 129 (forEnd -> empty .)
    READ            reduce using rule 129 (forEnd -> empty .)
    ID              reduce using rule 129 (forEnd -> empty .)
    PLOT            reduce using rule 129 (forEnd -> empty .)
    RETURN          reduce using rule 129 (forEnd -> empty .)
    WHILE           reduce using rule 129 (forEnd -> empty .)
    FOR             reduce using rule 129 (forEnd -> empty .)
    MAX             reduce using rule 129 (forEnd -> empty .)
    MIN             reduce using rule 129 (forEnd -> empty .)
    SUM             reduce using rule 129 (forEnd -> empty .)
    NORMAL          reduce using rule 129 (forEnd -> empty .)
    UNIFORME        reduce using rule 129 (forEnd -> empty .)
    POISSON         reduce using rule 129 (forEnd -> empty .)
    BINOMIAL        reduce using rule 129 (forEnd -> empty .)
    INT             reduce using rule 129 (forEnd -> empty .)
    FLOAT           reduce using rule 129 (forEnd -> empty .)
    CHAR            reduce using rule 129 (forEnd -> empty .)
    BRACKETCLOSE    reduce using rule 129 (forEnd -> empty .)


state 304

    (64) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON . dec_mvar
    (62) dec_mvar -> . ID guardarID COLON dec_mvar
    (63) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (64) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (65) dec_mvar -> . ID guardarID
    (66) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE
    (67) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 191

    dec_mvar                       shift and go to state 305

state 305

    (64) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .

    SEMICOLON       reduce using rule 64 (dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 233 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 233 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 233 resolved as shift
WARNING: reduce/reduce conflict in state 66 resolved using rule (bodyy -> statement)
WARNING: rejected rule (empty -> <empty>) in state 66
WARNING: reduce/reduce conflict in state 125 resolved using rule (factor -> ID)
WARNING: rejected rule (variable -> ID) in state 125
