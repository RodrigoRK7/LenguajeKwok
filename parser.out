Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    FOR
    TO

Grammar

Rule 0     S' -> start_program
Rule 1     start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body end
Rule 2     start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body end
Rule 3     start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body end
Rule 4     start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body end
Rule 5     cuadruploMain -> empty
Rule 6     main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body
Rule 7     crearTablaMain -> empty
Rule 8     gotoMain -> empty
Rule 9     end -> empty
Rule 10    vars -> VAR varss
Rule 11    varss -> type guardarTipo mvar SEMICOLON varss
Rule 12    varss -> type guardarTipo mvar SEMICOLON
Rule 13    guardarTipo -> empty
Rule 14    mvar -> ID guardarIDvar COLON mvar
Rule 15    mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON mvar
Rule 16    mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
Rule 17    mvar -> ID guardarIDvar
Rule 18    mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE
Rule 19    mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE
Rule 20    guardarIDvar -> empty
Rule 21    multiple_funcs -> dec_func
Rule 22    multiple_funcs -> dec_func multiple_funcs
Rule 23    dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
Rule 24    dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
Rule 25    crearSymbolTable -> empty
Rule 26    param -> typeParam ID
Rule 27    param -> typeParam ID COLON param
Rule 28    param -> empty
Rule 29    typeParam -> INT
Rule 30    typeParam -> FLOAT
Rule 31    typeParam -> CHAR
Rule 32    numeroParam -> empty
Rule 33    startFunc -> empty
Rule 34    exitFunc -> empty
Rule 35    type -> INT
Rule 36    type -> FLOAT
Rule 37    type -> CHAR
Rule 38    body -> BRACKETOPEN bodyy BRACKETCLOSE
Rule 39    bodyy -> statement
Rule 40    bodyy -> statement bodyy
Rule 41    bodyy -> empty
Rule 42    statement -> dec_variables
Rule 43    statement -> assignment
Rule 44    statement -> condition
Rule 45    statement -> writing
Rule 46    statement -> reading
Rule 47    statement -> call_func
Rule 48    statement -> graph
Rule 49    statement -> return
Rule 50    statement -> while_loop
Rule 51    statement -> max
Rule 52    statement -> min
Rule 53    statement -> sum
Rule 54    statement -> normal
Rule 55    statement -> uniforme
Rule 56    statement -> poisson
Rule 57    statement -> binomial
Rule 58    dec_variables -> dec_variabless
Rule 59    dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless
Rule 60    dec_variabless -> type guardarTipo dec_mvar SEMICOLON
Rule 61    dec_mvar -> ID guardarID COLON dec_mvar
Rule 62    dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
Rule 63    dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
Rule 64    dec_mvar -> ID guardarID
Rule 65    dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE
Rule 66    dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE
Rule 67    guardarID -> empty
Rule 68    assignment -> variableAssignment EQUAL exp SEMICOLON
Rule 69    call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE
Rule 70    generarERA -> empty
Rule 71    call_funcc -> exp mandarParam
Rule 72    call_funcc -> exp mandarParam COLON call_funcc
Rule 73    call_funcc -> empty
Rule 74    mandarParam -> empty
Rule 75    exp -> expp
Rule 76    exp -> exp AND expp
Rule 77    exp -> exp OR expp
Rule 78    expp -> m_exp
Rule 79    expp -> expp GREATHERTHAN m_exp
Rule 80    expp -> expp LESSTHAN m_exp
Rule 81    expp -> expp GREATHEREQUAL m_exp
Rule 82    expp -> expp LESSEQUAL m_exp
Rule 83    expp -> expp DIFFERENT m_exp
Rule 84    expp -> expp SAME m_exp
Rule 85    m_exp -> termino
Rule 86    m_exp -> m_exp PLUS termino
Rule 87    m_exp -> m_exp MINUS termino
Rule 88    termino -> factor
Rule 89    termino -> termino MULTIPLY factor
Rule 90    termino -> termino DIVIDE factor
Rule 91    factor -> ID
Rule 92    factor -> CTEINT guardarConstanteInt
Rule 93    factor -> CTFLOAT guardarConstanteFloat
Rule 94    factor -> CTECHAR guardarConstanteChar
Rule 95    factor -> variable
Rule 96    factor -> call_func
Rule 97    factor -> PARENOPEN exp PARENCLOSE
Rule 98    guardarConstanteInt -> empty
Rule 99    guardarConstanteFloat -> empty
Rule 100   guardarConstanteChar -> empty
Rule 101   variable -> ID
Rule 102   variable -> ID BRACEOPEN exp BRACECLOSE
Rule 103   variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
Rule 104   variableAssignment -> ID
Rule 105   variableAssignment -> ID BRACEOPEN exp BRACECLOSE
Rule 106   variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
Rule 107   condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
Rule 108   condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
Rule 109   cuadruploIF -> empty
Rule 110   ifEnd -> empty
Rule 111   cuadruploElse -> empty
Rule 112   ifEndElse -> empty
Rule 113   writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
Rule 114   writingg -> exp
Rule 115   writingg -> exp COLON writingg
Rule 116   writingg -> auxString
Rule 117   writingg -> auxString COLON writingg
Rule 118   auxString -> CTESTRING
Rule 119   reading -> READ multivariables SEMICOLON
Rule 120   multivariables -> variable
Rule 121   multivariables -> variable COLON multivariables
Rule 122   while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
Rule 123   whileMigaja -> empty
Rule 124   whileEval -> empty
Rule 125   whileEnd -> empty
Rule 126   return -> RETURN exp SEMICOLON
Rule 127   graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON
Rule 128   max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON
Rule 129   min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON
Rule 130   sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON
Rule 131   binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON
Rule 132   poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON
Rule 133   uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON
Rule 134   normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON
Rule 135   empty -> <empty>

Terminals, with rules where they appear

AND                  : 76
BINOMIAL             : 131
BRACECLOSE           : 15 16 16 18 19 19 62 63 63 65 66 66 102 103 103 105 106 106
BRACEOPEN            : 15 16 16 18 19 19 62 63 63 65 66 66 102 103 103 105 106 106
BRACKETCLOSE         : 38
BRACKETOPEN          : 38
CHAR                 : 31 37
COLON                : 14 15 16 27 61 62 63 72 115 117 121 131 131 132 133 133 134 134
CTECHAR              : 94
CTEINT               : 15 16 16 18 19 19 62 63 63 65 66 66 92
CTESTRING            : 118
CTFLOAT              : 93
DIFFERENT            : 83
DIVIDE               : 90
ELSE                 : 108
EQUAL                : 68
FLOAT                : 30 36
FOR                  : 
FUNCTION             : 23 24
GREATHEREQUAL        : 81
GREATHERTHAN         : 79
ID                   : 1 2 3 4 14 15 16 17 18 19 23 24 26 27 61 62 63 64 65 66 69 91 101 102 103 104 105 106 128 129 130
IF                   : 107 108
INT                  : 29 35
LESSEQUAL            : 82
LESSTHAN             : 80
MAIN                 : 6
MAX                  : 128
MIN                  : 129
MINUS                : 87
MULTIPLY             : 89
NORMAL               : 134
OR                   : 77
PARENCLOSE           : 6 23 24 69 97 107 108 113 122 127 128 129 130 131 132 133 134
PARENOPEN            : 6 23 24 69 97 107 108 113 122 127 128 129 130 131 132 133 134
PLOT                 : 127
PLUS                 : 86
POISSON              : 132
PRINT                : 113
PROGRAM              : 1 2 3 4
READ                 : 119
RETURN               : 126
SAME                 : 84
SEMICOLON            : 1 2 3 4 11 12 59 60 68 113 119 126 127 128 129 130 131 132 133 134
SUM                  : 130
TO                   : 
UNIFORME             : 133
VAR                  : 10
VOID                 : 24
WHILE                : 122
error                : 

Nonterminals, with rules where they appear

assignment           : 43
auxString            : 116 117
binomial             : 57
body                 : 6 23 24 107 108 108 122
bodyy                : 38 40
call_func            : 47 96
call_funcc           : 69 72
condition            : 44
crearSymbolTable     : 23 24
crearTablaMain       : 6
cuadruploElse        : 108
cuadruploIF          : 107 108
cuadruploMain        : 1 2 3 4
dec_func             : 21 22
dec_mvar             : 59 60 61 62 63
dec_variables        : 42
dec_variabless       : 58 59
empty                : 5 7 8 9 13 20 25 28 32 33 34 41 67 70 73 74 98 99 100 109 110 111 112 123 124 125
end                  : 1 2 3 4
exitFunc             : 23 24
exp                  : 68 71 72 76 77 97 102 103 103 105 106 106 107 108 114 115 122 126 127 131 131 131 132 132 133 133 133 134 134 134
expp                 : 75 76 77 79 80 81 82 83 84
factor               : 88 89 90
generarERA           : 69
gotoMain             : 6
graph                : 48
guardarConstanteChar : 94
guardarConstanteFloat : 93
guardarConstanteInt  : 92
guardarID            : 61 62 63 64 65 66
guardarIDvar         : 14 15 16 17 18 19
guardarTipo          : 11 12 59 60
ifEnd                : 107
ifEndElse            : 108
m_exp                : 78 79 80 81 82 83 84 86 87
main_body            : 1 2 3 4
mandarParam          : 71 72
max                  : 51
min                  : 52
multiple_funcs       : 1 3 22
multivariables       : 119 121
mvar                 : 11 12 14 15 16
normal               : 54
numeroParam          : 23 24
param                : 23 24 27
poisson              : 56
reading              : 46
return               : 49
startFunc            : 23 24
start_program        : 0
statement            : 39 40
sum                  : 53
termino              : 85 86 87 89 90
type                 : 11 12 23 59 60
typeParam            : 26 27
uniforme             : 55
variable             : 95 120 121
variableAssignment   : 68
vars                 : 1 2
varss                : 10 11
whileEnd             : 122
whileEval            : 122
whileMigaja          : 122
while_loop           : 50
writing              : 45
writingg             : 113 115 117

Parsing method: LALR

state 0

    (0) S' -> . start_program
    (1) start_program -> . cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body end
    (2) start_program -> . cuadruploMain PROGRAM ID SEMICOLON vars main_body end
    (3) start_program -> . cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body end
    (4) start_program -> . cuadruploMain PROGRAM ID SEMICOLON main_body end
    (5) cuadruploMain -> . empty
    (135) empty -> .

    PROGRAM         reduce using rule 135 (empty -> .)

    start_program                  shift and go to state 1
    cuadruploMain                  shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> start_program .



state 2

    (1) start_program -> cuadruploMain . PROGRAM ID SEMICOLON vars multiple_funcs main_body end
    (2) start_program -> cuadruploMain . PROGRAM ID SEMICOLON vars main_body end
    (3) start_program -> cuadruploMain . PROGRAM ID SEMICOLON multiple_funcs main_body end
    (4) start_program -> cuadruploMain . PROGRAM ID SEMICOLON main_body end

    PROGRAM         shift and go to state 4


state 3

    (5) cuadruploMain -> empty .

    PROGRAM         reduce using rule 5 (cuadruploMain -> empty .)


state 4

    (1) start_program -> cuadruploMain PROGRAM . ID SEMICOLON vars multiple_funcs main_body end
    (2) start_program -> cuadruploMain PROGRAM . ID SEMICOLON vars main_body end
    (3) start_program -> cuadruploMain PROGRAM . ID SEMICOLON multiple_funcs main_body end
    (4) start_program -> cuadruploMain PROGRAM . ID SEMICOLON main_body end

    ID              shift and go to state 5


state 5

    (1) start_program -> cuadruploMain PROGRAM ID . SEMICOLON vars multiple_funcs main_body end
    (2) start_program -> cuadruploMain PROGRAM ID . SEMICOLON vars main_body end
    (3) start_program -> cuadruploMain PROGRAM ID . SEMICOLON multiple_funcs main_body end
    (4) start_program -> cuadruploMain PROGRAM ID . SEMICOLON main_body end

    SEMICOLON       shift and go to state 6


state 6

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON . vars multiple_funcs main_body end
    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON . vars main_body end
    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON . multiple_funcs main_body end
    (4) start_program -> cuadruploMain PROGRAM ID SEMICOLON . main_body end
    (10) vars -> . VAR varss
    (21) multiple_funcs -> . dec_func
    (22) multiple_funcs -> . dec_func multiple_funcs
    (6) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body
    (23) dec_func -> . FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
    (24) dec_func -> . FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc

    VAR             shift and go to state 10
    MAIN            shift and go to state 12
    FUNCTION        shift and go to state 13

    vars                           shift and go to state 7
    multiple_funcs                 shift and go to state 8
    main_body                      shift and go to state 9
    dec_func                       shift and go to state 11

state 7

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars . multiple_funcs main_body end
    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars . main_body end
    (21) multiple_funcs -> . dec_func
    (22) multiple_funcs -> . dec_func multiple_funcs
    (6) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body
    (23) dec_func -> . FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
    (24) dec_func -> . FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc

    MAIN            shift and go to state 12
    FUNCTION        shift and go to state 13

    multiple_funcs                 shift and go to state 14
    main_body                      shift and go to state 15
    dec_func                       shift and go to state 11

state 8

    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs . main_body end
    (6) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body

    MAIN            shift and go to state 12

    main_body                      shift and go to state 16

state 9

    (4) start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body . end
    (9) end -> . empty
    (135) empty -> .

    $end            reduce using rule 135 (empty -> .)

    end                            shift and go to state 17
    empty                          shift and go to state 18

state 10

    (10) vars -> VAR . varss
    (11) varss -> . type guardarTipo mvar SEMICOLON varss
    (12) varss -> . type guardarTipo mvar SEMICOLON
    (35) type -> . INT
    (36) type -> . FLOAT
    (37) type -> . CHAR

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    varss                          shift and go to state 19
    type                           shift and go to state 20

state 11

    (21) multiple_funcs -> dec_func .
    (22) multiple_funcs -> dec_func . multiple_funcs
    (21) multiple_funcs -> . dec_func
    (22) multiple_funcs -> . dec_func multiple_funcs
    (23) dec_func -> . FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
    (24) dec_func -> . FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc

    MAIN            reduce using rule 21 (multiple_funcs -> dec_func .)
    FUNCTION        shift and go to state 13

    dec_func                       shift and go to state 11
    multiple_funcs                 shift and go to state 24

state 12

    (6) main_body -> MAIN . crearTablaMain PARENOPEN PARENCLOSE gotoMain body
    (7) crearTablaMain -> . empty
    (135) empty -> .

    PARENOPEN       reduce using rule 135 (empty -> .)

    crearTablaMain                 shift and go to state 25
    empty                          shift and go to state 26

state 13

    (23) dec_func -> FUNCTION . type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
    (24) dec_func -> FUNCTION . VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
    (35) type -> . INT
    (36) type -> . FLOAT
    (37) type -> . CHAR

    VOID            shift and go to state 28
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    type                           shift and go to state 27

state 14

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs . main_body end
    (6) main_body -> . MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body

    MAIN            shift and go to state 12

    main_body                      shift and go to state 29

state 15

    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body . end
    (9) end -> . empty
    (135) empty -> .

    $end            reduce using rule 135 (empty -> .)

    end                            shift and go to state 30
    empty                          shift and go to state 18

state 16

    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body . end
    (9) end -> . empty
    (135) empty -> .

    $end            reduce using rule 135 (empty -> .)

    end                            shift and go to state 31
    empty                          shift and go to state 18

state 17

    (4) start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body end .

    $end            reduce using rule 4 (start_program -> cuadruploMain PROGRAM ID SEMICOLON main_body end .)


state 18

    (9) end -> empty .

    $end            reduce using rule 9 (end -> empty .)


state 19

    (10) vars -> VAR varss .

    MAIN            reduce using rule 10 (vars -> VAR varss .)
    FUNCTION        reduce using rule 10 (vars -> VAR varss .)


state 20

    (11) varss -> type . guardarTipo mvar SEMICOLON varss
    (12) varss -> type . guardarTipo mvar SEMICOLON
    (13) guardarTipo -> . empty
    (135) empty -> .

    ID              reduce using rule 135 (empty -> .)

    guardarTipo                    shift and go to state 32
    empty                          shift and go to state 33

state 21

    (35) type -> INT .

    ID              reduce using rule 35 (type -> INT .)


state 22

    (36) type -> FLOAT .

    ID              reduce using rule 36 (type -> FLOAT .)


state 23

    (37) type -> CHAR .

    ID              reduce using rule 37 (type -> CHAR .)


state 24

    (22) multiple_funcs -> dec_func multiple_funcs .

    MAIN            reduce using rule 22 (multiple_funcs -> dec_func multiple_funcs .)


state 25

    (6) main_body -> MAIN crearTablaMain . PARENOPEN PARENCLOSE gotoMain body

    PARENOPEN       shift and go to state 34


state 26

    (7) crearTablaMain -> empty .

    PARENOPEN       reduce using rule 7 (crearTablaMain -> empty .)


state 27

    (23) dec_func -> FUNCTION type . ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc

    ID              shift and go to state 35


state 28

    (24) dec_func -> FUNCTION VOID . ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc

    ID              shift and go to state 36


state 29

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body . end
    (9) end -> . empty
    (135) empty -> .

    $end            reduce using rule 135 (empty -> .)

    end                            shift and go to state 37
    empty                          shift and go to state 18

state 30

    (2) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body end .

    $end            reduce using rule 2 (start_program -> cuadruploMain PROGRAM ID SEMICOLON vars main_body end .)


state 31

    (3) start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body end .

    $end            reduce using rule 3 (start_program -> cuadruploMain PROGRAM ID SEMICOLON multiple_funcs main_body end .)


state 32

    (11) varss -> type guardarTipo . mvar SEMICOLON varss
    (12) varss -> type guardarTipo . mvar SEMICOLON
    (14) mvar -> . ID guardarIDvar COLON mvar
    (15) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (16) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID guardarIDvar
    (18) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE
    (19) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 39

    mvar                           shift and go to state 38

state 33

    (13) guardarTipo -> empty .

    ID              reduce using rule 13 (guardarTipo -> empty .)


state 34

    (6) main_body -> MAIN crearTablaMain PARENOPEN . PARENCLOSE gotoMain body

    PARENCLOSE      shift and go to state 40


state 35

    (23) dec_func -> FUNCTION type ID . crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
    (25) crearSymbolTable -> . empty
    (135) empty -> .

    PARENOPEN       reduce using rule 135 (empty -> .)

    crearSymbolTable               shift and go to state 41
    empty                          shift and go to state 42

state 36

    (24) dec_func -> FUNCTION VOID ID . crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc
    (25) crearSymbolTable -> . empty
    (135) empty -> .

    PARENOPEN       reduce using rule 135 (empty -> .)

    crearSymbolTable               shift and go to state 43
    empty                          shift and go to state 42

state 37

    (1) start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body end .

    $end            reduce using rule 1 (start_program -> cuadruploMain PROGRAM ID SEMICOLON vars multiple_funcs main_body end .)


state 38

    (11) varss -> type guardarTipo mvar . SEMICOLON varss
    (12) varss -> type guardarTipo mvar . SEMICOLON

    SEMICOLON       shift and go to state 44


state 39

    (14) mvar -> ID . guardarIDvar COLON mvar
    (15) mvar -> ID . guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (16) mvar -> ID . guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> ID . guardarIDvar
    (18) mvar -> ID . guardarIDvar BRACEOPEN CTEINT BRACECLOSE
    (19) mvar -> ID . guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE
    (20) guardarIDvar -> . empty
    (135) empty -> .

    COLON           reduce using rule 135 (empty -> .)
    BRACEOPEN       reduce using rule 135 (empty -> .)
    SEMICOLON       reduce using rule 135 (empty -> .)

    guardarIDvar                   shift and go to state 45
    empty                          shift and go to state 46

state 40

    (6) main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE . gotoMain body
    (8) gotoMain -> . empty
    (135) empty -> .

    BRACKETOPEN     reduce using rule 135 (empty -> .)

    gotoMain                       shift and go to state 47
    empty                          shift and go to state 48

state 41

    (23) dec_func -> FUNCTION type ID crearSymbolTable . PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc

    PARENOPEN       shift and go to state 49


state 42

    (25) crearSymbolTable -> empty .

    PARENOPEN       reduce using rule 25 (crearSymbolTable -> empty .)


state 43

    (24) dec_func -> FUNCTION VOID ID crearSymbolTable . PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc

    PARENOPEN       shift and go to state 50


state 44

    (11) varss -> type guardarTipo mvar SEMICOLON . varss
    (12) varss -> type guardarTipo mvar SEMICOLON .
    (11) varss -> . type guardarTipo mvar SEMICOLON varss
    (12) varss -> . type guardarTipo mvar SEMICOLON
    (35) type -> . INT
    (36) type -> . FLOAT
    (37) type -> . CHAR

    MAIN            reduce using rule 12 (varss -> type guardarTipo mvar SEMICOLON .)
    FUNCTION        reduce using rule 12 (varss -> type guardarTipo mvar SEMICOLON .)
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    type                           shift and go to state 20
    varss                          shift and go to state 51

state 45

    (14) mvar -> ID guardarIDvar . COLON mvar
    (15) mvar -> ID guardarIDvar . BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (16) mvar -> ID guardarIDvar . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> ID guardarIDvar .
    (18) mvar -> ID guardarIDvar . BRACEOPEN CTEINT BRACECLOSE
    (19) mvar -> ID guardarIDvar . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 52
    BRACEOPEN       shift and go to state 53
    SEMICOLON       reduce using rule 17 (mvar -> ID guardarIDvar .)


state 46

    (20) guardarIDvar -> empty .

    COLON           reduce using rule 20 (guardarIDvar -> empty .)
    BRACEOPEN       reduce using rule 20 (guardarIDvar -> empty .)
    SEMICOLON       reduce using rule 20 (guardarIDvar -> empty .)


state 47

    (6) main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain . body
    (38) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 55

    body                           shift and go to state 54

state 48

    (8) gotoMain -> empty .

    BRACKETOPEN     reduce using rule 8 (gotoMain -> empty .)


state 49

    (23) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN . param numeroParam PARENCLOSE startFunc body exitFunc
    (26) param -> . typeParam ID
    (27) param -> . typeParam ID COLON param
    (28) param -> . empty
    (29) typeParam -> . INT
    (30) typeParam -> . FLOAT
    (31) typeParam -> . CHAR
    (135) empty -> .

    INT             shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    PARENCLOSE      reduce using rule 135 (empty -> .)

    param                          shift and go to state 56
    typeParam                      shift and go to state 57
    empty                          shift and go to state 58

state 50

    (24) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN . param numeroParam PARENCLOSE startFunc body exitFunc
    (26) param -> . typeParam ID
    (27) param -> . typeParam ID COLON param
    (28) param -> . empty
    (29) typeParam -> . INT
    (30) typeParam -> . FLOAT
    (31) typeParam -> . CHAR
    (135) empty -> .

    INT             shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    PARENCLOSE      reduce using rule 135 (empty -> .)

    param                          shift and go to state 62
    typeParam                      shift and go to state 57
    empty                          shift and go to state 58

state 51

    (11) varss -> type guardarTipo mvar SEMICOLON varss .

    MAIN            reduce using rule 11 (varss -> type guardarTipo mvar SEMICOLON varss .)
    FUNCTION        reduce using rule 11 (varss -> type guardarTipo mvar SEMICOLON varss .)


state 52

    (14) mvar -> ID guardarIDvar COLON . mvar
    (14) mvar -> . ID guardarIDvar COLON mvar
    (15) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (16) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID guardarIDvar
    (18) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE
    (19) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 39

    mvar                           shift and go to state 63

state 53

    (15) mvar -> ID guardarIDvar BRACEOPEN . CTEINT BRACECLOSE COLON mvar
    (16) mvar -> ID guardarIDvar BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> ID guardarIDvar BRACEOPEN . CTEINT BRACECLOSE
    (19) mvar -> ID guardarIDvar BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    CTEINT          shift and go to state 64


state 54

    (6) main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body .

    $end            reduce using rule 6 (main_body -> MAIN crearTablaMain PARENOPEN PARENCLOSE gotoMain body .)


state 55

    (38) body -> BRACKETOPEN . bodyy BRACKETCLOSE
    (39) bodyy -> . statement
    (40) bodyy -> . statement bodyy
    (41) bodyy -> . empty
    (42) statement -> . dec_variables
    (43) statement -> . assignment
    (44) statement -> . condition
    (45) statement -> . writing
    (46) statement -> . reading
    (47) statement -> . call_func
    (48) statement -> . graph
    (49) statement -> . return
    (50) statement -> . while_loop
    (51) statement -> . max
    (52) statement -> . min
    (53) statement -> . sum
    (54) statement -> . normal
    (55) statement -> . uniforme
    (56) statement -> . poisson
    (57) statement -> . binomial
    (135) empty -> .
    (58) dec_variables -> . dec_variabless
    (68) assignment -> . variableAssignment EQUAL exp SEMICOLON
    (107) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
    (108) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (113) writing -> . PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
    (119) reading -> . READ multivariables SEMICOLON
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE
    (127) graph -> . PLOT PARENOPEN exp PARENCLOSE SEMICOLON
    (126) return -> . RETURN exp SEMICOLON
    (122) while_loop -> . WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (128) max -> . MAX PARENOPEN ID PARENCLOSE SEMICOLON
    (129) min -> . MIN PARENOPEN ID PARENCLOSE SEMICOLON
    (130) sum -> . SUM PARENOPEN ID PARENCLOSE SEMICOLON
    (134) normal -> . NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON
    (133) uniforme -> . UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON
    (132) poisson -> . POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON
    (131) binomial -> . BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON
    (59) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON dec_variabless
    (60) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON
    (104) variableAssignment -> . ID
    (105) variableAssignment -> . ID BRACEOPEN exp BRACECLOSE
    (106) variableAssignment -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (35) type -> . INT
    (36) type -> . FLOAT
    (37) type -> . CHAR

    BRACKETCLOSE    reduce using rule 135 (empty -> .)
    IF              shift and go to state 86
    PRINT           shift and go to state 87
    READ            shift and go to state 88
    ID              shift and go to state 89
    PLOT            shift and go to state 90
    RETURN          shift and go to state 91
    WHILE           shift and go to state 92
    MAX             shift and go to state 93
    MIN             shift and go to state 94
    SUM             shift and go to state 95
    NORMAL          shift and go to state 96
    UNIFORME        shift and go to state 97
    POISSON         shift and go to state 98
    BINOMIAL        shift and go to state 99
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

    bodyy                          shift and go to state 65
    statement                      shift and go to state 66
    empty                          shift and go to state 67
    dec_variables                  shift and go to state 68
    assignment                     shift and go to state 69
    condition                      shift and go to state 70
    writing                        shift and go to state 71
    reading                        shift and go to state 72
    call_func                      shift and go to state 73
    graph                          shift and go to state 74
    return                         shift and go to state 75
    while_loop                     shift and go to state 76
    max                            shift and go to state 77
    min                            shift and go to state 78
    sum                            shift and go to state 79
    normal                         shift and go to state 80
    uniforme                       shift and go to state 81
    poisson                        shift and go to state 82
    binomial                       shift and go to state 83
    dec_variabless                 shift and go to state 84
    variableAssignment             shift and go to state 85
    type                           shift and go to state 100

state 56

    (23) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param . numeroParam PARENCLOSE startFunc body exitFunc
    (32) numeroParam -> . empty
    (135) empty -> .

    PARENCLOSE      reduce using rule 135 (empty -> .)

    numeroParam                    shift and go to state 101
    empty                          shift and go to state 102

state 57

    (26) param -> typeParam . ID
    (27) param -> typeParam . ID COLON param

    ID              shift and go to state 103


state 58

    (28) param -> empty .

    PARENCLOSE      reduce using rule 28 (param -> empty .)


state 59

    (29) typeParam -> INT .

    ID              reduce using rule 29 (typeParam -> INT .)


state 60

    (30) typeParam -> FLOAT .

    ID              reduce using rule 30 (typeParam -> FLOAT .)


state 61

    (31) typeParam -> CHAR .

    ID              reduce using rule 31 (typeParam -> CHAR .)


state 62

    (24) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param . numeroParam PARENCLOSE startFunc body exitFunc
    (32) numeroParam -> . empty
    (135) empty -> .

    PARENCLOSE      reduce using rule 135 (empty -> .)

    numeroParam                    shift and go to state 104
    empty                          shift and go to state 102

state 63

    (14) mvar -> ID guardarIDvar COLON mvar .

    SEMICOLON       reduce using rule 14 (mvar -> ID guardarIDvar COLON mvar .)


state 64

    (15) mvar -> ID guardarIDvar BRACEOPEN CTEINT . BRACECLOSE COLON mvar
    (16) mvar -> ID guardarIDvar BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> ID guardarIDvar BRACEOPEN CTEINT . BRACECLOSE
    (19) mvar -> ID guardarIDvar BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    BRACECLOSE      shift and go to state 105


state 65

    (38) body -> BRACKETOPEN bodyy . BRACKETCLOSE

    BRACKETCLOSE    shift and go to state 106


state 66

    (39) bodyy -> statement .
    (40) bodyy -> statement . bodyy
    (39) bodyy -> . statement
    (40) bodyy -> . statement bodyy
    (41) bodyy -> . empty
    (42) statement -> . dec_variables
    (43) statement -> . assignment
    (44) statement -> . condition
    (45) statement -> . writing
    (46) statement -> . reading
    (47) statement -> . call_func
    (48) statement -> . graph
    (49) statement -> . return
    (50) statement -> . while_loop
    (51) statement -> . max
    (52) statement -> . min
    (53) statement -> . sum
    (54) statement -> . normal
    (55) statement -> . uniforme
    (56) statement -> . poisson
    (57) statement -> . binomial
    (135) empty -> .
    (58) dec_variables -> . dec_variabless
    (68) assignment -> . variableAssignment EQUAL exp SEMICOLON
    (107) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
    (108) condition -> . IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (113) writing -> . PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
    (119) reading -> . READ multivariables SEMICOLON
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE
    (127) graph -> . PLOT PARENOPEN exp PARENCLOSE SEMICOLON
    (126) return -> . RETURN exp SEMICOLON
    (122) while_loop -> . WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (128) max -> . MAX PARENOPEN ID PARENCLOSE SEMICOLON
    (129) min -> . MIN PARENOPEN ID PARENCLOSE SEMICOLON
    (130) sum -> . SUM PARENOPEN ID PARENCLOSE SEMICOLON
    (134) normal -> . NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON
    (133) uniforme -> . UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON
    (132) poisson -> . POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON
    (131) binomial -> . BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON
    (59) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON dec_variabless
    (60) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON
    (104) variableAssignment -> . ID
    (105) variableAssignment -> . ID BRACEOPEN exp BRACECLOSE
    (106) variableAssignment -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (35) type -> . INT
    (36) type -> . FLOAT
    (37) type -> . CHAR

  ! reduce/reduce conflict for BRACKETCLOSE resolved using rule 39 (bodyy -> statement .)
    BRACKETCLOSE    reduce using rule 39 (bodyy -> statement .)
    IF              shift and go to state 86
    PRINT           shift and go to state 87
    READ            shift and go to state 88
    ID              shift and go to state 89
    PLOT            shift and go to state 90
    RETURN          shift and go to state 91
    WHILE           shift and go to state 92
    MAX             shift and go to state 93
    MIN             shift and go to state 94
    SUM             shift and go to state 95
    NORMAL          shift and go to state 96
    UNIFORME        shift and go to state 97
    POISSON         shift and go to state 98
    BINOMIAL        shift and go to state 99
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

  ! BRACKETCLOSE    [ reduce using rule 135 (empty -> .) ]

    statement                      shift and go to state 66
    bodyy                          shift and go to state 107
    empty                          shift and go to state 67
    dec_variables                  shift and go to state 68
    assignment                     shift and go to state 69
    condition                      shift and go to state 70
    writing                        shift and go to state 71
    reading                        shift and go to state 72
    call_func                      shift and go to state 73
    graph                          shift and go to state 74
    return                         shift and go to state 75
    while_loop                     shift and go to state 76
    max                            shift and go to state 77
    min                            shift and go to state 78
    sum                            shift and go to state 79
    normal                         shift and go to state 80
    uniforme                       shift and go to state 81
    poisson                        shift and go to state 82
    binomial                       shift and go to state 83
    dec_variabless                 shift and go to state 84
    variableAssignment             shift and go to state 85
    type                           shift and go to state 100

state 67

    (41) bodyy -> empty .

    BRACKETCLOSE    reduce using rule 41 (bodyy -> empty .)


state 68

    (42) statement -> dec_variables .

    IF              reduce using rule 42 (statement -> dec_variables .)
    PRINT           reduce using rule 42 (statement -> dec_variables .)
    READ            reduce using rule 42 (statement -> dec_variables .)
    ID              reduce using rule 42 (statement -> dec_variables .)
    PLOT            reduce using rule 42 (statement -> dec_variables .)
    RETURN          reduce using rule 42 (statement -> dec_variables .)
    WHILE           reduce using rule 42 (statement -> dec_variables .)
    MAX             reduce using rule 42 (statement -> dec_variables .)
    MIN             reduce using rule 42 (statement -> dec_variables .)
    SUM             reduce using rule 42 (statement -> dec_variables .)
    NORMAL          reduce using rule 42 (statement -> dec_variables .)
    UNIFORME        reduce using rule 42 (statement -> dec_variables .)
    POISSON         reduce using rule 42 (statement -> dec_variables .)
    BINOMIAL        reduce using rule 42 (statement -> dec_variables .)
    INT             reduce using rule 42 (statement -> dec_variables .)
    FLOAT           reduce using rule 42 (statement -> dec_variables .)
    CHAR            reduce using rule 42 (statement -> dec_variables .)
    BRACKETCLOSE    reduce using rule 42 (statement -> dec_variables .)


state 69

    (43) statement -> assignment .

    IF              reduce using rule 43 (statement -> assignment .)
    PRINT           reduce using rule 43 (statement -> assignment .)
    READ            reduce using rule 43 (statement -> assignment .)
    ID              reduce using rule 43 (statement -> assignment .)
    PLOT            reduce using rule 43 (statement -> assignment .)
    RETURN          reduce using rule 43 (statement -> assignment .)
    WHILE           reduce using rule 43 (statement -> assignment .)
    MAX             reduce using rule 43 (statement -> assignment .)
    MIN             reduce using rule 43 (statement -> assignment .)
    SUM             reduce using rule 43 (statement -> assignment .)
    NORMAL          reduce using rule 43 (statement -> assignment .)
    UNIFORME        reduce using rule 43 (statement -> assignment .)
    POISSON         reduce using rule 43 (statement -> assignment .)
    BINOMIAL        reduce using rule 43 (statement -> assignment .)
    INT             reduce using rule 43 (statement -> assignment .)
    FLOAT           reduce using rule 43 (statement -> assignment .)
    CHAR            reduce using rule 43 (statement -> assignment .)
    BRACKETCLOSE    reduce using rule 43 (statement -> assignment .)


state 70

    (44) statement -> condition .

    IF              reduce using rule 44 (statement -> condition .)
    PRINT           reduce using rule 44 (statement -> condition .)
    READ            reduce using rule 44 (statement -> condition .)
    ID              reduce using rule 44 (statement -> condition .)
    PLOT            reduce using rule 44 (statement -> condition .)
    RETURN          reduce using rule 44 (statement -> condition .)
    WHILE           reduce using rule 44 (statement -> condition .)
    MAX             reduce using rule 44 (statement -> condition .)
    MIN             reduce using rule 44 (statement -> condition .)
    SUM             reduce using rule 44 (statement -> condition .)
    NORMAL          reduce using rule 44 (statement -> condition .)
    UNIFORME        reduce using rule 44 (statement -> condition .)
    POISSON         reduce using rule 44 (statement -> condition .)
    BINOMIAL        reduce using rule 44 (statement -> condition .)
    INT             reduce using rule 44 (statement -> condition .)
    FLOAT           reduce using rule 44 (statement -> condition .)
    CHAR            reduce using rule 44 (statement -> condition .)
    BRACKETCLOSE    reduce using rule 44 (statement -> condition .)


state 71

    (45) statement -> writing .

    IF              reduce using rule 45 (statement -> writing .)
    PRINT           reduce using rule 45 (statement -> writing .)
    READ            reduce using rule 45 (statement -> writing .)
    ID              reduce using rule 45 (statement -> writing .)
    PLOT            reduce using rule 45 (statement -> writing .)
    RETURN          reduce using rule 45 (statement -> writing .)
    WHILE           reduce using rule 45 (statement -> writing .)
    MAX             reduce using rule 45 (statement -> writing .)
    MIN             reduce using rule 45 (statement -> writing .)
    SUM             reduce using rule 45 (statement -> writing .)
    NORMAL          reduce using rule 45 (statement -> writing .)
    UNIFORME        reduce using rule 45 (statement -> writing .)
    POISSON         reduce using rule 45 (statement -> writing .)
    BINOMIAL        reduce using rule 45 (statement -> writing .)
    INT             reduce using rule 45 (statement -> writing .)
    FLOAT           reduce using rule 45 (statement -> writing .)
    CHAR            reduce using rule 45 (statement -> writing .)
    BRACKETCLOSE    reduce using rule 45 (statement -> writing .)


state 72

    (46) statement -> reading .

    IF              reduce using rule 46 (statement -> reading .)
    PRINT           reduce using rule 46 (statement -> reading .)
    READ            reduce using rule 46 (statement -> reading .)
    ID              reduce using rule 46 (statement -> reading .)
    PLOT            reduce using rule 46 (statement -> reading .)
    RETURN          reduce using rule 46 (statement -> reading .)
    WHILE           reduce using rule 46 (statement -> reading .)
    MAX             reduce using rule 46 (statement -> reading .)
    MIN             reduce using rule 46 (statement -> reading .)
    SUM             reduce using rule 46 (statement -> reading .)
    NORMAL          reduce using rule 46 (statement -> reading .)
    UNIFORME        reduce using rule 46 (statement -> reading .)
    POISSON         reduce using rule 46 (statement -> reading .)
    BINOMIAL        reduce using rule 46 (statement -> reading .)
    INT             reduce using rule 46 (statement -> reading .)
    FLOAT           reduce using rule 46 (statement -> reading .)
    CHAR            reduce using rule 46 (statement -> reading .)
    BRACKETCLOSE    reduce using rule 46 (statement -> reading .)


state 73

    (47) statement -> call_func .

    IF              reduce using rule 47 (statement -> call_func .)
    PRINT           reduce using rule 47 (statement -> call_func .)
    READ            reduce using rule 47 (statement -> call_func .)
    ID              reduce using rule 47 (statement -> call_func .)
    PLOT            reduce using rule 47 (statement -> call_func .)
    RETURN          reduce using rule 47 (statement -> call_func .)
    WHILE           reduce using rule 47 (statement -> call_func .)
    MAX             reduce using rule 47 (statement -> call_func .)
    MIN             reduce using rule 47 (statement -> call_func .)
    SUM             reduce using rule 47 (statement -> call_func .)
    NORMAL          reduce using rule 47 (statement -> call_func .)
    UNIFORME        reduce using rule 47 (statement -> call_func .)
    POISSON         reduce using rule 47 (statement -> call_func .)
    BINOMIAL        reduce using rule 47 (statement -> call_func .)
    INT             reduce using rule 47 (statement -> call_func .)
    FLOAT           reduce using rule 47 (statement -> call_func .)
    CHAR            reduce using rule 47 (statement -> call_func .)
    BRACKETCLOSE    reduce using rule 47 (statement -> call_func .)


state 74

    (48) statement -> graph .

    IF              reduce using rule 48 (statement -> graph .)
    PRINT           reduce using rule 48 (statement -> graph .)
    READ            reduce using rule 48 (statement -> graph .)
    ID              reduce using rule 48 (statement -> graph .)
    PLOT            reduce using rule 48 (statement -> graph .)
    RETURN          reduce using rule 48 (statement -> graph .)
    WHILE           reduce using rule 48 (statement -> graph .)
    MAX             reduce using rule 48 (statement -> graph .)
    MIN             reduce using rule 48 (statement -> graph .)
    SUM             reduce using rule 48 (statement -> graph .)
    NORMAL          reduce using rule 48 (statement -> graph .)
    UNIFORME        reduce using rule 48 (statement -> graph .)
    POISSON         reduce using rule 48 (statement -> graph .)
    BINOMIAL        reduce using rule 48 (statement -> graph .)
    INT             reduce using rule 48 (statement -> graph .)
    FLOAT           reduce using rule 48 (statement -> graph .)
    CHAR            reduce using rule 48 (statement -> graph .)
    BRACKETCLOSE    reduce using rule 48 (statement -> graph .)


state 75

    (49) statement -> return .

    IF              reduce using rule 49 (statement -> return .)
    PRINT           reduce using rule 49 (statement -> return .)
    READ            reduce using rule 49 (statement -> return .)
    ID              reduce using rule 49 (statement -> return .)
    PLOT            reduce using rule 49 (statement -> return .)
    RETURN          reduce using rule 49 (statement -> return .)
    WHILE           reduce using rule 49 (statement -> return .)
    MAX             reduce using rule 49 (statement -> return .)
    MIN             reduce using rule 49 (statement -> return .)
    SUM             reduce using rule 49 (statement -> return .)
    NORMAL          reduce using rule 49 (statement -> return .)
    UNIFORME        reduce using rule 49 (statement -> return .)
    POISSON         reduce using rule 49 (statement -> return .)
    BINOMIAL        reduce using rule 49 (statement -> return .)
    INT             reduce using rule 49 (statement -> return .)
    FLOAT           reduce using rule 49 (statement -> return .)
    CHAR            reduce using rule 49 (statement -> return .)
    BRACKETCLOSE    reduce using rule 49 (statement -> return .)


state 76

    (50) statement -> while_loop .

    IF              reduce using rule 50 (statement -> while_loop .)
    PRINT           reduce using rule 50 (statement -> while_loop .)
    READ            reduce using rule 50 (statement -> while_loop .)
    ID              reduce using rule 50 (statement -> while_loop .)
    PLOT            reduce using rule 50 (statement -> while_loop .)
    RETURN          reduce using rule 50 (statement -> while_loop .)
    WHILE           reduce using rule 50 (statement -> while_loop .)
    MAX             reduce using rule 50 (statement -> while_loop .)
    MIN             reduce using rule 50 (statement -> while_loop .)
    SUM             reduce using rule 50 (statement -> while_loop .)
    NORMAL          reduce using rule 50 (statement -> while_loop .)
    UNIFORME        reduce using rule 50 (statement -> while_loop .)
    POISSON         reduce using rule 50 (statement -> while_loop .)
    BINOMIAL        reduce using rule 50 (statement -> while_loop .)
    INT             reduce using rule 50 (statement -> while_loop .)
    FLOAT           reduce using rule 50 (statement -> while_loop .)
    CHAR            reduce using rule 50 (statement -> while_loop .)
    BRACKETCLOSE    reduce using rule 50 (statement -> while_loop .)


state 77

    (51) statement -> max .

    IF              reduce using rule 51 (statement -> max .)
    PRINT           reduce using rule 51 (statement -> max .)
    READ            reduce using rule 51 (statement -> max .)
    ID              reduce using rule 51 (statement -> max .)
    PLOT            reduce using rule 51 (statement -> max .)
    RETURN          reduce using rule 51 (statement -> max .)
    WHILE           reduce using rule 51 (statement -> max .)
    MAX             reduce using rule 51 (statement -> max .)
    MIN             reduce using rule 51 (statement -> max .)
    SUM             reduce using rule 51 (statement -> max .)
    NORMAL          reduce using rule 51 (statement -> max .)
    UNIFORME        reduce using rule 51 (statement -> max .)
    POISSON         reduce using rule 51 (statement -> max .)
    BINOMIAL        reduce using rule 51 (statement -> max .)
    INT             reduce using rule 51 (statement -> max .)
    FLOAT           reduce using rule 51 (statement -> max .)
    CHAR            reduce using rule 51 (statement -> max .)
    BRACKETCLOSE    reduce using rule 51 (statement -> max .)


state 78

    (52) statement -> min .

    IF              reduce using rule 52 (statement -> min .)
    PRINT           reduce using rule 52 (statement -> min .)
    READ            reduce using rule 52 (statement -> min .)
    ID              reduce using rule 52 (statement -> min .)
    PLOT            reduce using rule 52 (statement -> min .)
    RETURN          reduce using rule 52 (statement -> min .)
    WHILE           reduce using rule 52 (statement -> min .)
    MAX             reduce using rule 52 (statement -> min .)
    MIN             reduce using rule 52 (statement -> min .)
    SUM             reduce using rule 52 (statement -> min .)
    NORMAL          reduce using rule 52 (statement -> min .)
    UNIFORME        reduce using rule 52 (statement -> min .)
    POISSON         reduce using rule 52 (statement -> min .)
    BINOMIAL        reduce using rule 52 (statement -> min .)
    INT             reduce using rule 52 (statement -> min .)
    FLOAT           reduce using rule 52 (statement -> min .)
    CHAR            reduce using rule 52 (statement -> min .)
    BRACKETCLOSE    reduce using rule 52 (statement -> min .)


state 79

    (53) statement -> sum .

    IF              reduce using rule 53 (statement -> sum .)
    PRINT           reduce using rule 53 (statement -> sum .)
    READ            reduce using rule 53 (statement -> sum .)
    ID              reduce using rule 53 (statement -> sum .)
    PLOT            reduce using rule 53 (statement -> sum .)
    RETURN          reduce using rule 53 (statement -> sum .)
    WHILE           reduce using rule 53 (statement -> sum .)
    MAX             reduce using rule 53 (statement -> sum .)
    MIN             reduce using rule 53 (statement -> sum .)
    SUM             reduce using rule 53 (statement -> sum .)
    NORMAL          reduce using rule 53 (statement -> sum .)
    UNIFORME        reduce using rule 53 (statement -> sum .)
    POISSON         reduce using rule 53 (statement -> sum .)
    BINOMIAL        reduce using rule 53 (statement -> sum .)
    INT             reduce using rule 53 (statement -> sum .)
    FLOAT           reduce using rule 53 (statement -> sum .)
    CHAR            reduce using rule 53 (statement -> sum .)
    BRACKETCLOSE    reduce using rule 53 (statement -> sum .)


state 80

    (54) statement -> normal .

    IF              reduce using rule 54 (statement -> normal .)
    PRINT           reduce using rule 54 (statement -> normal .)
    READ            reduce using rule 54 (statement -> normal .)
    ID              reduce using rule 54 (statement -> normal .)
    PLOT            reduce using rule 54 (statement -> normal .)
    RETURN          reduce using rule 54 (statement -> normal .)
    WHILE           reduce using rule 54 (statement -> normal .)
    MAX             reduce using rule 54 (statement -> normal .)
    MIN             reduce using rule 54 (statement -> normal .)
    SUM             reduce using rule 54 (statement -> normal .)
    NORMAL          reduce using rule 54 (statement -> normal .)
    UNIFORME        reduce using rule 54 (statement -> normal .)
    POISSON         reduce using rule 54 (statement -> normal .)
    BINOMIAL        reduce using rule 54 (statement -> normal .)
    INT             reduce using rule 54 (statement -> normal .)
    FLOAT           reduce using rule 54 (statement -> normal .)
    CHAR            reduce using rule 54 (statement -> normal .)
    BRACKETCLOSE    reduce using rule 54 (statement -> normal .)


state 81

    (55) statement -> uniforme .

    IF              reduce using rule 55 (statement -> uniforme .)
    PRINT           reduce using rule 55 (statement -> uniforme .)
    READ            reduce using rule 55 (statement -> uniforme .)
    ID              reduce using rule 55 (statement -> uniforme .)
    PLOT            reduce using rule 55 (statement -> uniforme .)
    RETURN          reduce using rule 55 (statement -> uniforme .)
    WHILE           reduce using rule 55 (statement -> uniforme .)
    MAX             reduce using rule 55 (statement -> uniforme .)
    MIN             reduce using rule 55 (statement -> uniforme .)
    SUM             reduce using rule 55 (statement -> uniforme .)
    NORMAL          reduce using rule 55 (statement -> uniforme .)
    UNIFORME        reduce using rule 55 (statement -> uniforme .)
    POISSON         reduce using rule 55 (statement -> uniforme .)
    BINOMIAL        reduce using rule 55 (statement -> uniforme .)
    INT             reduce using rule 55 (statement -> uniforme .)
    FLOAT           reduce using rule 55 (statement -> uniforme .)
    CHAR            reduce using rule 55 (statement -> uniforme .)
    BRACKETCLOSE    reduce using rule 55 (statement -> uniforme .)


state 82

    (56) statement -> poisson .

    IF              reduce using rule 56 (statement -> poisson .)
    PRINT           reduce using rule 56 (statement -> poisson .)
    READ            reduce using rule 56 (statement -> poisson .)
    ID              reduce using rule 56 (statement -> poisson .)
    PLOT            reduce using rule 56 (statement -> poisson .)
    RETURN          reduce using rule 56 (statement -> poisson .)
    WHILE           reduce using rule 56 (statement -> poisson .)
    MAX             reduce using rule 56 (statement -> poisson .)
    MIN             reduce using rule 56 (statement -> poisson .)
    SUM             reduce using rule 56 (statement -> poisson .)
    NORMAL          reduce using rule 56 (statement -> poisson .)
    UNIFORME        reduce using rule 56 (statement -> poisson .)
    POISSON         reduce using rule 56 (statement -> poisson .)
    BINOMIAL        reduce using rule 56 (statement -> poisson .)
    INT             reduce using rule 56 (statement -> poisson .)
    FLOAT           reduce using rule 56 (statement -> poisson .)
    CHAR            reduce using rule 56 (statement -> poisson .)
    BRACKETCLOSE    reduce using rule 56 (statement -> poisson .)


state 83

    (57) statement -> binomial .

    IF              reduce using rule 57 (statement -> binomial .)
    PRINT           reduce using rule 57 (statement -> binomial .)
    READ            reduce using rule 57 (statement -> binomial .)
    ID              reduce using rule 57 (statement -> binomial .)
    PLOT            reduce using rule 57 (statement -> binomial .)
    RETURN          reduce using rule 57 (statement -> binomial .)
    WHILE           reduce using rule 57 (statement -> binomial .)
    MAX             reduce using rule 57 (statement -> binomial .)
    MIN             reduce using rule 57 (statement -> binomial .)
    SUM             reduce using rule 57 (statement -> binomial .)
    NORMAL          reduce using rule 57 (statement -> binomial .)
    UNIFORME        reduce using rule 57 (statement -> binomial .)
    POISSON         reduce using rule 57 (statement -> binomial .)
    BINOMIAL        reduce using rule 57 (statement -> binomial .)
    INT             reduce using rule 57 (statement -> binomial .)
    FLOAT           reduce using rule 57 (statement -> binomial .)
    CHAR            reduce using rule 57 (statement -> binomial .)
    BRACKETCLOSE    reduce using rule 57 (statement -> binomial .)


state 84

    (58) dec_variables -> dec_variabless .

    IF              reduce using rule 58 (dec_variables -> dec_variabless .)
    PRINT           reduce using rule 58 (dec_variables -> dec_variabless .)
    READ            reduce using rule 58 (dec_variables -> dec_variabless .)
    ID              reduce using rule 58 (dec_variables -> dec_variabless .)
    PLOT            reduce using rule 58 (dec_variables -> dec_variabless .)
    RETURN          reduce using rule 58 (dec_variables -> dec_variabless .)
    WHILE           reduce using rule 58 (dec_variables -> dec_variabless .)
    MAX             reduce using rule 58 (dec_variables -> dec_variabless .)
    MIN             reduce using rule 58 (dec_variables -> dec_variabless .)
    SUM             reduce using rule 58 (dec_variables -> dec_variabless .)
    NORMAL          reduce using rule 58 (dec_variables -> dec_variabless .)
    UNIFORME        reduce using rule 58 (dec_variables -> dec_variabless .)
    POISSON         reduce using rule 58 (dec_variables -> dec_variabless .)
    BINOMIAL        reduce using rule 58 (dec_variables -> dec_variabless .)
    INT             reduce using rule 58 (dec_variables -> dec_variabless .)
    FLOAT           reduce using rule 58 (dec_variables -> dec_variabless .)
    CHAR            reduce using rule 58 (dec_variables -> dec_variabless .)
    BRACKETCLOSE    reduce using rule 58 (dec_variables -> dec_variabless .)


state 85

    (68) assignment -> variableAssignment . EQUAL exp SEMICOLON

    EQUAL           shift and go to state 108


state 86

    (107) condition -> IF . PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd
    (108) condition -> IF . PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse

    PARENOPEN       shift and go to state 109


state 87

    (113) writing -> PRINT . PARENOPEN writingg PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 110


state 88

    (119) reading -> READ . multivariables SEMICOLON
    (120) multivariables -> . variable
    (121) multivariables -> . variable COLON multivariables
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 113

    multivariables                 shift and go to state 111
    variable                       shift and go to state 112

state 89

    (69) call_func -> ID . generarERA PARENOPEN call_funcc PARENCLOSE
    (104) variableAssignment -> ID .
    (105) variableAssignment -> ID . BRACEOPEN exp BRACECLOSE
    (106) variableAssignment -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (70) generarERA -> . empty
    (135) empty -> .

    EQUAL           reduce using rule 104 (variableAssignment -> ID .)
    BRACEOPEN       shift and go to state 115
    PARENOPEN       reduce using rule 135 (empty -> .)

    generarERA                     shift and go to state 114
    empty                          shift and go to state 116

state 90

    (127) graph -> PLOT . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 117


state 91

    (126) return -> RETURN . exp SEMICOLON
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 118
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 92

    (122) while_loop -> WHILE . whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (123) whileMigaja -> . empty
    (135) empty -> .

    PARENOPEN       reduce using rule 135 (empty -> .)

    whileMigaja                    shift and go to state 130
    empty                          shift and go to state 131

state 93

    (128) max -> MAX . PARENOPEN ID PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 132


state 94

    (129) min -> MIN . PARENOPEN ID PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 133


state 95

    (130) sum -> SUM . PARENOPEN ID PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 134


state 96

    (134) normal -> NORMAL . PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 135


state 97

    (133) uniforme -> UNIFORME . PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 136


state 98

    (132) poisson -> POISSON . PARENOPEN exp COLON exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 137


state 99

    (131) binomial -> BINOMIAL . PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 138


state 100

    (59) dec_variabless -> type . guardarTipo dec_mvar SEMICOLON dec_variabless
    (60) dec_variabless -> type . guardarTipo dec_mvar SEMICOLON
    (13) guardarTipo -> . empty
    (135) empty -> .

    ID              reduce using rule 135 (empty -> .)

    guardarTipo                    shift and go to state 139
    empty                          shift and go to state 33

state 101

    (23) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam . PARENCLOSE startFunc body exitFunc

    PARENCLOSE      shift and go to state 140


state 102

    (32) numeroParam -> empty .

    PARENCLOSE      reduce using rule 32 (numeroParam -> empty .)


state 103

    (26) param -> typeParam ID .
    (27) param -> typeParam ID . COLON param

    PARENCLOSE      reduce using rule 26 (param -> typeParam ID .)
    COLON           shift and go to state 141


state 104

    (24) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam . PARENCLOSE startFunc body exitFunc

    PARENCLOSE      shift and go to state 142


state 105

    (15) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE . COLON mvar
    (16) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (18) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE .
    (19) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 144
    BRACEOPEN       shift and go to state 143
    SEMICOLON       reduce using rule 18 (mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE .)


state 106

    (38) body -> BRACKETOPEN bodyy BRACKETCLOSE .

    $end            reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FUNCTION        reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MAIN            reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    ELSE            reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    IF              reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    PRINT           reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    READ            reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    ID              reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    PLOT            reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    RETURN          reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    WHILE           reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MAX             reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MIN             reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    SUM             reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    NORMAL          reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    UNIFORME        reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    POISSON         reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    BINOMIAL        reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    INT             reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FLOAT           reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    CHAR            reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    BRACKETCLOSE    reduce using rule 38 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)


state 107

    (40) bodyy -> statement bodyy .

    BRACKETCLOSE    reduce using rule 40 (bodyy -> statement bodyy .)


state 108

    (68) assignment -> variableAssignment EQUAL . exp SEMICOLON
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 145
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 109

    (107) condition -> IF PARENOPEN . exp PARENCLOSE cuadruploIF body ifEnd
    (108) condition -> IF PARENOPEN . exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 146
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 110

    (113) writing -> PRINT PARENOPEN . writingg PARENCLOSE SEMICOLON
    (114) writingg -> . exp
    (115) writingg -> . exp COLON writingg
    (116) writingg -> . auxString
    (117) writingg -> . auxString COLON writingg
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (118) auxString -> . CTESTRING
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 150
    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    writingg                       shift and go to state 147
    exp                            shift and go to state 148
    auxString                      shift and go to state 149
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 111

    (119) reading -> READ multivariables . SEMICOLON

    SEMICOLON       shift and go to state 151


state 112

    (120) multivariables -> variable .
    (121) multivariables -> variable . COLON multivariables

    SEMICOLON       reduce using rule 120 (multivariables -> variable .)
    COLON           shift and go to state 152


state 113

    (101) variable -> ID .
    (102) variable -> ID . BRACEOPEN exp BRACECLOSE
    (103) variable -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    COLON           reduce using rule 101 (variable -> ID .)
    SEMICOLON       reduce using rule 101 (variable -> ID .)
    BRACEOPEN       shift and go to state 153


state 114

    (69) call_func -> ID generarERA . PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 154


state 115

    (105) variableAssignment -> ID BRACEOPEN . exp BRACECLOSE
    (106) variableAssignment -> ID BRACEOPEN . exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 155
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 116

    (70) generarERA -> empty .

    PARENOPEN       reduce using rule 70 (generarERA -> empty .)


state 117

    (127) graph -> PLOT PARENOPEN . exp PARENCLOSE SEMICOLON
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 156
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 118

    (126) return -> RETURN exp . SEMICOLON
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    SEMICOLON       shift and go to state 157
    AND             shift and go to state 158
    OR              shift and go to state 159


state 119

    (75) exp -> expp .
    (79) expp -> expp . GREATHERTHAN m_exp
    (80) expp -> expp . LESSTHAN m_exp
    (81) expp -> expp . GREATHEREQUAL m_exp
    (82) expp -> expp . LESSEQUAL m_exp
    (83) expp -> expp . DIFFERENT m_exp
    (84) expp -> expp . SAME m_exp

    SEMICOLON       reduce using rule 75 (exp -> expp .)
    AND             reduce using rule 75 (exp -> expp .)
    OR              reduce using rule 75 (exp -> expp .)
    PARENCLOSE      reduce using rule 75 (exp -> expp .)
    COLON           reduce using rule 75 (exp -> expp .)
    BRACECLOSE      reduce using rule 75 (exp -> expp .)
    GREATHERTHAN    shift and go to state 160
    LESSTHAN        shift and go to state 161
    GREATHEREQUAL   shift and go to state 162
    LESSEQUAL       shift and go to state 163
    DIFFERENT       shift and go to state 164
    SAME            shift and go to state 165


state 120

    (78) expp -> m_exp .
    (86) m_exp -> m_exp . PLUS termino
    (87) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 78 (expp -> m_exp .)
    LESSTHAN        reduce using rule 78 (expp -> m_exp .)
    GREATHEREQUAL   reduce using rule 78 (expp -> m_exp .)
    LESSEQUAL       reduce using rule 78 (expp -> m_exp .)
    DIFFERENT       reduce using rule 78 (expp -> m_exp .)
    SAME            reduce using rule 78 (expp -> m_exp .)
    SEMICOLON       reduce using rule 78 (expp -> m_exp .)
    AND             reduce using rule 78 (expp -> m_exp .)
    OR              reduce using rule 78 (expp -> m_exp .)
    PARENCLOSE      reduce using rule 78 (expp -> m_exp .)
    COLON           reduce using rule 78 (expp -> m_exp .)
    BRACECLOSE      reduce using rule 78 (expp -> m_exp .)
    PLUS            shift and go to state 166
    MINUS           shift and go to state 167


state 121

    (85) m_exp -> termino .
    (89) termino -> termino . MULTIPLY factor
    (90) termino -> termino . DIVIDE factor

    PLUS            reduce using rule 85 (m_exp -> termino .)
    MINUS           reduce using rule 85 (m_exp -> termino .)
    GREATHERTHAN    reduce using rule 85 (m_exp -> termino .)
    LESSTHAN        reduce using rule 85 (m_exp -> termino .)
    GREATHEREQUAL   reduce using rule 85 (m_exp -> termino .)
    LESSEQUAL       reduce using rule 85 (m_exp -> termino .)
    DIFFERENT       reduce using rule 85 (m_exp -> termino .)
    SAME            reduce using rule 85 (m_exp -> termino .)
    SEMICOLON       reduce using rule 85 (m_exp -> termino .)
    AND             reduce using rule 85 (m_exp -> termino .)
    OR              reduce using rule 85 (m_exp -> termino .)
    PARENCLOSE      reduce using rule 85 (m_exp -> termino .)
    COLON           reduce using rule 85 (m_exp -> termino .)
    BRACECLOSE      reduce using rule 85 (m_exp -> termino .)
    MULTIPLY        shift and go to state 168
    DIVIDE          shift and go to state 169


state 122

    (88) termino -> factor .

    MULTIPLY        reduce using rule 88 (termino -> factor .)
    DIVIDE          reduce using rule 88 (termino -> factor .)
    PLUS            reduce using rule 88 (termino -> factor .)
    MINUS           reduce using rule 88 (termino -> factor .)
    GREATHERTHAN    reduce using rule 88 (termino -> factor .)
    LESSTHAN        reduce using rule 88 (termino -> factor .)
    GREATHEREQUAL   reduce using rule 88 (termino -> factor .)
    LESSEQUAL       reduce using rule 88 (termino -> factor .)
    DIFFERENT       reduce using rule 88 (termino -> factor .)
    SAME            reduce using rule 88 (termino -> factor .)
    SEMICOLON       reduce using rule 88 (termino -> factor .)
    AND             reduce using rule 88 (termino -> factor .)
    OR              reduce using rule 88 (termino -> factor .)
    PARENCLOSE      reduce using rule 88 (termino -> factor .)
    COLON           reduce using rule 88 (termino -> factor .)
    BRACECLOSE      reduce using rule 88 (termino -> factor .)


state 123

    (91) factor -> ID .
    (101) variable -> ID .
    (102) variable -> ID . BRACEOPEN exp BRACECLOSE
    (103) variable -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> ID . generarERA PARENOPEN call_funcc PARENCLOSE
    (70) generarERA -> . empty
    (135) empty -> .

  ! reduce/reduce conflict for MULTIPLY resolved using rule 91 (factor -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 91 (factor -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 91 (factor -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 91 (factor -> ID .)
  ! reduce/reduce conflict for GREATHERTHAN resolved using rule 91 (factor -> ID .)
  ! reduce/reduce conflict for LESSTHAN resolved using rule 91 (factor -> ID .)
  ! reduce/reduce conflict for GREATHEREQUAL resolved using rule 91 (factor -> ID .)
  ! reduce/reduce conflict for LESSEQUAL resolved using rule 91 (factor -> ID .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 91 (factor -> ID .)
  ! reduce/reduce conflict for SAME resolved using rule 91 (factor -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 91 (factor -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 91 (factor -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 91 (factor -> ID .)
  ! reduce/reduce conflict for PARENCLOSE resolved using rule 91 (factor -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 91 (factor -> ID .)
  ! reduce/reduce conflict for BRACECLOSE resolved using rule 91 (factor -> ID .)
    MULTIPLY        reduce using rule 91 (factor -> ID .)
    DIVIDE          reduce using rule 91 (factor -> ID .)
    PLUS            reduce using rule 91 (factor -> ID .)
    MINUS           reduce using rule 91 (factor -> ID .)
    GREATHERTHAN    reduce using rule 91 (factor -> ID .)
    LESSTHAN        reduce using rule 91 (factor -> ID .)
    GREATHEREQUAL   reduce using rule 91 (factor -> ID .)
    LESSEQUAL       reduce using rule 91 (factor -> ID .)
    DIFFERENT       reduce using rule 91 (factor -> ID .)
    SAME            reduce using rule 91 (factor -> ID .)
    SEMICOLON       reduce using rule 91 (factor -> ID .)
    AND             reduce using rule 91 (factor -> ID .)
    OR              reduce using rule 91 (factor -> ID .)
    PARENCLOSE      reduce using rule 91 (factor -> ID .)
    COLON           reduce using rule 91 (factor -> ID .)
    BRACECLOSE      reduce using rule 91 (factor -> ID .)
    BRACEOPEN       shift and go to state 153
    PARENOPEN       reduce using rule 135 (empty -> .)

  ! MULTIPLY        [ reduce using rule 101 (variable -> ID .) ]
  ! DIVIDE          [ reduce using rule 101 (variable -> ID .) ]
  ! PLUS            [ reduce using rule 101 (variable -> ID .) ]
  ! MINUS           [ reduce using rule 101 (variable -> ID .) ]
  ! GREATHERTHAN    [ reduce using rule 101 (variable -> ID .) ]
  ! LESSTHAN        [ reduce using rule 101 (variable -> ID .) ]
  ! GREATHEREQUAL   [ reduce using rule 101 (variable -> ID .) ]
  ! LESSEQUAL       [ reduce using rule 101 (variable -> ID .) ]
  ! DIFFERENT       [ reduce using rule 101 (variable -> ID .) ]
  ! SAME            [ reduce using rule 101 (variable -> ID .) ]
  ! SEMICOLON       [ reduce using rule 101 (variable -> ID .) ]
  ! AND             [ reduce using rule 101 (variable -> ID .) ]
  ! OR              [ reduce using rule 101 (variable -> ID .) ]
  ! PARENCLOSE      [ reduce using rule 101 (variable -> ID .) ]
  ! COLON           [ reduce using rule 101 (variable -> ID .) ]
  ! BRACECLOSE      [ reduce using rule 101 (variable -> ID .) ]

    generarERA                     shift and go to state 114
    empty                          shift and go to state 116

state 124

    (92) factor -> CTEINT . guardarConstanteInt
    (98) guardarConstanteInt -> . empty
    (135) empty -> .

    MULTIPLY        reduce using rule 135 (empty -> .)
    DIVIDE          reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GREATHERTHAN    reduce using rule 135 (empty -> .)
    LESSTHAN        reduce using rule 135 (empty -> .)
    GREATHEREQUAL   reduce using rule 135 (empty -> .)
    LESSEQUAL       reduce using rule 135 (empty -> .)
    DIFFERENT       reduce using rule 135 (empty -> .)
    SAME            reduce using rule 135 (empty -> .)
    SEMICOLON       reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    PARENCLOSE      reduce using rule 135 (empty -> .)
    COLON           reduce using rule 135 (empty -> .)
    BRACECLOSE      reduce using rule 135 (empty -> .)

    guardarConstanteInt            shift and go to state 170
    empty                          shift and go to state 171

state 125

    (93) factor -> CTFLOAT . guardarConstanteFloat
    (99) guardarConstanteFloat -> . empty
    (135) empty -> .

    MULTIPLY        reduce using rule 135 (empty -> .)
    DIVIDE          reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GREATHERTHAN    reduce using rule 135 (empty -> .)
    LESSTHAN        reduce using rule 135 (empty -> .)
    GREATHEREQUAL   reduce using rule 135 (empty -> .)
    LESSEQUAL       reduce using rule 135 (empty -> .)
    DIFFERENT       reduce using rule 135 (empty -> .)
    SAME            reduce using rule 135 (empty -> .)
    SEMICOLON       reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    PARENCLOSE      reduce using rule 135 (empty -> .)
    COLON           reduce using rule 135 (empty -> .)
    BRACECLOSE      reduce using rule 135 (empty -> .)

    guardarConstanteFloat          shift and go to state 172
    empty                          shift and go to state 173

state 126

    (94) factor -> CTECHAR . guardarConstanteChar
    (100) guardarConstanteChar -> . empty
    (135) empty -> .

    MULTIPLY        reduce using rule 135 (empty -> .)
    DIVIDE          reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GREATHERTHAN    reduce using rule 135 (empty -> .)
    LESSTHAN        reduce using rule 135 (empty -> .)
    GREATHEREQUAL   reduce using rule 135 (empty -> .)
    LESSEQUAL       reduce using rule 135 (empty -> .)
    DIFFERENT       reduce using rule 135 (empty -> .)
    SAME            reduce using rule 135 (empty -> .)
    SEMICOLON       reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    PARENCLOSE      reduce using rule 135 (empty -> .)
    COLON           reduce using rule 135 (empty -> .)
    BRACECLOSE      reduce using rule 135 (empty -> .)

    guardarConstanteChar           shift and go to state 174
    empty                          shift and go to state 175

state 127

    (95) factor -> variable .

    MULTIPLY        reduce using rule 95 (factor -> variable .)
    DIVIDE          reduce using rule 95 (factor -> variable .)
    PLUS            reduce using rule 95 (factor -> variable .)
    MINUS           reduce using rule 95 (factor -> variable .)
    GREATHERTHAN    reduce using rule 95 (factor -> variable .)
    LESSTHAN        reduce using rule 95 (factor -> variable .)
    GREATHEREQUAL   reduce using rule 95 (factor -> variable .)
    LESSEQUAL       reduce using rule 95 (factor -> variable .)
    DIFFERENT       reduce using rule 95 (factor -> variable .)
    SAME            reduce using rule 95 (factor -> variable .)
    SEMICOLON       reduce using rule 95 (factor -> variable .)
    AND             reduce using rule 95 (factor -> variable .)
    OR              reduce using rule 95 (factor -> variable .)
    PARENCLOSE      reduce using rule 95 (factor -> variable .)
    COLON           reduce using rule 95 (factor -> variable .)
    BRACECLOSE      reduce using rule 95 (factor -> variable .)


state 128

    (96) factor -> call_func .

    MULTIPLY        reduce using rule 96 (factor -> call_func .)
    DIVIDE          reduce using rule 96 (factor -> call_func .)
    PLUS            reduce using rule 96 (factor -> call_func .)
    MINUS           reduce using rule 96 (factor -> call_func .)
    GREATHERTHAN    reduce using rule 96 (factor -> call_func .)
    LESSTHAN        reduce using rule 96 (factor -> call_func .)
    GREATHEREQUAL   reduce using rule 96 (factor -> call_func .)
    LESSEQUAL       reduce using rule 96 (factor -> call_func .)
    DIFFERENT       reduce using rule 96 (factor -> call_func .)
    SAME            reduce using rule 96 (factor -> call_func .)
    SEMICOLON       reduce using rule 96 (factor -> call_func .)
    AND             reduce using rule 96 (factor -> call_func .)
    OR              reduce using rule 96 (factor -> call_func .)
    PARENCLOSE      reduce using rule 96 (factor -> call_func .)
    COLON           reduce using rule 96 (factor -> call_func .)
    BRACECLOSE      reduce using rule 96 (factor -> call_func .)


state 129

    (97) factor -> PARENOPEN . exp PARENCLOSE
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 176
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 130

    (122) while_loop -> WHILE whileMigaja . PARENOPEN exp PARENCLOSE whileEval body whileEnd

    PARENOPEN       shift and go to state 177


state 131

    (123) whileMigaja -> empty .

    PARENOPEN       reduce using rule 123 (whileMigaja -> empty .)


state 132

    (128) max -> MAX PARENOPEN . ID PARENCLOSE SEMICOLON

    ID              shift and go to state 178


state 133

    (129) min -> MIN PARENOPEN . ID PARENCLOSE SEMICOLON

    ID              shift and go to state 179


state 134

    (130) sum -> SUM PARENOPEN . ID PARENCLOSE SEMICOLON

    ID              shift and go to state 180


state 135

    (134) normal -> NORMAL PARENOPEN . exp COLON exp COLON exp PARENCLOSE SEMICOLON
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 181
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 136

    (133) uniforme -> UNIFORME PARENOPEN . exp COLON exp COLON exp PARENCLOSE SEMICOLON
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 182
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 137

    (132) poisson -> POISSON PARENOPEN . exp COLON exp PARENCLOSE SEMICOLON
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 183
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 138

    (131) binomial -> BINOMIAL PARENOPEN . exp COLON exp COLON exp PARENCLOSE SEMICOLON
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 184
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 139

    (59) dec_variabless -> type guardarTipo . dec_mvar SEMICOLON dec_variabless
    (60) dec_variabless -> type guardarTipo . dec_mvar SEMICOLON
    (61) dec_mvar -> . ID guardarID COLON dec_mvar
    (62) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (63) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (64) dec_mvar -> . ID guardarID
    (65) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE
    (66) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 186

    dec_mvar                       shift and go to state 185

state 140

    (23) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE . startFunc body exitFunc
    (33) startFunc -> . empty
    (135) empty -> .

    BRACKETOPEN     reduce using rule 135 (empty -> .)

    startFunc                      shift and go to state 187
    empty                          shift and go to state 188

state 141

    (27) param -> typeParam ID COLON . param
    (26) param -> . typeParam ID
    (27) param -> . typeParam ID COLON param
    (28) param -> . empty
    (29) typeParam -> . INT
    (30) typeParam -> . FLOAT
    (31) typeParam -> . CHAR
    (135) empty -> .

    INT             shift and go to state 59
    FLOAT           shift and go to state 60
    CHAR            shift and go to state 61
    PARENCLOSE      reduce using rule 135 (empty -> .)

    typeParam                      shift and go to state 57
    param                          shift and go to state 189
    empty                          shift and go to state 58

state 142

    (24) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE . startFunc body exitFunc
    (33) startFunc -> . empty
    (135) empty -> .

    BRACKETOPEN     reduce using rule 135 (empty -> .)

    startFunc                      shift and go to state 190
    empty                          shift and go to state 188

state 143

    (16) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE COLON mvar
    (19) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE

    CTEINT          shift and go to state 191


state 144

    (15) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON . mvar
    (14) mvar -> . ID guardarIDvar COLON mvar
    (15) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (16) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID guardarIDvar
    (18) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE
    (19) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 39

    mvar                           shift and go to state 192

state 145

    (68) assignment -> variableAssignment EQUAL exp . SEMICOLON
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    SEMICOLON       shift and go to state 193
    AND             shift and go to state 158
    OR              shift and go to state 159


state 146

    (107) condition -> IF PARENOPEN exp . PARENCLOSE cuadruploIF body ifEnd
    (108) condition -> IF PARENOPEN exp . PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 194
    AND             shift and go to state 158
    OR              shift and go to state 159


state 147

    (113) writing -> PRINT PARENOPEN writingg . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 195


state 148

    (114) writingg -> exp .
    (115) writingg -> exp . COLON writingg
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    PARENCLOSE      reduce using rule 114 (writingg -> exp .)
    COLON           shift and go to state 196
    AND             shift and go to state 158
    OR              shift and go to state 159


state 149

    (116) writingg -> auxString .
    (117) writingg -> auxString . COLON writingg

    PARENCLOSE      reduce using rule 116 (writingg -> auxString .)
    COLON           shift and go to state 197


state 150

    (118) auxString -> CTESTRING .

    COLON           reduce using rule 118 (auxString -> CTESTRING .)
    PARENCLOSE      reduce using rule 118 (auxString -> CTESTRING .)


state 151

    (119) reading -> READ multivariables SEMICOLON .

    IF              reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    PRINT           reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    READ            reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    ID              reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    PLOT            reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    RETURN          reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    WHILE           reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    MAX             reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    MIN             reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    SUM             reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    NORMAL          reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    UNIFORME        reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    POISSON         reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    BINOMIAL        reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    INT             reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    FLOAT           reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    CHAR            reduce using rule 119 (reading -> READ multivariables SEMICOLON .)
    BRACKETCLOSE    reduce using rule 119 (reading -> READ multivariables SEMICOLON .)


state 152

    (121) multivariables -> variable COLON . multivariables
    (120) multivariables -> . variable
    (121) multivariables -> . variable COLON multivariables
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 113

    variable                       shift and go to state 112
    multivariables                 shift and go to state 198

state 153

    (102) variable -> ID BRACEOPEN . exp BRACECLOSE
    (103) variable -> ID BRACEOPEN . exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 199
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 154

    (69) call_func -> ID generarERA PARENOPEN . call_funcc PARENCLOSE
    (71) call_funcc -> . exp mandarParam
    (72) call_funcc -> . exp mandarParam COLON call_funcc
    (73) call_funcc -> . empty
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (135) empty -> .
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    PARENCLOSE      reduce using rule 135 (empty -> .)
    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    call_funcc                     shift and go to state 200
    exp                            shift and go to state 201
    empty                          shift and go to state 202
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 155

    (105) variableAssignment -> ID BRACEOPEN exp . BRACECLOSE
    (106) variableAssignment -> ID BRACEOPEN exp . BRACECLOSE BRACEOPEN exp BRACECLOSE
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    BRACECLOSE      shift and go to state 203
    AND             shift and go to state 158
    OR              shift and go to state 159


state 156

    (127) graph -> PLOT PARENOPEN exp . PARENCLOSE SEMICOLON
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 204
    AND             shift and go to state 158
    OR              shift and go to state 159


state 157

    (126) return -> RETURN exp SEMICOLON .

    IF              reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    PRINT           reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    READ            reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    ID              reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    PLOT            reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    RETURN          reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    WHILE           reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    MAX             reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    MIN             reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    SUM             reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    NORMAL          reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    UNIFORME        reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    POISSON         reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    BINOMIAL        reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    INT             reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    FLOAT           reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    CHAR            reduce using rule 126 (return -> RETURN exp SEMICOLON .)
    BRACKETCLOSE    reduce using rule 126 (return -> RETURN exp SEMICOLON .)


state 158

    (76) exp -> exp AND . expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    expp                           shift and go to state 205
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 159

    (77) exp -> exp OR . expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    expp                           shift and go to state 206
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 160

    (79) expp -> expp GREATHERTHAN . m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    m_exp                          shift and go to state 207
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 161

    (80) expp -> expp LESSTHAN . m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    m_exp                          shift and go to state 208
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 162

    (81) expp -> expp GREATHEREQUAL . m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    m_exp                          shift and go to state 209
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 163

    (82) expp -> expp LESSEQUAL . m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    m_exp                          shift and go to state 210
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 164

    (83) expp -> expp DIFFERENT . m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    m_exp                          shift and go to state 211
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 165

    (84) expp -> expp SAME . m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    m_exp                          shift and go to state 212
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 166

    (86) m_exp -> m_exp PLUS . termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    termino                        shift and go to state 213
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 167

    (87) m_exp -> m_exp MINUS . termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    termino                        shift and go to state 214
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 168

    (89) termino -> termino MULTIPLY . factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    factor                         shift and go to state 215
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 169

    (90) termino -> termino DIVIDE . factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    factor                         shift and go to state 216
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 170

    (92) factor -> CTEINT guardarConstanteInt .

    MULTIPLY        reduce using rule 92 (factor -> CTEINT guardarConstanteInt .)
    DIVIDE          reduce using rule 92 (factor -> CTEINT guardarConstanteInt .)
    PLUS            reduce using rule 92 (factor -> CTEINT guardarConstanteInt .)
    MINUS           reduce using rule 92 (factor -> CTEINT guardarConstanteInt .)
    GREATHERTHAN    reduce using rule 92 (factor -> CTEINT guardarConstanteInt .)
    LESSTHAN        reduce using rule 92 (factor -> CTEINT guardarConstanteInt .)
    GREATHEREQUAL   reduce using rule 92 (factor -> CTEINT guardarConstanteInt .)
    LESSEQUAL       reduce using rule 92 (factor -> CTEINT guardarConstanteInt .)
    DIFFERENT       reduce using rule 92 (factor -> CTEINT guardarConstanteInt .)
    SAME            reduce using rule 92 (factor -> CTEINT guardarConstanteInt .)
    SEMICOLON       reduce using rule 92 (factor -> CTEINT guardarConstanteInt .)
    AND             reduce using rule 92 (factor -> CTEINT guardarConstanteInt .)
    OR              reduce using rule 92 (factor -> CTEINT guardarConstanteInt .)
    PARENCLOSE      reduce using rule 92 (factor -> CTEINT guardarConstanteInt .)
    COLON           reduce using rule 92 (factor -> CTEINT guardarConstanteInt .)
    BRACECLOSE      reduce using rule 92 (factor -> CTEINT guardarConstanteInt .)


state 171

    (98) guardarConstanteInt -> empty .

    MULTIPLY        reduce using rule 98 (guardarConstanteInt -> empty .)
    DIVIDE          reduce using rule 98 (guardarConstanteInt -> empty .)
    PLUS            reduce using rule 98 (guardarConstanteInt -> empty .)
    MINUS           reduce using rule 98 (guardarConstanteInt -> empty .)
    GREATHERTHAN    reduce using rule 98 (guardarConstanteInt -> empty .)
    LESSTHAN        reduce using rule 98 (guardarConstanteInt -> empty .)
    GREATHEREQUAL   reduce using rule 98 (guardarConstanteInt -> empty .)
    LESSEQUAL       reduce using rule 98 (guardarConstanteInt -> empty .)
    DIFFERENT       reduce using rule 98 (guardarConstanteInt -> empty .)
    SAME            reduce using rule 98 (guardarConstanteInt -> empty .)
    SEMICOLON       reduce using rule 98 (guardarConstanteInt -> empty .)
    AND             reduce using rule 98 (guardarConstanteInt -> empty .)
    OR              reduce using rule 98 (guardarConstanteInt -> empty .)
    PARENCLOSE      reduce using rule 98 (guardarConstanteInt -> empty .)
    COLON           reduce using rule 98 (guardarConstanteInt -> empty .)
    BRACECLOSE      reduce using rule 98 (guardarConstanteInt -> empty .)


state 172

    (93) factor -> CTFLOAT guardarConstanteFloat .

    MULTIPLY        reduce using rule 93 (factor -> CTFLOAT guardarConstanteFloat .)
    DIVIDE          reduce using rule 93 (factor -> CTFLOAT guardarConstanteFloat .)
    PLUS            reduce using rule 93 (factor -> CTFLOAT guardarConstanteFloat .)
    MINUS           reduce using rule 93 (factor -> CTFLOAT guardarConstanteFloat .)
    GREATHERTHAN    reduce using rule 93 (factor -> CTFLOAT guardarConstanteFloat .)
    LESSTHAN        reduce using rule 93 (factor -> CTFLOAT guardarConstanteFloat .)
    GREATHEREQUAL   reduce using rule 93 (factor -> CTFLOAT guardarConstanteFloat .)
    LESSEQUAL       reduce using rule 93 (factor -> CTFLOAT guardarConstanteFloat .)
    DIFFERENT       reduce using rule 93 (factor -> CTFLOAT guardarConstanteFloat .)
    SAME            reduce using rule 93 (factor -> CTFLOAT guardarConstanteFloat .)
    SEMICOLON       reduce using rule 93 (factor -> CTFLOAT guardarConstanteFloat .)
    AND             reduce using rule 93 (factor -> CTFLOAT guardarConstanteFloat .)
    OR              reduce using rule 93 (factor -> CTFLOAT guardarConstanteFloat .)
    PARENCLOSE      reduce using rule 93 (factor -> CTFLOAT guardarConstanteFloat .)
    COLON           reduce using rule 93 (factor -> CTFLOAT guardarConstanteFloat .)
    BRACECLOSE      reduce using rule 93 (factor -> CTFLOAT guardarConstanteFloat .)


state 173

    (99) guardarConstanteFloat -> empty .

    MULTIPLY        reduce using rule 99 (guardarConstanteFloat -> empty .)
    DIVIDE          reduce using rule 99 (guardarConstanteFloat -> empty .)
    PLUS            reduce using rule 99 (guardarConstanteFloat -> empty .)
    MINUS           reduce using rule 99 (guardarConstanteFloat -> empty .)
    GREATHERTHAN    reduce using rule 99 (guardarConstanteFloat -> empty .)
    LESSTHAN        reduce using rule 99 (guardarConstanteFloat -> empty .)
    GREATHEREQUAL   reduce using rule 99 (guardarConstanteFloat -> empty .)
    LESSEQUAL       reduce using rule 99 (guardarConstanteFloat -> empty .)
    DIFFERENT       reduce using rule 99 (guardarConstanteFloat -> empty .)
    SAME            reduce using rule 99 (guardarConstanteFloat -> empty .)
    SEMICOLON       reduce using rule 99 (guardarConstanteFloat -> empty .)
    AND             reduce using rule 99 (guardarConstanteFloat -> empty .)
    OR              reduce using rule 99 (guardarConstanteFloat -> empty .)
    PARENCLOSE      reduce using rule 99 (guardarConstanteFloat -> empty .)
    COLON           reduce using rule 99 (guardarConstanteFloat -> empty .)
    BRACECLOSE      reduce using rule 99 (guardarConstanteFloat -> empty .)


state 174

    (94) factor -> CTECHAR guardarConstanteChar .

    MULTIPLY        reduce using rule 94 (factor -> CTECHAR guardarConstanteChar .)
    DIVIDE          reduce using rule 94 (factor -> CTECHAR guardarConstanteChar .)
    PLUS            reduce using rule 94 (factor -> CTECHAR guardarConstanteChar .)
    MINUS           reduce using rule 94 (factor -> CTECHAR guardarConstanteChar .)
    GREATHERTHAN    reduce using rule 94 (factor -> CTECHAR guardarConstanteChar .)
    LESSTHAN        reduce using rule 94 (factor -> CTECHAR guardarConstanteChar .)
    GREATHEREQUAL   reduce using rule 94 (factor -> CTECHAR guardarConstanteChar .)
    LESSEQUAL       reduce using rule 94 (factor -> CTECHAR guardarConstanteChar .)
    DIFFERENT       reduce using rule 94 (factor -> CTECHAR guardarConstanteChar .)
    SAME            reduce using rule 94 (factor -> CTECHAR guardarConstanteChar .)
    SEMICOLON       reduce using rule 94 (factor -> CTECHAR guardarConstanteChar .)
    AND             reduce using rule 94 (factor -> CTECHAR guardarConstanteChar .)
    OR              reduce using rule 94 (factor -> CTECHAR guardarConstanteChar .)
    PARENCLOSE      reduce using rule 94 (factor -> CTECHAR guardarConstanteChar .)
    COLON           reduce using rule 94 (factor -> CTECHAR guardarConstanteChar .)
    BRACECLOSE      reduce using rule 94 (factor -> CTECHAR guardarConstanteChar .)


state 175

    (100) guardarConstanteChar -> empty .

    MULTIPLY        reduce using rule 100 (guardarConstanteChar -> empty .)
    DIVIDE          reduce using rule 100 (guardarConstanteChar -> empty .)
    PLUS            reduce using rule 100 (guardarConstanteChar -> empty .)
    MINUS           reduce using rule 100 (guardarConstanteChar -> empty .)
    GREATHERTHAN    reduce using rule 100 (guardarConstanteChar -> empty .)
    LESSTHAN        reduce using rule 100 (guardarConstanteChar -> empty .)
    GREATHEREQUAL   reduce using rule 100 (guardarConstanteChar -> empty .)
    LESSEQUAL       reduce using rule 100 (guardarConstanteChar -> empty .)
    DIFFERENT       reduce using rule 100 (guardarConstanteChar -> empty .)
    SAME            reduce using rule 100 (guardarConstanteChar -> empty .)
    SEMICOLON       reduce using rule 100 (guardarConstanteChar -> empty .)
    AND             reduce using rule 100 (guardarConstanteChar -> empty .)
    OR              reduce using rule 100 (guardarConstanteChar -> empty .)
    PARENCLOSE      reduce using rule 100 (guardarConstanteChar -> empty .)
    COLON           reduce using rule 100 (guardarConstanteChar -> empty .)
    BRACECLOSE      reduce using rule 100 (guardarConstanteChar -> empty .)


state 176

    (97) factor -> PARENOPEN exp . PARENCLOSE
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 217
    AND             shift and go to state 158
    OR              shift and go to state 159


state 177

    (122) while_loop -> WHILE whileMigaja PARENOPEN . exp PARENCLOSE whileEval body whileEnd
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 218
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 178

    (128) max -> MAX PARENOPEN ID . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 219


state 179

    (129) min -> MIN PARENOPEN ID . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 220


state 180

    (130) sum -> SUM PARENOPEN ID . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 221


state 181

    (134) normal -> NORMAL PARENOPEN exp . COLON exp COLON exp PARENCLOSE SEMICOLON
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    COLON           shift and go to state 222
    AND             shift and go to state 158
    OR              shift and go to state 159


state 182

    (133) uniforme -> UNIFORME PARENOPEN exp . COLON exp COLON exp PARENCLOSE SEMICOLON
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    COLON           shift and go to state 223
    AND             shift and go to state 158
    OR              shift and go to state 159


state 183

    (132) poisson -> POISSON PARENOPEN exp . COLON exp PARENCLOSE SEMICOLON
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    COLON           shift and go to state 224
    AND             shift and go to state 158
    OR              shift and go to state 159


state 184

    (131) binomial -> BINOMIAL PARENOPEN exp . COLON exp COLON exp PARENCLOSE SEMICOLON
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    COLON           shift and go to state 225
    AND             shift and go to state 158
    OR              shift and go to state 159


state 185

    (59) dec_variabless -> type guardarTipo dec_mvar . SEMICOLON dec_variabless
    (60) dec_variabless -> type guardarTipo dec_mvar . SEMICOLON

    SEMICOLON       shift and go to state 226


state 186

    (61) dec_mvar -> ID . guardarID COLON dec_mvar
    (62) dec_mvar -> ID . guardarID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (63) dec_mvar -> ID . guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (64) dec_mvar -> ID . guardarID
    (65) dec_mvar -> ID . guardarID BRACEOPEN CTEINT BRACECLOSE
    (66) dec_mvar -> ID . guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE
    (67) guardarID -> . empty
    (135) empty -> .

    COLON           reduce using rule 135 (empty -> .)
    BRACEOPEN       reduce using rule 135 (empty -> .)
    SEMICOLON       reduce using rule 135 (empty -> .)

    guardarID                      shift and go to state 227
    empty                          shift and go to state 228

state 187

    (23) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc . body exitFunc
    (38) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 55

    body                           shift and go to state 229

state 188

    (33) startFunc -> empty .

    BRACKETOPEN     reduce using rule 33 (startFunc -> empty .)


state 189

    (27) param -> typeParam ID COLON param .

    PARENCLOSE      reduce using rule 27 (param -> typeParam ID COLON param .)


state 190

    (24) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc . body exitFunc
    (38) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 55

    body                           shift and go to state 230

state 191

    (16) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE COLON mvar
    (19) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE

    BRACECLOSE      shift and go to state 231


state 192

    (15) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON mvar .

    SEMICOLON       reduce using rule 15 (mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON mvar .)


state 193

    (68) assignment -> variableAssignment EQUAL exp SEMICOLON .

    IF              reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    PRINT           reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    READ            reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    ID              reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    PLOT            reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    RETURN          reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    WHILE           reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    MAX             reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    MIN             reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    SUM             reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    NORMAL          reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    UNIFORME        reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    POISSON         reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    BINOMIAL        reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    INT             reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    FLOAT           reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    CHAR            reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)
    BRACKETCLOSE    reduce using rule 68 (assignment -> variableAssignment EQUAL exp SEMICOLON .)


state 194

    (107) condition -> IF PARENOPEN exp PARENCLOSE . cuadruploIF body ifEnd
    (108) condition -> IF PARENOPEN exp PARENCLOSE . cuadruploIF body cuadruploElse ELSE body ifEndElse
    (109) cuadruploIF -> . empty
    (135) empty -> .

    BRACKETOPEN     reduce using rule 135 (empty -> .)

    cuadruploIF                    shift and go to state 232
    empty                          shift and go to state 233

state 195

    (113) writing -> PRINT PARENOPEN writingg PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 234


state 196

    (115) writingg -> exp COLON . writingg
    (114) writingg -> . exp
    (115) writingg -> . exp COLON writingg
    (116) writingg -> . auxString
    (117) writingg -> . auxString COLON writingg
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (118) auxString -> . CTESTRING
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 150
    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 148
    writingg                       shift and go to state 235
    auxString                      shift and go to state 149
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 197

    (117) writingg -> auxString COLON . writingg
    (114) writingg -> . exp
    (115) writingg -> . exp COLON writingg
    (116) writingg -> . auxString
    (117) writingg -> . auxString COLON writingg
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (118) auxString -> . CTESTRING
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 150
    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    auxString                      shift and go to state 149
    writingg                       shift and go to state 236
    exp                            shift and go to state 148
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 198

    (121) multivariables -> variable COLON multivariables .

    SEMICOLON       reduce using rule 121 (multivariables -> variable COLON multivariables .)


state 199

    (102) variable -> ID BRACEOPEN exp . BRACECLOSE
    (103) variable -> ID BRACEOPEN exp . BRACECLOSE BRACEOPEN exp BRACECLOSE
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    BRACECLOSE      shift and go to state 237
    AND             shift and go to state 158
    OR              shift and go to state 159


state 200

    (69) call_func -> ID generarERA PARENOPEN call_funcc . PARENCLOSE

    PARENCLOSE      shift and go to state 238


state 201

    (71) call_funcc -> exp . mandarParam
    (72) call_funcc -> exp . mandarParam COLON call_funcc
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp
    (74) mandarParam -> . empty
    (135) empty -> .

    AND             shift and go to state 158
    OR              shift and go to state 159
    COLON           reduce using rule 135 (empty -> .)
    PARENCLOSE      reduce using rule 135 (empty -> .)

    mandarParam                    shift and go to state 239
    empty                          shift and go to state 240

state 202

    (73) call_funcc -> empty .

    PARENCLOSE      reduce using rule 73 (call_funcc -> empty .)


state 203

    (105) variableAssignment -> ID BRACEOPEN exp BRACECLOSE .
    (106) variableAssignment -> ID BRACEOPEN exp BRACECLOSE . BRACEOPEN exp BRACECLOSE

    EQUAL           reduce using rule 105 (variableAssignment -> ID BRACEOPEN exp BRACECLOSE .)
    BRACEOPEN       shift and go to state 241


state 204

    (127) graph -> PLOT PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 242


state 205

    (76) exp -> exp AND expp .
    (79) expp -> expp . GREATHERTHAN m_exp
    (80) expp -> expp . LESSTHAN m_exp
    (81) expp -> expp . GREATHEREQUAL m_exp
    (82) expp -> expp . LESSEQUAL m_exp
    (83) expp -> expp . DIFFERENT m_exp
    (84) expp -> expp . SAME m_exp

    SEMICOLON       reduce using rule 76 (exp -> exp AND expp .)
    AND             reduce using rule 76 (exp -> exp AND expp .)
    OR              reduce using rule 76 (exp -> exp AND expp .)
    PARENCLOSE      reduce using rule 76 (exp -> exp AND expp .)
    COLON           reduce using rule 76 (exp -> exp AND expp .)
    BRACECLOSE      reduce using rule 76 (exp -> exp AND expp .)
    GREATHERTHAN    shift and go to state 160
    LESSTHAN        shift and go to state 161
    GREATHEREQUAL   shift and go to state 162
    LESSEQUAL       shift and go to state 163
    DIFFERENT       shift and go to state 164
    SAME            shift and go to state 165


state 206

    (77) exp -> exp OR expp .
    (79) expp -> expp . GREATHERTHAN m_exp
    (80) expp -> expp . LESSTHAN m_exp
    (81) expp -> expp . GREATHEREQUAL m_exp
    (82) expp -> expp . LESSEQUAL m_exp
    (83) expp -> expp . DIFFERENT m_exp
    (84) expp -> expp . SAME m_exp

    SEMICOLON       reduce using rule 77 (exp -> exp OR expp .)
    AND             reduce using rule 77 (exp -> exp OR expp .)
    OR              reduce using rule 77 (exp -> exp OR expp .)
    PARENCLOSE      reduce using rule 77 (exp -> exp OR expp .)
    COLON           reduce using rule 77 (exp -> exp OR expp .)
    BRACECLOSE      reduce using rule 77 (exp -> exp OR expp .)
    GREATHERTHAN    shift and go to state 160
    LESSTHAN        shift and go to state 161
    GREATHEREQUAL   shift and go to state 162
    LESSEQUAL       shift and go to state 163
    DIFFERENT       shift and go to state 164
    SAME            shift and go to state 165


state 207

    (79) expp -> expp GREATHERTHAN m_exp .
    (86) m_exp -> m_exp . PLUS termino
    (87) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 79 (expp -> expp GREATHERTHAN m_exp .)
    LESSTHAN        reduce using rule 79 (expp -> expp GREATHERTHAN m_exp .)
    GREATHEREQUAL   reduce using rule 79 (expp -> expp GREATHERTHAN m_exp .)
    LESSEQUAL       reduce using rule 79 (expp -> expp GREATHERTHAN m_exp .)
    DIFFERENT       reduce using rule 79 (expp -> expp GREATHERTHAN m_exp .)
    SAME            reduce using rule 79 (expp -> expp GREATHERTHAN m_exp .)
    SEMICOLON       reduce using rule 79 (expp -> expp GREATHERTHAN m_exp .)
    AND             reduce using rule 79 (expp -> expp GREATHERTHAN m_exp .)
    OR              reduce using rule 79 (expp -> expp GREATHERTHAN m_exp .)
    PARENCLOSE      reduce using rule 79 (expp -> expp GREATHERTHAN m_exp .)
    COLON           reduce using rule 79 (expp -> expp GREATHERTHAN m_exp .)
    BRACECLOSE      reduce using rule 79 (expp -> expp GREATHERTHAN m_exp .)
    PLUS            shift and go to state 166
    MINUS           shift and go to state 167


state 208

    (80) expp -> expp LESSTHAN m_exp .
    (86) m_exp -> m_exp . PLUS termino
    (87) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 80 (expp -> expp LESSTHAN m_exp .)
    LESSTHAN        reduce using rule 80 (expp -> expp LESSTHAN m_exp .)
    GREATHEREQUAL   reduce using rule 80 (expp -> expp LESSTHAN m_exp .)
    LESSEQUAL       reduce using rule 80 (expp -> expp LESSTHAN m_exp .)
    DIFFERENT       reduce using rule 80 (expp -> expp LESSTHAN m_exp .)
    SAME            reduce using rule 80 (expp -> expp LESSTHAN m_exp .)
    SEMICOLON       reduce using rule 80 (expp -> expp LESSTHAN m_exp .)
    AND             reduce using rule 80 (expp -> expp LESSTHAN m_exp .)
    OR              reduce using rule 80 (expp -> expp LESSTHAN m_exp .)
    PARENCLOSE      reduce using rule 80 (expp -> expp LESSTHAN m_exp .)
    COLON           reduce using rule 80 (expp -> expp LESSTHAN m_exp .)
    BRACECLOSE      reduce using rule 80 (expp -> expp LESSTHAN m_exp .)
    PLUS            shift and go to state 166
    MINUS           shift and go to state 167


state 209

    (81) expp -> expp GREATHEREQUAL m_exp .
    (86) m_exp -> m_exp . PLUS termino
    (87) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 81 (expp -> expp GREATHEREQUAL m_exp .)
    LESSTHAN        reduce using rule 81 (expp -> expp GREATHEREQUAL m_exp .)
    GREATHEREQUAL   reduce using rule 81 (expp -> expp GREATHEREQUAL m_exp .)
    LESSEQUAL       reduce using rule 81 (expp -> expp GREATHEREQUAL m_exp .)
    DIFFERENT       reduce using rule 81 (expp -> expp GREATHEREQUAL m_exp .)
    SAME            reduce using rule 81 (expp -> expp GREATHEREQUAL m_exp .)
    SEMICOLON       reduce using rule 81 (expp -> expp GREATHEREQUAL m_exp .)
    AND             reduce using rule 81 (expp -> expp GREATHEREQUAL m_exp .)
    OR              reduce using rule 81 (expp -> expp GREATHEREQUAL m_exp .)
    PARENCLOSE      reduce using rule 81 (expp -> expp GREATHEREQUAL m_exp .)
    COLON           reduce using rule 81 (expp -> expp GREATHEREQUAL m_exp .)
    BRACECLOSE      reduce using rule 81 (expp -> expp GREATHEREQUAL m_exp .)
    PLUS            shift and go to state 166
    MINUS           shift and go to state 167


state 210

    (82) expp -> expp LESSEQUAL m_exp .
    (86) m_exp -> m_exp . PLUS termino
    (87) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 82 (expp -> expp LESSEQUAL m_exp .)
    LESSTHAN        reduce using rule 82 (expp -> expp LESSEQUAL m_exp .)
    GREATHEREQUAL   reduce using rule 82 (expp -> expp LESSEQUAL m_exp .)
    LESSEQUAL       reduce using rule 82 (expp -> expp LESSEQUAL m_exp .)
    DIFFERENT       reduce using rule 82 (expp -> expp LESSEQUAL m_exp .)
    SAME            reduce using rule 82 (expp -> expp LESSEQUAL m_exp .)
    SEMICOLON       reduce using rule 82 (expp -> expp LESSEQUAL m_exp .)
    AND             reduce using rule 82 (expp -> expp LESSEQUAL m_exp .)
    OR              reduce using rule 82 (expp -> expp LESSEQUAL m_exp .)
    PARENCLOSE      reduce using rule 82 (expp -> expp LESSEQUAL m_exp .)
    COLON           reduce using rule 82 (expp -> expp LESSEQUAL m_exp .)
    BRACECLOSE      reduce using rule 82 (expp -> expp LESSEQUAL m_exp .)
    PLUS            shift and go to state 166
    MINUS           shift and go to state 167


state 211

    (83) expp -> expp DIFFERENT m_exp .
    (86) m_exp -> m_exp . PLUS termino
    (87) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 83 (expp -> expp DIFFERENT m_exp .)
    LESSTHAN        reduce using rule 83 (expp -> expp DIFFERENT m_exp .)
    GREATHEREQUAL   reduce using rule 83 (expp -> expp DIFFERENT m_exp .)
    LESSEQUAL       reduce using rule 83 (expp -> expp DIFFERENT m_exp .)
    DIFFERENT       reduce using rule 83 (expp -> expp DIFFERENT m_exp .)
    SAME            reduce using rule 83 (expp -> expp DIFFERENT m_exp .)
    SEMICOLON       reduce using rule 83 (expp -> expp DIFFERENT m_exp .)
    AND             reduce using rule 83 (expp -> expp DIFFERENT m_exp .)
    OR              reduce using rule 83 (expp -> expp DIFFERENT m_exp .)
    PARENCLOSE      reduce using rule 83 (expp -> expp DIFFERENT m_exp .)
    COLON           reduce using rule 83 (expp -> expp DIFFERENT m_exp .)
    BRACECLOSE      reduce using rule 83 (expp -> expp DIFFERENT m_exp .)
    PLUS            shift and go to state 166
    MINUS           shift and go to state 167


state 212

    (84) expp -> expp SAME m_exp .
    (86) m_exp -> m_exp . PLUS termino
    (87) m_exp -> m_exp . MINUS termino

    GREATHERTHAN    reduce using rule 84 (expp -> expp SAME m_exp .)
    LESSTHAN        reduce using rule 84 (expp -> expp SAME m_exp .)
    GREATHEREQUAL   reduce using rule 84 (expp -> expp SAME m_exp .)
    LESSEQUAL       reduce using rule 84 (expp -> expp SAME m_exp .)
    DIFFERENT       reduce using rule 84 (expp -> expp SAME m_exp .)
    SAME            reduce using rule 84 (expp -> expp SAME m_exp .)
    SEMICOLON       reduce using rule 84 (expp -> expp SAME m_exp .)
    AND             reduce using rule 84 (expp -> expp SAME m_exp .)
    OR              reduce using rule 84 (expp -> expp SAME m_exp .)
    PARENCLOSE      reduce using rule 84 (expp -> expp SAME m_exp .)
    COLON           reduce using rule 84 (expp -> expp SAME m_exp .)
    BRACECLOSE      reduce using rule 84 (expp -> expp SAME m_exp .)
    PLUS            shift and go to state 166
    MINUS           shift and go to state 167


state 213

    (86) m_exp -> m_exp PLUS termino .
    (89) termino -> termino . MULTIPLY factor
    (90) termino -> termino . DIVIDE factor

    PLUS            reduce using rule 86 (m_exp -> m_exp PLUS termino .)
    MINUS           reduce using rule 86 (m_exp -> m_exp PLUS termino .)
    GREATHERTHAN    reduce using rule 86 (m_exp -> m_exp PLUS termino .)
    LESSTHAN        reduce using rule 86 (m_exp -> m_exp PLUS termino .)
    GREATHEREQUAL   reduce using rule 86 (m_exp -> m_exp PLUS termino .)
    LESSEQUAL       reduce using rule 86 (m_exp -> m_exp PLUS termino .)
    DIFFERENT       reduce using rule 86 (m_exp -> m_exp PLUS termino .)
    SAME            reduce using rule 86 (m_exp -> m_exp PLUS termino .)
    SEMICOLON       reduce using rule 86 (m_exp -> m_exp PLUS termino .)
    AND             reduce using rule 86 (m_exp -> m_exp PLUS termino .)
    OR              reduce using rule 86 (m_exp -> m_exp PLUS termino .)
    PARENCLOSE      reduce using rule 86 (m_exp -> m_exp PLUS termino .)
    COLON           reduce using rule 86 (m_exp -> m_exp PLUS termino .)
    BRACECLOSE      reduce using rule 86 (m_exp -> m_exp PLUS termino .)
    MULTIPLY        shift and go to state 168
    DIVIDE          shift and go to state 169


state 214

    (87) m_exp -> m_exp MINUS termino .
    (89) termino -> termino . MULTIPLY factor
    (90) termino -> termino . DIVIDE factor

    PLUS            reduce using rule 87 (m_exp -> m_exp MINUS termino .)
    MINUS           reduce using rule 87 (m_exp -> m_exp MINUS termino .)
    GREATHERTHAN    reduce using rule 87 (m_exp -> m_exp MINUS termino .)
    LESSTHAN        reduce using rule 87 (m_exp -> m_exp MINUS termino .)
    GREATHEREQUAL   reduce using rule 87 (m_exp -> m_exp MINUS termino .)
    LESSEQUAL       reduce using rule 87 (m_exp -> m_exp MINUS termino .)
    DIFFERENT       reduce using rule 87 (m_exp -> m_exp MINUS termino .)
    SAME            reduce using rule 87 (m_exp -> m_exp MINUS termino .)
    SEMICOLON       reduce using rule 87 (m_exp -> m_exp MINUS termino .)
    AND             reduce using rule 87 (m_exp -> m_exp MINUS termino .)
    OR              reduce using rule 87 (m_exp -> m_exp MINUS termino .)
    PARENCLOSE      reduce using rule 87 (m_exp -> m_exp MINUS termino .)
    COLON           reduce using rule 87 (m_exp -> m_exp MINUS termino .)
    BRACECLOSE      reduce using rule 87 (m_exp -> m_exp MINUS termino .)
    MULTIPLY        shift and go to state 168
    DIVIDE          shift and go to state 169


state 215

    (89) termino -> termino MULTIPLY factor .

    MULTIPLY        reduce using rule 89 (termino -> termino MULTIPLY factor .)
    DIVIDE          reduce using rule 89 (termino -> termino MULTIPLY factor .)
    PLUS            reduce using rule 89 (termino -> termino MULTIPLY factor .)
    MINUS           reduce using rule 89 (termino -> termino MULTIPLY factor .)
    GREATHERTHAN    reduce using rule 89 (termino -> termino MULTIPLY factor .)
    LESSTHAN        reduce using rule 89 (termino -> termino MULTIPLY factor .)
    GREATHEREQUAL   reduce using rule 89 (termino -> termino MULTIPLY factor .)
    LESSEQUAL       reduce using rule 89 (termino -> termino MULTIPLY factor .)
    DIFFERENT       reduce using rule 89 (termino -> termino MULTIPLY factor .)
    SAME            reduce using rule 89 (termino -> termino MULTIPLY factor .)
    SEMICOLON       reduce using rule 89 (termino -> termino MULTIPLY factor .)
    AND             reduce using rule 89 (termino -> termino MULTIPLY factor .)
    OR              reduce using rule 89 (termino -> termino MULTIPLY factor .)
    PARENCLOSE      reduce using rule 89 (termino -> termino MULTIPLY factor .)
    COLON           reduce using rule 89 (termino -> termino MULTIPLY factor .)
    BRACECLOSE      reduce using rule 89 (termino -> termino MULTIPLY factor .)


state 216

    (90) termino -> termino DIVIDE factor .

    MULTIPLY        reduce using rule 90 (termino -> termino DIVIDE factor .)
    DIVIDE          reduce using rule 90 (termino -> termino DIVIDE factor .)
    PLUS            reduce using rule 90 (termino -> termino DIVIDE factor .)
    MINUS           reduce using rule 90 (termino -> termino DIVIDE factor .)
    GREATHERTHAN    reduce using rule 90 (termino -> termino DIVIDE factor .)
    LESSTHAN        reduce using rule 90 (termino -> termino DIVIDE factor .)
    GREATHEREQUAL   reduce using rule 90 (termino -> termino DIVIDE factor .)
    LESSEQUAL       reduce using rule 90 (termino -> termino DIVIDE factor .)
    DIFFERENT       reduce using rule 90 (termino -> termino DIVIDE factor .)
    SAME            reduce using rule 90 (termino -> termino DIVIDE factor .)
    SEMICOLON       reduce using rule 90 (termino -> termino DIVIDE factor .)
    AND             reduce using rule 90 (termino -> termino DIVIDE factor .)
    OR              reduce using rule 90 (termino -> termino DIVIDE factor .)
    PARENCLOSE      reduce using rule 90 (termino -> termino DIVIDE factor .)
    COLON           reduce using rule 90 (termino -> termino DIVIDE factor .)
    BRACECLOSE      reduce using rule 90 (termino -> termino DIVIDE factor .)


state 217

    (97) factor -> PARENOPEN exp PARENCLOSE .

    MULTIPLY        reduce using rule 97 (factor -> PARENOPEN exp PARENCLOSE .)
    DIVIDE          reduce using rule 97 (factor -> PARENOPEN exp PARENCLOSE .)
    PLUS            reduce using rule 97 (factor -> PARENOPEN exp PARENCLOSE .)
    MINUS           reduce using rule 97 (factor -> PARENOPEN exp PARENCLOSE .)
    GREATHERTHAN    reduce using rule 97 (factor -> PARENOPEN exp PARENCLOSE .)
    LESSTHAN        reduce using rule 97 (factor -> PARENOPEN exp PARENCLOSE .)
    GREATHEREQUAL   reduce using rule 97 (factor -> PARENOPEN exp PARENCLOSE .)
    LESSEQUAL       reduce using rule 97 (factor -> PARENOPEN exp PARENCLOSE .)
    DIFFERENT       reduce using rule 97 (factor -> PARENOPEN exp PARENCLOSE .)
    SAME            reduce using rule 97 (factor -> PARENOPEN exp PARENCLOSE .)
    SEMICOLON       reduce using rule 97 (factor -> PARENOPEN exp PARENCLOSE .)
    AND             reduce using rule 97 (factor -> PARENOPEN exp PARENCLOSE .)
    OR              reduce using rule 97 (factor -> PARENOPEN exp PARENCLOSE .)
    PARENCLOSE      reduce using rule 97 (factor -> PARENOPEN exp PARENCLOSE .)
    COLON           reduce using rule 97 (factor -> PARENOPEN exp PARENCLOSE .)
    BRACECLOSE      reduce using rule 97 (factor -> PARENOPEN exp PARENCLOSE .)


state 218

    (122) while_loop -> WHILE whileMigaja PARENOPEN exp . PARENCLOSE whileEval body whileEnd
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 243
    AND             shift and go to state 158
    OR              shift and go to state 159


state 219

    (128) max -> MAX PARENOPEN ID PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 244


state 220

    (129) min -> MIN PARENOPEN ID PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 245


state 221

    (130) sum -> SUM PARENOPEN ID PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 246


state 222

    (134) normal -> NORMAL PARENOPEN exp COLON . exp COLON exp PARENCLOSE SEMICOLON
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 247
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 223

    (133) uniforme -> UNIFORME PARENOPEN exp COLON . exp COLON exp PARENCLOSE SEMICOLON
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 248
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 224

    (132) poisson -> POISSON PARENOPEN exp COLON . exp PARENCLOSE SEMICOLON
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 249
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 225

    (131) binomial -> BINOMIAL PARENOPEN exp COLON . exp COLON exp PARENCLOSE SEMICOLON
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 250
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 226

    (59) dec_variabless -> type guardarTipo dec_mvar SEMICOLON . dec_variabless
    (60) dec_variabless -> type guardarTipo dec_mvar SEMICOLON .
    (59) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON dec_variabless
    (60) dec_variabless -> . type guardarTipo dec_mvar SEMICOLON
    (35) type -> . INT
    (36) type -> . FLOAT
    (37) type -> . CHAR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    IF              reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    PRINT           reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    READ            reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    ID              reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    PLOT            reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    RETURN          reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    WHILE           reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    MAX             reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    MIN             reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    SUM             reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    NORMAL          reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    UNIFORME        reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    POISSON         reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    BINOMIAL        reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    BRACKETCLOSE    reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .)
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23

  ! INT             [ reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .) ]
  ! CHAR            [ reduce using rule 60 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON .) ]

    type                           shift and go to state 100
    dec_variabless                 shift and go to state 251

state 227

    (61) dec_mvar -> ID guardarID . COLON dec_mvar
    (62) dec_mvar -> ID guardarID . BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (63) dec_mvar -> ID guardarID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (64) dec_mvar -> ID guardarID .
    (65) dec_mvar -> ID guardarID . BRACEOPEN CTEINT BRACECLOSE
    (66) dec_mvar -> ID guardarID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 252
    BRACEOPEN       shift and go to state 253
    SEMICOLON       reduce using rule 64 (dec_mvar -> ID guardarID .)


state 228

    (67) guardarID -> empty .

    COLON           reduce using rule 67 (guardarID -> empty .)
    BRACEOPEN       reduce using rule 67 (guardarID -> empty .)
    SEMICOLON       reduce using rule 67 (guardarID -> empty .)


state 229

    (23) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body . exitFunc
    (34) exitFunc -> . empty
    (135) empty -> .

    FUNCTION        reduce using rule 135 (empty -> .)
    MAIN            reduce using rule 135 (empty -> .)

    exitFunc                       shift and go to state 254
    empty                          shift and go to state 255

state 230

    (24) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body . exitFunc
    (34) exitFunc -> . empty
    (135) empty -> .

    FUNCTION        reduce using rule 135 (empty -> .)
    MAIN            reduce using rule 135 (empty -> .)

    exitFunc                       shift and go to state 256
    empty                          shift and go to state 255

state 231

    (16) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE . COLON mvar
    (19) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .

    COLON           shift and go to state 257
    SEMICOLON       reduce using rule 19 (mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .)


state 232

    (107) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF . body ifEnd
    (108) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF . body cuadruploElse ELSE body ifEndElse
    (38) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 55

    body                           shift and go to state 258

state 233

    (109) cuadruploIF -> empty .

    BRACKETOPEN     reduce using rule 109 (cuadruploIF -> empty .)


state 234

    (113) writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .

    IF              reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    READ            reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    ID              reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    INT             reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 113 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)


state 235

    (115) writingg -> exp COLON writingg .

    PARENCLOSE      reduce using rule 115 (writingg -> exp COLON writingg .)


state 236

    (117) writingg -> auxString COLON writingg .

    PARENCLOSE      reduce using rule 117 (writingg -> auxString COLON writingg .)


state 237

    (102) variable -> ID BRACEOPEN exp BRACECLOSE .
    (103) variable -> ID BRACEOPEN exp BRACECLOSE . BRACEOPEN exp BRACECLOSE

    COLON           reduce using rule 102 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    SEMICOLON       reduce using rule 102 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    MULTIPLY        reduce using rule 102 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    DIVIDE          reduce using rule 102 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    PLUS            reduce using rule 102 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    MINUS           reduce using rule 102 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    GREATHERTHAN    reduce using rule 102 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    LESSTHAN        reduce using rule 102 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    GREATHEREQUAL   reduce using rule 102 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    LESSEQUAL       reduce using rule 102 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    DIFFERENT       reduce using rule 102 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    SAME            reduce using rule 102 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    AND             reduce using rule 102 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    OR              reduce using rule 102 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    PARENCLOSE      reduce using rule 102 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    BRACECLOSE      reduce using rule 102 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    BRACEOPEN       shift and go to state 259


state 238

    (69) call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .

    IF              reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    PRINT           reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    READ            reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    ID              reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    PLOT            reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    RETURN          reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    WHILE           reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    MAX             reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    MIN             reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    SUM             reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    NORMAL          reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    UNIFORME        reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    POISSON         reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    BINOMIAL        reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    INT             reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    FLOAT           reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    CHAR            reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    BRACKETCLOSE    reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    MULTIPLY        reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    DIVIDE          reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    PLUS            reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    MINUS           reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    GREATHERTHAN    reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    LESSTHAN        reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    GREATHEREQUAL   reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    LESSEQUAL       reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    DIFFERENT       reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    SAME            reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    SEMICOLON       reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    AND             reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    OR              reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    PARENCLOSE      reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    COLON           reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)
    BRACECLOSE      reduce using rule 69 (call_func -> ID generarERA PARENOPEN call_funcc PARENCLOSE .)


state 239

    (71) call_funcc -> exp mandarParam .
    (72) call_funcc -> exp mandarParam . COLON call_funcc

    PARENCLOSE      reduce using rule 71 (call_funcc -> exp mandarParam .)
    COLON           shift and go to state 260


state 240

    (74) mandarParam -> empty .

    COLON           reduce using rule 74 (mandarParam -> empty .)
    PARENCLOSE      reduce using rule 74 (mandarParam -> empty .)


state 241

    (106) variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN . exp BRACECLOSE
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 261
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 242

    (127) graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 127 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)


state 243

    (122) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE . whileEval body whileEnd
    (124) whileEval -> . empty
    (135) empty -> .

    BRACKETOPEN     reduce using rule 135 (empty -> .)

    whileEval                      shift and go to state 262
    empty                          shift and go to state 263

state 244

    (128) max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .

    IF              reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    READ            reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    ID              reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    INT             reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 128 (max -> MAX PARENOPEN ID PARENCLOSE SEMICOLON .)


state 245

    (129) min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .

    IF              reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    READ            reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    ID              reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    INT             reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 129 (min -> MIN PARENOPEN ID PARENCLOSE SEMICOLON .)


state 246

    (130) sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .

    IF              reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    READ            reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    ID              reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    INT             reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 130 (sum -> SUM PARENOPEN ID PARENCLOSE SEMICOLON .)


state 247

    (134) normal -> NORMAL PARENOPEN exp COLON exp . COLON exp PARENCLOSE SEMICOLON
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    COLON           shift and go to state 264
    AND             shift and go to state 158
    OR              shift and go to state 159


state 248

    (133) uniforme -> UNIFORME PARENOPEN exp COLON exp . COLON exp PARENCLOSE SEMICOLON
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    COLON           shift and go to state 265
    AND             shift and go to state 158
    OR              shift and go to state 159


state 249

    (132) poisson -> POISSON PARENOPEN exp COLON exp . PARENCLOSE SEMICOLON
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 266
    AND             shift and go to state 158
    OR              shift and go to state 159


state 250

    (131) binomial -> BINOMIAL PARENOPEN exp COLON exp . COLON exp PARENCLOSE SEMICOLON
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    COLON           shift and go to state 267
    AND             shift and go to state 158
    OR              shift and go to state 159


state 251

    (59) dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .

    IF              reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    PRINT           reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    READ            reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    ID              reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    PLOT            reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    RETURN          reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    WHILE           reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    MAX             reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    MIN             reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    SUM             reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    NORMAL          reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    UNIFORME        reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    POISSON         reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    BINOMIAL        reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    INT             reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    FLOAT           reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    CHAR            reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)
    BRACKETCLOSE    reduce using rule 59 (dec_variabless -> type guardarTipo dec_mvar SEMICOLON dec_variabless .)


state 252

    (61) dec_mvar -> ID guardarID COLON . dec_mvar
    (61) dec_mvar -> . ID guardarID COLON dec_mvar
    (62) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (63) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (64) dec_mvar -> . ID guardarID
    (65) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE
    (66) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 186

    dec_mvar                       shift and go to state 268

state 253

    (62) dec_mvar -> ID guardarID BRACEOPEN . CTEINT BRACECLOSE COLON dec_mvar
    (63) dec_mvar -> ID guardarID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (65) dec_mvar -> ID guardarID BRACEOPEN . CTEINT BRACECLOSE
    (66) dec_mvar -> ID guardarID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    CTEINT          shift and go to state 269


state 254

    (23) dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc .

    FUNCTION        reduce using rule 23 (dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc .)
    MAIN            reduce using rule 23 (dec_func -> FUNCTION type ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc .)


state 255

    (34) exitFunc -> empty .

    FUNCTION        reduce using rule 34 (exitFunc -> empty .)
    MAIN            reduce using rule 34 (exitFunc -> empty .)


state 256

    (24) dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc .

    FUNCTION        reduce using rule 24 (dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc .)
    MAIN            reduce using rule 24 (dec_func -> FUNCTION VOID ID crearSymbolTable PARENOPEN param numeroParam PARENCLOSE startFunc body exitFunc .)


state 257

    (16) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON . mvar
    (14) mvar -> . ID guardarIDvar COLON mvar
    (15) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (16) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (17) mvar -> . ID guardarIDvar
    (18) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE
    (19) mvar -> . ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 39

    mvar                           shift and go to state 270

state 258

    (107) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body . ifEnd
    (108) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body . cuadruploElse ELSE body ifEndElse
    (110) ifEnd -> . empty
    (111) cuadruploElse -> . empty
    (135) empty -> .

    IF              reduce using rule 135 (empty -> .)
    PRINT           reduce using rule 135 (empty -> .)
    READ            reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    PLOT            reduce using rule 135 (empty -> .)
    RETURN          reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    MAX             reduce using rule 135 (empty -> .)
    MIN             reduce using rule 135 (empty -> .)
    SUM             reduce using rule 135 (empty -> .)
    NORMAL          reduce using rule 135 (empty -> .)
    UNIFORME        reduce using rule 135 (empty -> .)
    POISSON         reduce using rule 135 (empty -> .)
    BINOMIAL        reduce using rule 135 (empty -> .)
    INT             reduce using rule 135 (empty -> .)
    FLOAT           reduce using rule 135 (empty -> .)
    CHAR            reduce using rule 135 (empty -> .)
    BRACKETCLOSE    reduce using rule 135 (empty -> .)
    ELSE            reduce using rule 135 (empty -> .)

    ifEnd                          shift and go to state 271
    cuadruploElse                  shift and go to state 272
    empty                          shift and go to state 273

state 259

    (103) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN . exp BRACECLOSE
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 274
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 260

    (72) call_funcc -> exp mandarParam COLON . call_funcc
    (71) call_funcc -> . exp mandarParam
    (72) call_funcc -> . exp mandarParam COLON call_funcc
    (73) call_funcc -> . empty
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (135) empty -> .
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    PARENCLOSE      reduce using rule 135 (empty -> .)
    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 201
    call_funcc                     shift and go to state 275
    empty                          shift and go to state 202
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 261

    (106) variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp . BRACECLOSE
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    BRACECLOSE      shift and go to state 276
    AND             shift and go to state 158
    OR              shift and go to state 159


state 262

    (122) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval . body whileEnd
    (38) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 55

    body                           shift and go to state 277

state 263

    (124) whileEval -> empty .

    BRACKETOPEN     reduce using rule 124 (whileEval -> empty .)


state 264

    (134) normal -> NORMAL PARENOPEN exp COLON exp COLON . exp PARENCLOSE SEMICOLON
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 278
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 265

    (133) uniforme -> UNIFORME PARENOPEN exp COLON exp COLON . exp PARENCLOSE SEMICOLON
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 279
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 266

    (132) poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 280


state 267

    (131) binomial -> BINOMIAL PARENOPEN exp COLON exp COLON . exp PARENCLOSE SEMICOLON
    (75) exp -> . expp
    (76) exp -> . exp AND expp
    (77) exp -> . exp OR expp
    (78) expp -> . m_exp
    (79) expp -> . expp GREATHERTHAN m_exp
    (80) expp -> . expp LESSTHAN m_exp
    (81) expp -> . expp GREATHEREQUAL m_exp
    (82) expp -> . expp LESSEQUAL m_exp
    (83) expp -> . expp DIFFERENT m_exp
    (84) expp -> . expp SAME m_exp
    (85) m_exp -> . termino
    (86) m_exp -> . m_exp PLUS termino
    (87) m_exp -> . m_exp MINUS termino
    (88) termino -> . factor
    (89) termino -> . termino MULTIPLY factor
    (90) termino -> . termino DIVIDE factor
    (91) factor -> . ID
    (92) factor -> . CTEINT guardarConstanteInt
    (93) factor -> . CTFLOAT guardarConstanteFloat
    (94) factor -> . CTECHAR guardarConstanteChar
    (95) factor -> . variable
    (96) factor -> . call_func
    (97) factor -> . PARENOPEN exp PARENCLOSE
    (101) variable -> . ID
    (102) variable -> . ID BRACEOPEN exp BRACECLOSE
    (103) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (69) call_func -> . ID generarERA PARENOPEN call_funcc PARENCLOSE

    ID              shift and go to state 123
    CTEINT          shift and go to state 124
    CTFLOAT         shift and go to state 125
    CTECHAR         shift and go to state 126
    PARENOPEN       shift and go to state 129

    exp                            shift and go to state 281
    expp                           shift and go to state 119
    m_exp                          shift and go to state 120
    termino                        shift and go to state 121
    factor                         shift and go to state 122
    variable                       shift and go to state 127
    call_func                      shift and go to state 128

state 268

    (61) dec_mvar -> ID guardarID COLON dec_mvar .

    SEMICOLON       reduce using rule 61 (dec_mvar -> ID guardarID COLON dec_mvar .)


state 269

    (62) dec_mvar -> ID guardarID BRACEOPEN CTEINT . BRACECLOSE COLON dec_mvar
    (63) dec_mvar -> ID guardarID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (65) dec_mvar -> ID guardarID BRACEOPEN CTEINT . BRACECLOSE
    (66) dec_mvar -> ID guardarID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    BRACECLOSE      shift and go to state 282


state 270

    (16) mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar .

    SEMICOLON       reduce using rule 16 (mvar -> ID guardarIDvar BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar .)


state 271

    (107) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .

    IF              reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    PRINT           reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    READ            reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    ID              reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    PLOT            reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    RETURN          reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    WHILE           reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    MAX             reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    MIN             reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    SUM             reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    NORMAL          reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    UNIFORME        reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    POISSON         reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    BINOMIAL        reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    INT             reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    FLOAT           reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    CHAR            reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)
    BRACKETCLOSE    reduce using rule 107 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body ifEnd .)


state 272

    (108) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse . ELSE body ifEndElse

    ELSE            shift and go to state 283


state 273

    (110) ifEnd -> empty .
    (111) cuadruploElse -> empty .

    IF              reduce using rule 110 (ifEnd -> empty .)
    PRINT           reduce using rule 110 (ifEnd -> empty .)
    READ            reduce using rule 110 (ifEnd -> empty .)
    ID              reduce using rule 110 (ifEnd -> empty .)
    PLOT            reduce using rule 110 (ifEnd -> empty .)
    RETURN          reduce using rule 110 (ifEnd -> empty .)
    WHILE           reduce using rule 110 (ifEnd -> empty .)
    MAX             reduce using rule 110 (ifEnd -> empty .)
    MIN             reduce using rule 110 (ifEnd -> empty .)
    SUM             reduce using rule 110 (ifEnd -> empty .)
    NORMAL          reduce using rule 110 (ifEnd -> empty .)
    UNIFORME        reduce using rule 110 (ifEnd -> empty .)
    POISSON         reduce using rule 110 (ifEnd -> empty .)
    BINOMIAL        reduce using rule 110 (ifEnd -> empty .)
    INT             reduce using rule 110 (ifEnd -> empty .)
    FLOAT           reduce using rule 110 (ifEnd -> empty .)
    CHAR            reduce using rule 110 (ifEnd -> empty .)
    BRACKETCLOSE    reduce using rule 110 (ifEnd -> empty .)
    ELSE            reduce using rule 111 (cuadruploElse -> empty .)


state 274

    (103) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp . BRACECLOSE
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    BRACECLOSE      shift and go to state 284
    AND             shift and go to state 158
    OR              shift and go to state 159


state 275

    (72) call_funcc -> exp mandarParam COLON call_funcc .

    PARENCLOSE      reduce using rule 72 (call_funcc -> exp mandarParam COLON call_funcc .)


state 276

    (106) variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .

    EQUAL           reduce using rule 106 (variableAssignment -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)


state 277

    (122) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body . whileEnd
    (125) whileEnd -> . empty
    (135) empty -> .

    IF              reduce using rule 135 (empty -> .)
    PRINT           reduce using rule 135 (empty -> .)
    READ            reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    PLOT            reduce using rule 135 (empty -> .)
    RETURN          reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    MAX             reduce using rule 135 (empty -> .)
    MIN             reduce using rule 135 (empty -> .)
    SUM             reduce using rule 135 (empty -> .)
    NORMAL          reduce using rule 135 (empty -> .)
    UNIFORME        reduce using rule 135 (empty -> .)
    POISSON         reduce using rule 135 (empty -> .)
    BINOMIAL        reduce using rule 135 (empty -> .)
    INT             reduce using rule 135 (empty -> .)
    FLOAT           reduce using rule 135 (empty -> .)
    CHAR            reduce using rule 135 (empty -> .)
    BRACKETCLOSE    reduce using rule 135 (empty -> .)

    whileEnd                       shift and go to state 285
    empty                          shift and go to state 286

state 278

    (134) normal -> NORMAL PARENOPEN exp COLON exp COLON exp . PARENCLOSE SEMICOLON
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 287
    AND             shift and go to state 158
    OR              shift and go to state 159


state 279

    (133) uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp . PARENCLOSE SEMICOLON
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 288
    AND             shift and go to state 158
    OR              shift and go to state 159


state 280

    (132) poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 132 (poisson -> POISSON PARENOPEN exp COLON exp PARENCLOSE SEMICOLON .)


state 281

    (131) binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp . PARENCLOSE SEMICOLON
    (76) exp -> exp . AND expp
    (77) exp -> exp . OR expp

    PARENCLOSE      shift and go to state 289
    AND             shift and go to state 158
    OR              shift and go to state 159


state 282

    (62) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE . COLON dec_mvar
    (63) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (65) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE .
    (66) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 291
    BRACEOPEN       shift and go to state 290
    SEMICOLON       reduce using rule 65 (dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE .)


state 283

    (108) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE . body ifEndElse
    (38) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 55

    body                           shift and go to state 292

state 284

    (103) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .

    COLON           reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    SEMICOLON       reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    MULTIPLY        reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    DIVIDE          reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    PLUS            reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    MINUS           reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    GREATHERTHAN    reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    LESSTHAN        reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    GREATHEREQUAL   reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    LESSEQUAL       reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    DIFFERENT       reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    SAME            reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    AND             reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    OR              reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    PARENCLOSE      reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    BRACECLOSE      reduce using rule 103 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)


state 285

    (122) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .

    IF              reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    PRINT           reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    READ            reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    ID              reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    PLOT            reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    RETURN          reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    WHILE           reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    MAX             reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    MIN             reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    SUM             reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    NORMAL          reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    UNIFORME        reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    POISSON         reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    BINOMIAL        reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    INT             reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    FLOAT           reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    CHAR            reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    BRACKETCLOSE    reduce using rule 122 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)


state 286

    (125) whileEnd -> empty .

    IF              reduce using rule 125 (whileEnd -> empty .)
    PRINT           reduce using rule 125 (whileEnd -> empty .)
    READ            reduce using rule 125 (whileEnd -> empty .)
    ID              reduce using rule 125 (whileEnd -> empty .)
    PLOT            reduce using rule 125 (whileEnd -> empty .)
    RETURN          reduce using rule 125 (whileEnd -> empty .)
    WHILE           reduce using rule 125 (whileEnd -> empty .)
    MAX             reduce using rule 125 (whileEnd -> empty .)
    MIN             reduce using rule 125 (whileEnd -> empty .)
    SUM             reduce using rule 125 (whileEnd -> empty .)
    NORMAL          reduce using rule 125 (whileEnd -> empty .)
    UNIFORME        reduce using rule 125 (whileEnd -> empty .)
    POISSON         reduce using rule 125 (whileEnd -> empty .)
    BINOMIAL        reduce using rule 125 (whileEnd -> empty .)
    INT             reduce using rule 125 (whileEnd -> empty .)
    FLOAT           reduce using rule 125 (whileEnd -> empty .)
    CHAR            reduce using rule 125 (whileEnd -> empty .)
    BRACKETCLOSE    reduce using rule 125 (whileEnd -> empty .)


state 287

    (134) normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 293


state 288

    (133) uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 294


state 289

    (131) binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 295


state 290

    (63) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE COLON dec_mvar
    (66) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE

    CTEINT          shift and go to state 296


state 291

    (62) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE COLON . dec_mvar
    (61) dec_mvar -> . ID guardarID COLON dec_mvar
    (62) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (63) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (64) dec_mvar -> . ID guardarID
    (65) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE
    (66) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 186

    dec_mvar                       shift and go to state 297

state 292

    (108) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body . ifEndElse
    (112) ifEndElse -> . empty
    (135) empty -> .

    IF              reduce using rule 135 (empty -> .)
    PRINT           reduce using rule 135 (empty -> .)
    READ            reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    PLOT            reduce using rule 135 (empty -> .)
    RETURN          reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    MAX             reduce using rule 135 (empty -> .)
    MIN             reduce using rule 135 (empty -> .)
    SUM             reduce using rule 135 (empty -> .)
    NORMAL          reduce using rule 135 (empty -> .)
    UNIFORME        reduce using rule 135 (empty -> .)
    POISSON         reduce using rule 135 (empty -> .)
    BINOMIAL        reduce using rule 135 (empty -> .)
    INT             reduce using rule 135 (empty -> .)
    FLOAT           reduce using rule 135 (empty -> .)
    CHAR            reduce using rule 135 (empty -> .)
    BRACKETCLOSE    reduce using rule 135 (empty -> .)

    ifEndElse                      shift and go to state 298
    empty                          shift and go to state 299

state 293

    (134) normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 134 (normal -> NORMAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)


state 294

    (133) uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 133 (uniforme -> UNIFORME PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)


state 295

    (131) binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 131 (binomial -> BINOMIAL PARENOPEN exp COLON exp COLON exp PARENCLOSE SEMICOLON .)


state 296

    (63) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE COLON dec_mvar
    (66) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE

    BRACECLOSE      shift and go to state 300


state 297

    (62) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .

    SEMICOLON       reduce using rule 62 (dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .)


state 298

    (108) condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .

    IF              reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    PRINT           reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    READ            reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    ID              reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    PLOT            reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    RETURN          reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    WHILE           reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    MAX             reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    MIN             reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    SUM             reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    NORMAL          reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    UNIFORME        reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    POISSON         reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    BINOMIAL        reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    INT             reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    FLOAT           reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    CHAR            reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)
    BRACKETCLOSE    reduce using rule 108 (condition -> IF PARENOPEN exp PARENCLOSE cuadruploIF body cuadruploElse ELSE body ifEndElse .)


state 299

    (112) ifEndElse -> empty .

    IF              reduce using rule 112 (ifEndElse -> empty .)
    PRINT           reduce using rule 112 (ifEndElse -> empty .)
    READ            reduce using rule 112 (ifEndElse -> empty .)
    ID              reduce using rule 112 (ifEndElse -> empty .)
    PLOT            reduce using rule 112 (ifEndElse -> empty .)
    RETURN          reduce using rule 112 (ifEndElse -> empty .)
    WHILE           reduce using rule 112 (ifEndElse -> empty .)
    MAX             reduce using rule 112 (ifEndElse -> empty .)
    MIN             reduce using rule 112 (ifEndElse -> empty .)
    SUM             reduce using rule 112 (ifEndElse -> empty .)
    NORMAL          reduce using rule 112 (ifEndElse -> empty .)
    UNIFORME        reduce using rule 112 (ifEndElse -> empty .)
    POISSON         reduce using rule 112 (ifEndElse -> empty .)
    BINOMIAL        reduce using rule 112 (ifEndElse -> empty .)
    INT             reduce using rule 112 (ifEndElse -> empty .)
    FLOAT           reduce using rule 112 (ifEndElse -> empty .)
    CHAR            reduce using rule 112 (ifEndElse -> empty .)
    BRACKETCLOSE    reduce using rule 112 (ifEndElse -> empty .)


state 300

    (63) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE . COLON dec_mvar
    (66) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .

    COLON           shift and go to state 301
    SEMICOLON       reduce using rule 66 (dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .)


state 301

    (63) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON . dec_mvar
    (61) dec_mvar -> . ID guardarID COLON dec_mvar
    (62) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (63) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (64) dec_mvar -> . ID guardarID
    (65) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE
    (66) dec_mvar -> . ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 186

    dec_mvar                       shift and go to state 302

state 302

    (63) dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .

    SEMICOLON       reduce using rule 63 (dec_mvar -> ID guardarID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 226 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 226 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 226 resolved as shift
WARNING: reduce/reduce conflict in state 66 resolved using rule (bodyy -> statement)
WARNING: rejected rule (empty -> <empty>) in state 66
WARNING: reduce/reduce conflict in state 123 resolved using rule (factor -> ID)
WARNING: rejected rule (variable -> ID) in state 123
