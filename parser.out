Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start_program
Rule 1     start_program -> PROGRAM ID SEMICOLON vars multiple_funcs main_body
Rule 2     start_program -> PROGRAM ID SEMICOLON vars main_body
Rule 3     start_program -> PROGRAM ID SEMICOLON multiple_funcs main_body
Rule 4     start_program -> PROGRAM ID SEMICOLON main_body
Rule 5     multiple_funcs -> dec_func
Rule 6     multiple_funcs -> dec_func multiple_funcs
Rule 7     main_body -> MAIN body
Rule 8     vars -> VAR varss
Rule 9     varss -> type mvar SEMICOLON varss
Rule 10    varss -> type mvar SEMICOLON
Rule 11    mvar -> ID COLON mvar
Rule 12    mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
Rule 13    mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
Rule 14    mvar -> ID
Rule 15    mvar -> ID BRACEOPEN CTEINT BRACECLOSE
Rule 16    mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE
Rule 17    dec_func -> FUNCTION type ID PARENOPEN param PARENCLOSE body
Rule 18    dec_func -> FUNCTION VOID ID PARENOPEN param PARENCLOSE body
Rule 19    param -> type variable
Rule 20    param -> type variable COLON param
Rule 21    param -> empty
Rule 22    type -> INT
Rule 23    type -> FLOAT
Rule 24    type -> CHAR
Rule 25    body -> BRACKETOPEN bodyy BRACKETCLOSE
Rule 26    bodyy -> statement
Rule 27    bodyy -> statement bodyy
Rule 28    bodyy -> empty
Rule 29    statement -> dec_variables
Rule 30    statement -> assignment
Rule 31    statement -> condition
Rule 32    statement -> writing
Rule 33    statement -> reading
Rule 34    statement -> call_func
Rule 35    statement -> graph
Rule 36    statement -> return
Rule 37    statement -> while_loop
Rule 38    statement -> for_loop
Rule 39    statement -> max
Rule 40    statement -> min
Rule 41    statement -> sum
Rule 42    statement -> normal
Rule 43    statement -> uniforme
Rule 44    statement -> poisson
Rule 45    statement -> binomial
Rule 46    dec_variables -> dec_variabless
Rule 47    dec_variabless -> type dec_mvar SEMICOLON dec_variabless
Rule 48    dec_variabless -> type dec_mvar SEMICOLON
Rule 49    dec_mvar -> ID COLON dec_mvar
Rule 50    dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
Rule 51    dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
Rule 52    dec_mvar -> ID
Rule 53    dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE
Rule 54    dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE
Rule 55    assignment -> variable EQUAL exp SEMICOLON
Rule 56    call_func -> ID PARENOPEN call_funcc PARENCLOSE
Rule 57    call_funcc -> exp
Rule 58    call_funcc -> exp COLON call_funcc
Rule 59    call_funcc -> empty
Rule 60    graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON
Rule 61    exp -> exp GREATHERTHAN exp
Rule 62    exp -> exp LESSTHAN exp
Rule 63    exp -> exp GREATHEREQUAL exp
Rule 64    exp -> exp LESSEQUAL exp
Rule 65    exp -> exp DIFFERENT exp
Rule 66    exp -> exp SAME exp
Rule 67    exp -> exp AND exp
Rule 68    exp -> exp OR exp
Rule 69    exp -> m_exp
Rule 70    m_exp -> t m_expp
Rule 71    m_expp -> PLUS appendPLUS m_exp
Rule 72    m_expp -> MINUS appendMINUS m_exp
Rule 73    m_expp -> empty
Rule 74    appendPLUS -> empty
Rule 75    appendMINUS -> empty
Rule 76    appendMULTIPLY -> empty
Rule 77    appendDIVIDE -> empty
Rule 78    t -> f termino
Rule 79    termino -> MULTIPLY appendMULTIPLY t
Rule 80    termino -> DIVIDE appendDIVIDE t
Rule 81    termino -> empty
Rule 82    f -> PARENOPEN exp PARENCLOSE
Rule 83    f -> ID
Rule 84    f -> CTEINT
Rule 85    f -> CTFLOAT
Rule 86    f -> variable
Rule 87    f -> call_func
Rule 88    variable -> ID
Rule 89    variable -> ID BRACEOPEN exp BRACECLOSE
Rule 90    variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
Rule 91    condition -> IF PARENOPEN exp PARENCLOSE body
Rule 92    condition -> IF PARENOPEN exp PARENCLOSE body ELSE body
Rule 93    cuadruploIF -> empty
Rule 94    writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
Rule 95    writingg -> exp
Rule 96    writingg -> exp COLON writingg
Rule 97    writingg -> auxString
Rule 98    writingg -> auxString COLON writingg
Rule 99    auxString -> CTESTRING
Rule 100   reading -> READ multivariables SEMICOLON
Rule 101   multivariables -> variable
Rule 102   multivariables -> variable COLON multivariables
Rule 103   while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
Rule 104   whileMigaja -> empty
Rule 105   whileEval -> empty
Rule 106   whileEnd -> empty
Rule 107   for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body
Rule 108   for_assignment -> variable EQUAL exp
Rule 109   return -> RETURN exp SEMICOLON
Rule 110   max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON
Rule 111   min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON
Rule 112   sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON
Rule 113   param_dist -> variable
Rule 114   param_dist -> variable COLON param_dist
Rule 115   binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 116   poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 117   uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 118   normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON
Rule 119   empty -> <empty>

Terminals, with rules where they appear

AND                  : 67
BINOMIAL             : 115
BRACECLOSE           : 12 13 13 15 16 16 50 51 51 53 54 54 89 90 90
BRACEOPEN            : 12 13 13 15 16 16 50 51 51 53 54 54 89 90 90
BRACKETCLOSE         : 25
BRACKETOPEN          : 25
CHAR                 : 24
COLON                : 11 12 13 20 49 50 51 58 96 98 102 114
CTEINT               : 12 13 13 15 16 16 50 51 51 53 54 54 84
CTESTRING            : 99
CTFLOAT              : 85
DIFFERENT            : 65
DIVIDE               : 80
ELSE                 : 92
EQUAL                : 55 108
FLOAT                : 23
FOR                  : 107
FUNCTION             : 17 18
GREATHEREQUAL        : 63
GREATHERTHAN         : 61
ID                   : 1 2 3 4 11 12 13 14 15 16 17 18 49 50 51 52 53 54 56 83 88 89 90
IF                   : 91 92
INT                  : 22
LESSEQUAL            : 64
LESSTHAN             : 62
MAIN                 : 7
MAX                  : 110
MIN                  : 111
MINUS                : 72
MULTIPLY             : 79
NORMAL               : 118
OR                   : 68
PARENCLOSE           : 17 18 56 60 82 91 92 94 103 107 110 111 112 115 116 117 118
PARENOPEN            : 17 18 56 60 82 91 92 94 103 107 110 111 112 115 116 117 118
PLOT                 : 60
PLUS                 : 71
POISSON              : 116
PRINT                : 94
PROGRAM              : 1 2 3 4
READ                 : 100
RETURN               : 109
SAME                 : 66
SEMICOLON            : 1 2 3 4 9 10 47 48 55 60 94 100 107 107 109 110 111 112 115 116 117 118
SUM                  : 112
UNIFORME             : 117
VAR                  : 8
VOID                 : 18
WHILE                : 103
error                : 

Nonterminals, with rules where they appear

appendDIVIDE         : 80
appendMINUS          : 72
appendMULTIPLY       : 79
appendPLUS           : 71
assignment           : 30
auxString            : 97 98
binomial             : 45
body                 : 7 17 18 91 92 92 103 107
bodyy                : 25 27
call_func            : 34 87
call_funcc           : 56 58
condition            : 31
cuadruploIF          : 
dec_func             : 5 6
dec_mvar             : 47 48 49 50 51
dec_variables        : 29
dec_variabless       : 46 47
empty                : 21 28 59 73 74 75 76 77 81 93 104 105 106
exp                  : 55 57 58 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 82 89 90 90 91 92 95 96 103 107 108 109 110 111 112
f                    : 78
for_assignment       : 107 107
for_loop             : 38
graph                : 35
m_exp                : 69 71 72
m_expp               : 70
main_body            : 1 2 3 4
max                  : 39
min                  : 40
multiple_funcs       : 1 3 6
multivariables       : 100 102
mvar                 : 9 10 11 12 13
normal               : 42
param                : 17 18 20
param_dist           : 114 115 116 117 118
poisson              : 44
reading              : 33
return               : 36
start_program        : 0
statement            : 26 27
sum                  : 41
t                    : 70 79 80
termino              : 78
type                 : 9 10 17 19 20 47 48
uniforme             : 43
variable             : 19 20 55 86 101 102 108 113 114
vars                 : 1 2
varss                : 8 9
whileEnd             : 103
whileEval            : 103
whileMigaja          : 103
while_loop           : 37
writing              : 32
writingg             : 94 96 98

Parsing method: LALR

state 0

    (0) S' -> . start_program
    (1) start_program -> . PROGRAM ID SEMICOLON vars multiple_funcs main_body
    (2) start_program -> . PROGRAM ID SEMICOLON vars main_body
    (3) start_program -> . PROGRAM ID SEMICOLON multiple_funcs main_body
    (4) start_program -> . PROGRAM ID SEMICOLON main_body

    PROGRAM         shift and go to state 2

    start_program                  shift and go to state 1

state 1

    (0) S' -> start_program .



state 2

    (1) start_program -> PROGRAM . ID SEMICOLON vars multiple_funcs main_body
    (2) start_program -> PROGRAM . ID SEMICOLON vars main_body
    (3) start_program -> PROGRAM . ID SEMICOLON multiple_funcs main_body
    (4) start_program -> PROGRAM . ID SEMICOLON main_body

    ID              shift and go to state 3


state 3

    (1) start_program -> PROGRAM ID . SEMICOLON vars multiple_funcs main_body
    (2) start_program -> PROGRAM ID . SEMICOLON vars main_body
    (3) start_program -> PROGRAM ID . SEMICOLON multiple_funcs main_body
    (4) start_program -> PROGRAM ID . SEMICOLON main_body

    SEMICOLON       shift and go to state 4


state 4

    (1) start_program -> PROGRAM ID SEMICOLON . vars multiple_funcs main_body
    (2) start_program -> PROGRAM ID SEMICOLON . vars main_body
    (3) start_program -> PROGRAM ID SEMICOLON . multiple_funcs main_body
    (4) start_program -> PROGRAM ID SEMICOLON . main_body
    (8) vars -> . VAR varss
    (5) multiple_funcs -> . dec_func
    (6) multiple_funcs -> . dec_func multiple_funcs
    (7) main_body -> . MAIN body
    (17) dec_func -> . FUNCTION type ID PARENOPEN param PARENCLOSE body
    (18) dec_func -> . FUNCTION VOID ID PARENOPEN param PARENCLOSE body

    VAR             shift and go to state 8
    MAIN            shift and go to state 10
    FUNCTION        shift and go to state 11

    vars                           shift and go to state 5
    multiple_funcs                 shift and go to state 6
    main_body                      shift and go to state 7
    dec_func                       shift and go to state 9

state 5

    (1) start_program -> PROGRAM ID SEMICOLON vars . multiple_funcs main_body
    (2) start_program -> PROGRAM ID SEMICOLON vars . main_body
    (5) multiple_funcs -> . dec_func
    (6) multiple_funcs -> . dec_func multiple_funcs
    (7) main_body -> . MAIN body
    (17) dec_func -> . FUNCTION type ID PARENOPEN param PARENCLOSE body
    (18) dec_func -> . FUNCTION VOID ID PARENOPEN param PARENCLOSE body

    MAIN            shift and go to state 10
    FUNCTION        shift and go to state 11

    multiple_funcs                 shift and go to state 12
    main_body                      shift and go to state 13
    dec_func                       shift and go to state 9

state 6

    (3) start_program -> PROGRAM ID SEMICOLON multiple_funcs . main_body
    (7) main_body -> . MAIN body

    MAIN            shift and go to state 10

    main_body                      shift and go to state 14

state 7

    (4) start_program -> PROGRAM ID SEMICOLON main_body .

    $end            reduce using rule 4 (start_program -> PROGRAM ID SEMICOLON main_body .)


state 8

    (8) vars -> VAR . varss
    (9) varss -> . type mvar SEMICOLON varss
    (10) varss -> . type mvar SEMICOLON
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . CHAR

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19

    varss                          shift and go to state 15
    type                           shift and go to state 16

state 9

    (5) multiple_funcs -> dec_func .
    (6) multiple_funcs -> dec_func . multiple_funcs
    (5) multiple_funcs -> . dec_func
    (6) multiple_funcs -> . dec_func multiple_funcs
    (17) dec_func -> . FUNCTION type ID PARENOPEN param PARENCLOSE body
    (18) dec_func -> . FUNCTION VOID ID PARENOPEN param PARENCLOSE body

    MAIN            reduce using rule 5 (multiple_funcs -> dec_func .)
    FUNCTION        shift and go to state 11

    dec_func                       shift and go to state 9
    multiple_funcs                 shift and go to state 20

state 10

    (7) main_body -> MAIN . body
    (25) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 22

    body                           shift and go to state 21

state 11

    (17) dec_func -> FUNCTION . type ID PARENOPEN param PARENCLOSE body
    (18) dec_func -> FUNCTION . VOID ID PARENOPEN param PARENCLOSE body
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . CHAR

    VOID            shift and go to state 24
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19

    type                           shift and go to state 23

state 12

    (1) start_program -> PROGRAM ID SEMICOLON vars multiple_funcs . main_body
    (7) main_body -> . MAIN body

    MAIN            shift and go to state 10

    main_body                      shift and go to state 25

state 13

    (2) start_program -> PROGRAM ID SEMICOLON vars main_body .

    $end            reduce using rule 2 (start_program -> PROGRAM ID SEMICOLON vars main_body .)


state 14

    (3) start_program -> PROGRAM ID SEMICOLON multiple_funcs main_body .

    $end            reduce using rule 3 (start_program -> PROGRAM ID SEMICOLON multiple_funcs main_body .)


state 15

    (8) vars -> VAR varss .

    MAIN            reduce using rule 8 (vars -> VAR varss .)
    FUNCTION        reduce using rule 8 (vars -> VAR varss .)


state 16

    (9) varss -> type . mvar SEMICOLON varss
    (10) varss -> type . mvar SEMICOLON
    (11) mvar -> . ID COLON mvar
    (12) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (13) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (14) mvar -> . ID
    (15) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (16) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 27

    mvar                           shift and go to state 26

state 17

    (22) type -> INT .

    ID              reduce using rule 22 (type -> INT .)


state 18

    (23) type -> FLOAT .

    ID              reduce using rule 23 (type -> FLOAT .)


state 19

    (24) type -> CHAR .

    ID              reduce using rule 24 (type -> CHAR .)


state 20

    (6) multiple_funcs -> dec_func multiple_funcs .

    MAIN            reduce using rule 6 (multiple_funcs -> dec_func multiple_funcs .)


state 21

    (7) main_body -> MAIN body .

    $end            reduce using rule 7 (main_body -> MAIN body .)


state 22

    (25) body -> BRACKETOPEN . bodyy BRACKETCLOSE
    (26) bodyy -> . statement
    (27) bodyy -> . statement bodyy
    (28) bodyy -> . empty
    (29) statement -> . dec_variables
    (30) statement -> . assignment
    (31) statement -> . condition
    (32) statement -> . writing
    (33) statement -> . reading
    (34) statement -> . call_func
    (35) statement -> . graph
    (36) statement -> . return
    (37) statement -> . while_loop
    (38) statement -> . for_loop
    (39) statement -> . max
    (40) statement -> . min
    (41) statement -> . sum
    (42) statement -> . normal
    (43) statement -> . uniforme
    (44) statement -> . poisson
    (45) statement -> . binomial
    (119) empty -> .
    (46) dec_variables -> . dec_variabless
    (55) assignment -> . variable EQUAL exp SEMICOLON
    (91) condition -> . IF PARENOPEN exp PARENCLOSE body
    (92) condition -> . IF PARENOPEN exp PARENCLOSE body ELSE body
    (94) writing -> . PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
    (100) reading -> . READ multivariables SEMICOLON
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE
    (60) graph -> . PLOT PARENOPEN exp PARENCLOSE SEMICOLON
    (109) return -> . RETURN exp SEMICOLON
    (103) while_loop -> . WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (107) for_loop -> . FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body
    (110) max -> . MAX PARENOPEN exp PARENCLOSE SEMICOLON
    (111) min -> . MIN PARENOPEN exp PARENCLOSE SEMICOLON
    (112) sum -> . SUM PARENOPEN exp PARENCLOSE SEMICOLON
    (118) normal -> . NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (117) uniforme -> . UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON
    (116) poisson -> . POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON
    (115) binomial -> . BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (47) dec_variabless -> . type dec_mvar SEMICOLON dec_variabless
    (48) dec_variabless -> . type dec_mvar SEMICOLON
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . CHAR

    BRACKETCLOSE    reduce using rule 119 (empty -> .)
    IF              shift and go to state 50
    PRINT           shift and go to state 51
    READ            shift and go to state 52
    ID              shift and go to state 53
    PLOT            shift and go to state 54
    RETURN          shift and go to state 55
    WHILE           shift and go to state 56
    FOR             shift and go to state 57
    MAX             shift and go to state 58
    MIN             shift and go to state 59
    SUM             shift and go to state 60
    NORMAL          shift and go to state 61
    UNIFORME        shift and go to state 62
    POISSON         shift and go to state 63
    BINOMIAL        shift and go to state 64
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19

    bodyy                          shift and go to state 28
    statement                      shift and go to state 29
    empty                          shift and go to state 30
    dec_variables                  shift and go to state 31
    assignment                     shift and go to state 32
    condition                      shift and go to state 33
    writing                        shift and go to state 34
    reading                        shift and go to state 35
    call_func                      shift and go to state 36
    graph                          shift and go to state 37
    return                         shift and go to state 38
    while_loop                     shift and go to state 39
    for_loop                       shift and go to state 40
    max                            shift and go to state 41
    min                            shift and go to state 42
    sum                            shift and go to state 43
    normal                         shift and go to state 44
    uniforme                       shift and go to state 45
    poisson                        shift and go to state 46
    binomial                       shift and go to state 47
    dec_variabless                 shift and go to state 48
    variable                       shift and go to state 49
    type                           shift and go to state 65

state 23

    (17) dec_func -> FUNCTION type . ID PARENOPEN param PARENCLOSE body

    ID              shift and go to state 66


state 24

    (18) dec_func -> FUNCTION VOID . ID PARENOPEN param PARENCLOSE body

    ID              shift and go to state 67


state 25

    (1) start_program -> PROGRAM ID SEMICOLON vars multiple_funcs main_body .

    $end            reduce using rule 1 (start_program -> PROGRAM ID SEMICOLON vars multiple_funcs main_body .)


state 26

    (9) varss -> type mvar . SEMICOLON varss
    (10) varss -> type mvar . SEMICOLON

    SEMICOLON       shift and go to state 68


state 27

    (11) mvar -> ID . COLON mvar
    (12) mvar -> ID . BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (13) mvar -> ID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (14) mvar -> ID .
    (15) mvar -> ID . BRACEOPEN CTEINT BRACECLOSE
    (16) mvar -> ID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 69
    BRACEOPEN       shift and go to state 70
    SEMICOLON       reduce using rule 14 (mvar -> ID .)


state 28

    (25) body -> BRACKETOPEN bodyy . BRACKETCLOSE

    BRACKETCLOSE    shift and go to state 71


state 29

    (26) bodyy -> statement .
    (27) bodyy -> statement . bodyy
    (26) bodyy -> . statement
    (27) bodyy -> . statement bodyy
    (28) bodyy -> . empty
    (29) statement -> . dec_variables
    (30) statement -> . assignment
    (31) statement -> . condition
    (32) statement -> . writing
    (33) statement -> . reading
    (34) statement -> . call_func
    (35) statement -> . graph
    (36) statement -> . return
    (37) statement -> . while_loop
    (38) statement -> . for_loop
    (39) statement -> . max
    (40) statement -> . min
    (41) statement -> . sum
    (42) statement -> . normal
    (43) statement -> . uniforme
    (44) statement -> . poisson
    (45) statement -> . binomial
    (119) empty -> .
    (46) dec_variables -> . dec_variabless
    (55) assignment -> . variable EQUAL exp SEMICOLON
    (91) condition -> . IF PARENOPEN exp PARENCLOSE body
    (92) condition -> . IF PARENOPEN exp PARENCLOSE body ELSE body
    (94) writing -> . PRINT PARENOPEN writingg PARENCLOSE SEMICOLON
    (100) reading -> . READ multivariables SEMICOLON
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE
    (60) graph -> . PLOT PARENOPEN exp PARENCLOSE SEMICOLON
    (109) return -> . RETURN exp SEMICOLON
    (103) while_loop -> . WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (107) for_loop -> . FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body
    (110) max -> . MAX PARENOPEN exp PARENCLOSE SEMICOLON
    (111) min -> . MIN PARENOPEN exp PARENCLOSE SEMICOLON
    (112) sum -> . SUM PARENOPEN exp PARENCLOSE SEMICOLON
    (118) normal -> . NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (117) uniforme -> . UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON
    (116) poisson -> . POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON
    (115) binomial -> . BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON
    (47) dec_variabless -> . type dec_mvar SEMICOLON dec_variabless
    (48) dec_variabless -> . type dec_mvar SEMICOLON
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . CHAR

  ! reduce/reduce conflict for BRACKETCLOSE resolved using rule 26 (bodyy -> statement .)
    BRACKETCLOSE    reduce using rule 26 (bodyy -> statement .)
    IF              shift and go to state 50
    PRINT           shift and go to state 51
    READ            shift and go to state 52
    ID              shift and go to state 53
    PLOT            shift and go to state 54
    RETURN          shift and go to state 55
    WHILE           shift and go to state 56
    FOR             shift and go to state 57
    MAX             shift and go to state 58
    MIN             shift and go to state 59
    SUM             shift and go to state 60
    NORMAL          shift and go to state 61
    UNIFORME        shift and go to state 62
    POISSON         shift and go to state 63
    BINOMIAL        shift and go to state 64
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19

  ! BRACKETCLOSE    [ reduce using rule 119 (empty -> .) ]

    statement                      shift and go to state 29
    bodyy                          shift and go to state 72
    empty                          shift and go to state 30
    dec_variables                  shift and go to state 31
    assignment                     shift and go to state 32
    condition                      shift and go to state 33
    writing                        shift and go to state 34
    reading                        shift and go to state 35
    call_func                      shift and go to state 36
    graph                          shift and go to state 37
    return                         shift and go to state 38
    while_loop                     shift and go to state 39
    for_loop                       shift and go to state 40
    max                            shift and go to state 41
    min                            shift and go to state 42
    sum                            shift and go to state 43
    normal                         shift and go to state 44
    uniforme                       shift and go to state 45
    poisson                        shift and go to state 46
    binomial                       shift and go to state 47
    dec_variabless                 shift and go to state 48
    variable                       shift and go to state 49
    type                           shift and go to state 65

state 30

    (28) bodyy -> empty .

    BRACKETCLOSE    reduce using rule 28 (bodyy -> empty .)


state 31

    (29) statement -> dec_variables .

    IF              reduce using rule 29 (statement -> dec_variables .)
    PRINT           reduce using rule 29 (statement -> dec_variables .)
    READ            reduce using rule 29 (statement -> dec_variables .)
    ID              reduce using rule 29 (statement -> dec_variables .)
    PLOT            reduce using rule 29 (statement -> dec_variables .)
    RETURN          reduce using rule 29 (statement -> dec_variables .)
    WHILE           reduce using rule 29 (statement -> dec_variables .)
    FOR             reduce using rule 29 (statement -> dec_variables .)
    MAX             reduce using rule 29 (statement -> dec_variables .)
    MIN             reduce using rule 29 (statement -> dec_variables .)
    SUM             reduce using rule 29 (statement -> dec_variables .)
    NORMAL          reduce using rule 29 (statement -> dec_variables .)
    UNIFORME        reduce using rule 29 (statement -> dec_variables .)
    POISSON         reduce using rule 29 (statement -> dec_variables .)
    BINOMIAL        reduce using rule 29 (statement -> dec_variables .)
    INT             reduce using rule 29 (statement -> dec_variables .)
    FLOAT           reduce using rule 29 (statement -> dec_variables .)
    CHAR            reduce using rule 29 (statement -> dec_variables .)
    BRACKETCLOSE    reduce using rule 29 (statement -> dec_variables .)


state 32

    (30) statement -> assignment .

    IF              reduce using rule 30 (statement -> assignment .)
    PRINT           reduce using rule 30 (statement -> assignment .)
    READ            reduce using rule 30 (statement -> assignment .)
    ID              reduce using rule 30 (statement -> assignment .)
    PLOT            reduce using rule 30 (statement -> assignment .)
    RETURN          reduce using rule 30 (statement -> assignment .)
    WHILE           reduce using rule 30 (statement -> assignment .)
    FOR             reduce using rule 30 (statement -> assignment .)
    MAX             reduce using rule 30 (statement -> assignment .)
    MIN             reduce using rule 30 (statement -> assignment .)
    SUM             reduce using rule 30 (statement -> assignment .)
    NORMAL          reduce using rule 30 (statement -> assignment .)
    UNIFORME        reduce using rule 30 (statement -> assignment .)
    POISSON         reduce using rule 30 (statement -> assignment .)
    BINOMIAL        reduce using rule 30 (statement -> assignment .)
    INT             reduce using rule 30 (statement -> assignment .)
    FLOAT           reduce using rule 30 (statement -> assignment .)
    CHAR            reduce using rule 30 (statement -> assignment .)
    BRACKETCLOSE    reduce using rule 30 (statement -> assignment .)


state 33

    (31) statement -> condition .

    IF              reduce using rule 31 (statement -> condition .)
    PRINT           reduce using rule 31 (statement -> condition .)
    READ            reduce using rule 31 (statement -> condition .)
    ID              reduce using rule 31 (statement -> condition .)
    PLOT            reduce using rule 31 (statement -> condition .)
    RETURN          reduce using rule 31 (statement -> condition .)
    WHILE           reduce using rule 31 (statement -> condition .)
    FOR             reduce using rule 31 (statement -> condition .)
    MAX             reduce using rule 31 (statement -> condition .)
    MIN             reduce using rule 31 (statement -> condition .)
    SUM             reduce using rule 31 (statement -> condition .)
    NORMAL          reduce using rule 31 (statement -> condition .)
    UNIFORME        reduce using rule 31 (statement -> condition .)
    POISSON         reduce using rule 31 (statement -> condition .)
    BINOMIAL        reduce using rule 31 (statement -> condition .)
    INT             reduce using rule 31 (statement -> condition .)
    FLOAT           reduce using rule 31 (statement -> condition .)
    CHAR            reduce using rule 31 (statement -> condition .)
    BRACKETCLOSE    reduce using rule 31 (statement -> condition .)


state 34

    (32) statement -> writing .

    IF              reduce using rule 32 (statement -> writing .)
    PRINT           reduce using rule 32 (statement -> writing .)
    READ            reduce using rule 32 (statement -> writing .)
    ID              reduce using rule 32 (statement -> writing .)
    PLOT            reduce using rule 32 (statement -> writing .)
    RETURN          reduce using rule 32 (statement -> writing .)
    WHILE           reduce using rule 32 (statement -> writing .)
    FOR             reduce using rule 32 (statement -> writing .)
    MAX             reduce using rule 32 (statement -> writing .)
    MIN             reduce using rule 32 (statement -> writing .)
    SUM             reduce using rule 32 (statement -> writing .)
    NORMAL          reduce using rule 32 (statement -> writing .)
    UNIFORME        reduce using rule 32 (statement -> writing .)
    POISSON         reduce using rule 32 (statement -> writing .)
    BINOMIAL        reduce using rule 32 (statement -> writing .)
    INT             reduce using rule 32 (statement -> writing .)
    FLOAT           reduce using rule 32 (statement -> writing .)
    CHAR            reduce using rule 32 (statement -> writing .)
    BRACKETCLOSE    reduce using rule 32 (statement -> writing .)


state 35

    (33) statement -> reading .

    IF              reduce using rule 33 (statement -> reading .)
    PRINT           reduce using rule 33 (statement -> reading .)
    READ            reduce using rule 33 (statement -> reading .)
    ID              reduce using rule 33 (statement -> reading .)
    PLOT            reduce using rule 33 (statement -> reading .)
    RETURN          reduce using rule 33 (statement -> reading .)
    WHILE           reduce using rule 33 (statement -> reading .)
    FOR             reduce using rule 33 (statement -> reading .)
    MAX             reduce using rule 33 (statement -> reading .)
    MIN             reduce using rule 33 (statement -> reading .)
    SUM             reduce using rule 33 (statement -> reading .)
    NORMAL          reduce using rule 33 (statement -> reading .)
    UNIFORME        reduce using rule 33 (statement -> reading .)
    POISSON         reduce using rule 33 (statement -> reading .)
    BINOMIAL        reduce using rule 33 (statement -> reading .)
    INT             reduce using rule 33 (statement -> reading .)
    FLOAT           reduce using rule 33 (statement -> reading .)
    CHAR            reduce using rule 33 (statement -> reading .)
    BRACKETCLOSE    reduce using rule 33 (statement -> reading .)


state 36

    (34) statement -> call_func .

    IF              reduce using rule 34 (statement -> call_func .)
    PRINT           reduce using rule 34 (statement -> call_func .)
    READ            reduce using rule 34 (statement -> call_func .)
    ID              reduce using rule 34 (statement -> call_func .)
    PLOT            reduce using rule 34 (statement -> call_func .)
    RETURN          reduce using rule 34 (statement -> call_func .)
    WHILE           reduce using rule 34 (statement -> call_func .)
    FOR             reduce using rule 34 (statement -> call_func .)
    MAX             reduce using rule 34 (statement -> call_func .)
    MIN             reduce using rule 34 (statement -> call_func .)
    SUM             reduce using rule 34 (statement -> call_func .)
    NORMAL          reduce using rule 34 (statement -> call_func .)
    UNIFORME        reduce using rule 34 (statement -> call_func .)
    POISSON         reduce using rule 34 (statement -> call_func .)
    BINOMIAL        reduce using rule 34 (statement -> call_func .)
    INT             reduce using rule 34 (statement -> call_func .)
    FLOAT           reduce using rule 34 (statement -> call_func .)
    CHAR            reduce using rule 34 (statement -> call_func .)
    BRACKETCLOSE    reduce using rule 34 (statement -> call_func .)


state 37

    (35) statement -> graph .

    IF              reduce using rule 35 (statement -> graph .)
    PRINT           reduce using rule 35 (statement -> graph .)
    READ            reduce using rule 35 (statement -> graph .)
    ID              reduce using rule 35 (statement -> graph .)
    PLOT            reduce using rule 35 (statement -> graph .)
    RETURN          reduce using rule 35 (statement -> graph .)
    WHILE           reduce using rule 35 (statement -> graph .)
    FOR             reduce using rule 35 (statement -> graph .)
    MAX             reduce using rule 35 (statement -> graph .)
    MIN             reduce using rule 35 (statement -> graph .)
    SUM             reduce using rule 35 (statement -> graph .)
    NORMAL          reduce using rule 35 (statement -> graph .)
    UNIFORME        reduce using rule 35 (statement -> graph .)
    POISSON         reduce using rule 35 (statement -> graph .)
    BINOMIAL        reduce using rule 35 (statement -> graph .)
    INT             reduce using rule 35 (statement -> graph .)
    FLOAT           reduce using rule 35 (statement -> graph .)
    CHAR            reduce using rule 35 (statement -> graph .)
    BRACKETCLOSE    reduce using rule 35 (statement -> graph .)


state 38

    (36) statement -> return .

    IF              reduce using rule 36 (statement -> return .)
    PRINT           reduce using rule 36 (statement -> return .)
    READ            reduce using rule 36 (statement -> return .)
    ID              reduce using rule 36 (statement -> return .)
    PLOT            reduce using rule 36 (statement -> return .)
    RETURN          reduce using rule 36 (statement -> return .)
    WHILE           reduce using rule 36 (statement -> return .)
    FOR             reduce using rule 36 (statement -> return .)
    MAX             reduce using rule 36 (statement -> return .)
    MIN             reduce using rule 36 (statement -> return .)
    SUM             reduce using rule 36 (statement -> return .)
    NORMAL          reduce using rule 36 (statement -> return .)
    UNIFORME        reduce using rule 36 (statement -> return .)
    POISSON         reduce using rule 36 (statement -> return .)
    BINOMIAL        reduce using rule 36 (statement -> return .)
    INT             reduce using rule 36 (statement -> return .)
    FLOAT           reduce using rule 36 (statement -> return .)
    CHAR            reduce using rule 36 (statement -> return .)
    BRACKETCLOSE    reduce using rule 36 (statement -> return .)


state 39

    (37) statement -> while_loop .

    IF              reduce using rule 37 (statement -> while_loop .)
    PRINT           reduce using rule 37 (statement -> while_loop .)
    READ            reduce using rule 37 (statement -> while_loop .)
    ID              reduce using rule 37 (statement -> while_loop .)
    PLOT            reduce using rule 37 (statement -> while_loop .)
    RETURN          reduce using rule 37 (statement -> while_loop .)
    WHILE           reduce using rule 37 (statement -> while_loop .)
    FOR             reduce using rule 37 (statement -> while_loop .)
    MAX             reduce using rule 37 (statement -> while_loop .)
    MIN             reduce using rule 37 (statement -> while_loop .)
    SUM             reduce using rule 37 (statement -> while_loop .)
    NORMAL          reduce using rule 37 (statement -> while_loop .)
    UNIFORME        reduce using rule 37 (statement -> while_loop .)
    POISSON         reduce using rule 37 (statement -> while_loop .)
    BINOMIAL        reduce using rule 37 (statement -> while_loop .)
    INT             reduce using rule 37 (statement -> while_loop .)
    FLOAT           reduce using rule 37 (statement -> while_loop .)
    CHAR            reduce using rule 37 (statement -> while_loop .)
    BRACKETCLOSE    reduce using rule 37 (statement -> while_loop .)


state 40

    (38) statement -> for_loop .

    IF              reduce using rule 38 (statement -> for_loop .)
    PRINT           reduce using rule 38 (statement -> for_loop .)
    READ            reduce using rule 38 (statement -> for_loop .)
    ID              reduce using rule 38 (statement -> for_loop .)
    PLOT            reduce using rule 38 (statement -> for_loop .)
    RETURN          reduce using rule 38 (statement -> for_loop .)
    WHILE           reduce using rule 38 (statement -> for_loop .)
    FOR             reduce using rule 38 (statement -> for_loop .)
    MAX             reduce using rule 38 (statement -> for_loop .)
    MIN             reduce using rule 38 (statement -> for_loop .)
    SUM             reduce using rule 38 (statement -> for_loop .)
    NORMAL          reduce using rule 38 (statement -> for_loop .)
    UNIFORME        reduce using rule 38 (statement -> for_loop .)
    POISSON         reduce using rule 38 (statement -> for_loop .)
    BINOMIAL        reduce using rule 38 (statement -> for_loop .)
    INT             reduce using rule 38 (statement -> for_loop .)
    FLOAT           reduce using rule 38 (statement -> for_loop .)
    CHAR            reduce using rule 38 (statement -> for_loop .)
    BRACKETCLOSE    reduce using rule 38 (statement -> for_loop .)


state 41

    (39) statement -> max .

    IF              reduce using rule 39 (statement -> max .)
    PRINT           reduce using rule 39 (statement -> max .)
    READ            reduce using rule 39 (statement -> max .)
    ID              reduce using rule 39 (statement -> max .)
    PLOT            reduce using rule 39 (statement -> max .)
    RETURN          reduce using rule 39 (statement -> max .)
    WHILE           reduce using rule 39 (statement -> max .)
    FOR             reduce using rule 39 (statement -> max .)
    MAX             reduce using rule 39 (statement -> max .)
    MIN             reduce using rule 39 (statement -> max .)
    SUM             reduce using rule 39 (statement -> max .)
    NORMAL          reduce using rule 39 (statement -> max .)
    UNIFORME        reduce using rule 39 (statement -> max .)
    POISSON         reduce using rule 39 (statement -> max .)
    BINOMIAL        reduce using rule 39 (statement -> max .)
    INT             reduce using rule 39 (statement -> max .)
    FLOAT           reduce using rule 39 (statement -> max .)
    CHAR            reduce using rule 39 (statement -> max .)
    BRACKETCLOSE    reduce using rule 39 (statement -> max .)


state 42

    (40) statement -> min .

    IF              reduce using rule 40 (statement -> min .)
    PRINT           reduce using rule 40 (statement -> min .)
    READ            reduce using rule 40 (statement -> min .)
    ID              reduce using rule 40 (statement -> min .)
    PLOT            reduce using rule 40 (statement -> min .)
    RETURN          reduce using rule 40 (statement -> min .)
    WHILE           reduce using rule 40 (statement -> min .)
    FOR             reduce using rule 40 (statement -> min .)
    MAX             reduce using rule 40 (statement -> min .)
    MIN             reduce using rule 40 (statement -> min .)
    SUM             reduce using rule 40 (statement -> min .)
    NORMAL          reduce using rule 40 (statement -> min .)
    UNIFORME        reduce using rule 40 (statement -> min .)
    POISSON         reduce using rule 40 (statement -> min .)
    BINOMIAL        reduce using rule 40 (statement -> min .)
    INT             reduce using rule 40 (statement -> min .)
    FLOAT           reduce using rule 40 (statement -> min .)
    CHAR            reduce using rule 40 (statement -> min .)
    BRACKETCLOSE    reduce using rule 40 (statement -> min .)


state 43

    (41) statement -> sum .

    IF              reduce using rule 41 (statement -> sum .)
    PRINT           reduce using rule 41 (statement -> sum .)
    READ            reduce using rule 41 (statement -> sum .)
    ID              reduce using rule 41 (statement -> sum .)
    PLOT            reduce using rule 41 (statement -> sum .)
    RETURN          reduce using rule 41 (statement -> sum .)
    WHILE           reduce using rule 41 (statement -> sum .)
    FOR             reduce using rule 41 (statement -> sum .)
    MAX             reduce using rule 41 (statement -> sum .)
    MIN             reduce using rule 41 (statement -> sum .)
    SUM             reduce using rule 41 (statement -> sum .)
    NORMAL          reduce using rule 41 (statement -> sum .)
    UNIFORME        reduce using rule 41 (statement -> sum .)
    POISSON         reduce using rule 41 (statement -> sum .)
    BINOMIAL        reduce using rule 41 (statement -> sum .)
    INT             reduce using rule 41 (statement -> sum .)
    FLOAT           reduce using rule 41 (statement -> sum .)
    CHAR            reduce using rule 41 (statement -> sum .)
    BRACKETCLOSE    reduce using rule 41 (statement -> sum .)


state 44

    (42) statement -> normal .

    IF              reduce using rule 42 (statement -> normal .)
    PRINT           reduce using rule 42 (statement -> normal .)
    READ            reduce using rule 42 (statement -> normal .)
    ID              reduce using rule 42 (statement -> normal .)
    PLOT            reduce using rule 42 (statement -> normal .)
    RETURN          reduce using rule 42 (statement -> normal .)
    WHILE           reduce using rule 42 (statement -> normal .)
    FOR             reduce using rule 42 (statement -> normal .)
    MAX             reduce using rule 42 (statement -> normal .)
    MIN             reduce using rule 42 (statement -> normal .)
    SUM             reduce using rule 42 (statement -> normal .)
    NORMAL          reduce using rule 42 (statement -> normal .)
    UNIFORME        reduce using rule 42 (statement -> normal .)
    POISSON         reduce using rule 42 (statement -> normal .)
    BINOMIAL        reduce using rule 42 (statement -> normal .)
    INT             reduce using rule 42 (statement -> normal .)
    FLOAT           reduce using rule 42 (statement -> normal .)
    CHAR            reduce using rule 42 (statement -> normal .)
    BRACKETCLOSE    reduce using rule 42 (statement -> normal .)


state 45

    (43) statement -> uniforme .

    IF              reduce using rule 43 (statement -> uniforme .)
    PRINT           reduce using rule 43 (statement -> uniforme .)
    READ            reduce using rule 43 (statement -> uniforme .)
    ID              reduce using rule 43 (statement -> uniforme .)
    PLOT            reduce using rule 43 (statement -> uniforme .)
    RETURN          reduce using rule 43 (statement -> uniforme .)
    WHILE           reduce using rule 43 (statement -> uniforme .)
    FOR             reduce using rule 43 (statement -> uniforme .)
    MAX             reduce using rule 43 (statement -> uniforme .)
    MIN             reduce using rule 43 (statement -> uniforme .)
    SUM             reduce using rule 43 (statement -> uniforme .)
    NORMAL          reduce using rule 43 (statement -> uniforme .)
    UNIFORME        reduce using rule 43 (statement -> uniforme .)
    POISSON         reduce using rule 43 (statement -> uniforme .)
    BINOMIAL        reduce using rule 43 (statement -> uniforme .)
    INT             reduce using rule 43 (statement -> uniforme .)
    FLOAT           reduce using rule 43 (statement -> uniforme .)
    CHAR            reduce using rule 43 (statement -> uniforme .)
    BRACKETCLOSE    reduce using rule 43 (statement -> uniforme .)


state 46

    (44) statement -> poisson .

    IF              reduce using rule 44 (statement -> poisson .)
    PRINT           reduce using rule 44 (statement -> poisson .)
    READ            reduce using rule 44 (statement -> poisson .)
    ID              reduce using rule 44 (statement -> poisson .)
    PLOT            reduce using rule 44 (statement -> poisson .)
    RETURN          reduce using rule 44 (statement -> poisson .)
    WHILE           reduce using rule 44 (statement -> poisson .)
    FOR             reduce using rule 44 (statement -> poisson .)
    MAX             reduce using rule 44 (statement -> poisson .)
    MIN             reduce using rule 44 (statement -> poisson .)
    SUM             reduce using rule 44 (statement -> poisson .)
    NORMAL          reduce using rule 44 (statement -> poisson .)
    UNIFORME        reduce using rule 44 (statement -> poisson .)
    POISSON         reduce using rule 44 (statement -> poisson .)
    BINOMIAL        reduce using rule 44 (statement -> poisson .)
    INT             reduce using rule 44 (statement -> poisson .)
    FLOAT           reduce using rule 44 (statement -> poisson .)
    CHAR            reduce using rule 44 (statement -> poisson .)
    BRACKETCLOSE    reduce using rule 44 (statement -> poisson .)


state 47

    (45) statement -> binomial .

    IF              reduce using rule 45 (statement -> binomial .)
    PRINT           reduce using rule 45 (statement -> binomial .)
    READ            reduce using rule 45 (statement -> binomial .)
    ID              reduce using rule 45 (statement -> binomial .)
    PLOT            reduce using rule 45 (statement -> binomial .)
    RETURN          reduce using rule 45 (statement -> binomial .)
    WHILE           reduce using rule 45 (statement -> binomial .)
    FOR             reduce using rule 45 (statement -> binomial .)
    MAX             reduce using rule 45 (statement -> binomial .)
    MIN             reduce using rule 45 (statement -> binomial .)
    SUM             reduce using rule 45 (statement -> binomial .)
    NORMAL          reduce using rule 45 (statement -> binomial .)
    UNIFORME        reduce using rule 45 (statement -> binomial .)
    POISSON         reduce using rule 45 (statement -> binomial .)
    BINOMIAL        reduce using rule 45 (statement -> binomial .)
    INT             reduce using rule 45 (statement -> binomial .)
    FLOAT           reduce using rule 45 (statement -> binomial .)
    CHAR            reduce using rule 45 (statement -> binomial .)
    BRACKETCLOSE    reduce using rule 45 (statement -> binomial .)


state 48

    (46) dec_variables -> dec_variabless .

    IF              reduce using rule 46 (dec_variables -> dec_variabless .)
    PRINT           reduce using rule 46 (dec_variables -> dec_variabless .)
    READ            reduce using rule 46 (dec_variables -> dec_variabless .)
    ID              reduce using rule 46 (dec_variables -> dec_variabless .)
    PLOT            reduce using rule 46 (dec_variables -> dec_variabless .)
    RETURN          reduce using rule 46 (dec_variables -> dec_variabless .)
    WHILE           reduce using rule 46 (dec_variables -> dec_variabless .)
    FOR             reduce using rule 46 (dec_variables -> dec_variabless .)
    MAX             reduce using rule 46 (dec_variables -> dec_variabless .)
    MIN             reduce using rule 46 (dec_variables -> dec_variabless .)
    SUM             reduce using rule 46 (dec_variables -> dec_variabless .)
    NORMAL          reduce using rule 46 (dec_variables -> dec_variabless .)
    UNIFORME        reduce using rule 46 (dec_variables -> dec_variabless .)
    POISSON         reduce using rule 46 (dec_variables -> dec_variabless .)
    BINOMIAL        reduce using rule 46 (dec_variables -> dec_variabless .)
    INT             reduce using rule 46 (dec_variables -> dec_variabless .)
    FLOAT           reduce using rule 46 (dec_variables -> dec_variabless .)
    CHAR            reduce using rule 46 (dec_variables -> dec_variabless .)
    BRACKETCLOSE    reduce using rule 46 (dec_variables -> dec_variabless .)


state 49

    (55) assignment -> variable . EQUAL exp SEMICOLON

    EQUAL           shift and go to state 73


state 50

    (91) condition -> IF . PARENOPEN exp PARENCLOSE body
    (92) condition -> IF . PARENOPEN exp PARENCLOSE body ELSE body

    PARENOPEN       shift and go to state 74


state 51

    (94) writing -> PRINT . PARENOPEN writingg PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 75


state 52

    (100) reading -> READ . multivariables SEMICOLON
    (101) multivariables -> . variable
    (102) multivariables -> . variable COLON multivariables
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 78

    multivariables                 shift and go to state 76
    variable                       shift and go to state 77

state 53

    (56) call_func -> ID . PARENOPEN call_funcc PARENCLOSE
    (88) variable -> ID .
    (89) variable -> ID . BRACEOPEN exp BRACECLOSE
    (90) variable -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    PARENOPEN       shift and go to state 79
    EQUAL           reduce using rule 88 (variable -> ID .)
    BRACEOPEN       shift and go to state 80


state 54

    (60) graph -> PLOT . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 81


state 55

    (109) return -> RETURN . exp SEMICOLON
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 82
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 56

    (103) while_loop -> WHILE . whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd
    (104) whileMigaja -> . empty
    (119) empty -> .

    PARENOPEN       reduce using rule 119 (empty -> .)

    whileMigaja                    shift and go to state 92
    empty                          shift and go to state 93

state 57

    (107) for_loop -> FOR . PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body

    PARENOPEN       shift and go to state 94


state 58

    (110) max -> MAX . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 95


state 59

    (111) min -> MIN . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 96


state 60

    (112) sum -> SUM . PARENOPEN exp PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 97


state 61

    (118) normal -> NORMAL . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 98


state 62

    (117) uniforme -> UNIFORME . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 99


state 63

    (116) poisson -> POISSON . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 100


state 64

    (115) binomial -> BINOMIAL . PARENOPEN param_dist PARENCLOSE SEMICOLON

    PARENOPEN       shift and go to state 101


state 65

    (47) dec_variabless -> type . dec_mvar SEMICOLON dec_variabless
    (48) dec_variabless -> type . dec_mvar SEMICOLON
    (49) dec_mvar -> . ID COLON dec_mvar
    (50) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (51) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (52) dec_mvar -> . ID
    (53) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (54) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 103

    dec_mvar                       shift and go to state 102

state 66

    (17) dec_func -> FUNCTION type ID . PARENOPEN param PARENCLOSE body

    PARENOPEN       shift and go to state 104


state 67

    (18) dec_func -> FUNCTION VOID ID . PARENOPEN param PARENCLOSE body

    PARENOPEN       shift and go to state 105


state 68

    (9) varss -> type mvar SEMICOLON . varss
    (10) varss -> type mvar SEMICOLON .
    (9) varss -> . type mvar SEMICOLON varss
    (10) varss -> . type mvar SEMICOLON
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . CHAR

    MAIN            reduce using rule 10 (varss -> type mvar SEMICOLON .)
    FUNCTION        reduce using rule 10 (varss -> type mvar SEMICOLON .)
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19

    type                           shift and go to state 16
    varss                          shift and go to state 106

state 69

    (11) mvar -> ID COLON . mvar
    (11) mvar -> . ID COLON mvar
    (12) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (13) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (14) mvar -> . ID
    (15) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (16) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 27

    mvar                           shift and go to state 107

state 70

    (12) mvar -> ID BRACEOPEN . CTEINT BRACECLOSE COLON mvar
    (13) mvar -> ID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (15) mvar -> ID BRACEOPEN . CTEINT BRACECLOSE
    (16) mvar -> ID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    CTEINT          shift and go to state 108


state 71

    (25) body -> BRACKETOPEN bodyy BRACKETCLOSE .

    $end            reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    ELSE            reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    IF              reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    PRINT           reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    READ            reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    ID              reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    PLOT            reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    RETURN          reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    WHILE           reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FOR             reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MAX             reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MIN             reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    SUM             reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    NORMAL          reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    UNIFORME        reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    POISSON         reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    BINOMIAL        reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    INT             reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FLOAT           reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    CHAR            reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    BRACKETCLOSE    reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    FUNCTION        reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)
    MAIN            reduce using rule 25 (body -> BRACKETOPEN bodyy BRACKETCLOSE .)


state 72

    (27) bodyy -> statement bodyy .

    BRACKETCLOSE    reduce using rule 27 (bodyy -> statement bodyy .)


state 73

    (55) assignment -> variable EQUAL . exp SEMICOLON
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    variable                       shift and go to state 90
    exp                            shift and go to state 109
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    call_func                      shift and go to state 91

state 74

    (91) condition -> IF PARENOPEN . exp PARENCLOSE body
    (92) condition -> IF PARENOPEN . exp PARENCLOSE body ELSE body
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 110
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 75

    (94) writing -> PRINT PARENOPEN . writingg PARENCLOSE SEMICOLON
    (95) writingg -> . exp
    (96) writingg -> . exp COLON writingg
    (97) writingg -> . auxString
    (98) writingg -> . auxString COLON writingg
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (99) auxString -> . CTESTRING
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 114
    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    writingg                       shift and go to state 111
    exp                            shift and go to state 112
    auxString                      shift and go to state 113
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 76

    (100) reading -> READ multivariables . SEMICOLON

    SEMICOLON       shift and go to state 115


state 77

    (101) multivariables -> variable .
    (102) multivariables -> variable . COLON multivariables

    SEMICOLON       reduce using rule 101 (multivariables -> variable .)
    COLON           shift and go to state 116


state 78

    (88) variable -> ID .
    (89) variable -> ID . BRACEOPEN exp BRACECLOSE
    (90) variable -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    COLON           reduce using rule 88 (variable -> ID .)
    SEMICOLON       reduce using rule 88 (variable -> ID .)
    EQUAL           reduce using rule 88 (variable -> ID .)
    PARENCLOSE      reduce using rule 88 (variable -> ID .)
    BRACEOPEN       shift and go to state 80


state 79

    (56) call_func -> ID PARENOPEN . call_funcc PARENCLOSE
    (57) call_funcc -> . exp
    (58) call_funcc -> . exp COLON call_funcc
    (59) call_funcc -> . empty
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (119) empty -> .
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENCLOSE      reduce using rule 119 (empty -> .)
    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    call_funcc                     shift and go to state 117
    exp                            shift and go to state 118
    empty                          shift and go to state 119
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 80

    (89) variable -> ID BRACEOPEN . exp BRACECLOSE
    (90) variable -> ID BRACEOPEN . exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 120
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 81

    (60) graph -> PLOT PARENOPEN . exp PARENCLOSE SEMICOLON
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 121
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 82

    (109) return -> RETURN exp . SEMICOLON
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

    SEMICOLON       shift and go to state 122
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130


state 83

    (69) exp -> m_exp .

    SEMICOLON       reduce using rule 69 (exp -> m_exp .)
    GREATHERTHAN    reduce using rule 69 (exp -> m_exp .)
    LESSTHAN        reduce using rule 69 (exp -> m_exp .)
    GREATHEREQUAL   reduce using rule 69 (exp -> m_exp .)
    LESSEQUAL       reduce using rule 69 (exp -> m_exp .)
    DIFFERENT       reduce using rule 69 (exp -> m_exp .)
    SAME            reduce using rule 69 (exp -> m_exp .)
    AND             reduce using rule 69 (exp -> m_exp .)
    OR              reduce using rule 69 (exp -> m_exp .)
    PARENCLOSE      reduce using rule 69 (exp -> m_exp .)
    COLON           reduce using rule 69 (exp -> m_exp .)
    BRACECLOSE      reduce using rule 69 (exp -> m_exp .)


state 84

    (70) m_exp -> t . m_expp
    (71) m_expp -> . PLUS appendPLUS m_exp
    (72) m_expp -> . MINUS appendMINUS m_exp
    (73) m_expp -> . empty
    (119) empty -> .

    PLUS            shift and go to state 132
    MINUS           shift and go to state 133
    SEMICOLON       reduce using rule 119 (empty -> .)
    GREATHERTHAN    reduce using rule 119 (empty -> .)
    LESSTHAN        reduce using rule 119 (empty -> .)
    GREATHEREQUAL   reduce using rule 119 (empty -> .)
    LESSEQUAL       reduce using rule 119 (empty -> .)
    DIFFERENT       reduce using rule 119 (empty -> .)
    SAME            reduce using rule 119 (empty -> .)
    AND             reduce using rule 119 (empty -> .)
    OR              reduce using rule 119 (empty -> .)
    PARENCLOSE      reduce using rule 119 (empty -> .)
    COLON           reduce using rule 119 (empty -> .)
    BRACECLOSE      reduce using rule 119 (empty -> .)

    m_expp                         shift and go to state 131
    empty                          shift and go to state 134

state 85

    (78) t -> f . termino
    (79) termino -> . MULTIPLY appendMULTIPLY t
    (80) termino -> . DIVIDE appendDIVIDE t
    (81) termino -> . empty
    (119) empty -> .

    MULTIPLY        shift and go to state 136
    DIVIDE          shift and go to state 137
    PLUS            reduce using rule 119 (empty -> .)
    MINUS           reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    GREATHERTHAN    reduce using rule 119 (empty -> .)
    LESSTHAN        reduce using rule 119 (empty -> .)
    GREATHEREQUAL   reduce using rule 119 (empty -> .)
    LESSEQUAL       reduce using rule 119 (empty -> .)
    DIFFERENT       reduce using rule 119 (empty -> .)
    SAME            reduce using rule 119 (empty -> .)
    AND             reduce using rule 119 (empty -> .)
    OR              reduce using rule 119 (empty -> .)
    PARENCLOSE      reduce using rule 119 (empty -> .)
    COLON           reduce using rule 119 (empty -> .)
    BRACECLOSE      reduce using rule 119 (empty -> .)

    termino                        shift and go to state 135
    empty                          shift and go to state 138

state 86

    (82) f -> PARENOPEN . exp PARENCLOSE
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 139
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 87

    (83) f -> ID .
    (88) variable -> ID .
    (89) variable -> ID . BRACEOPEN exp BRACECLOSE
    (90) variable -> ID . BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> ID . PARENOPEN call_funcc PARENCLOSE

  ! reduce/reduce conflict for MULTIPLY resolved using rule 83 (f -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 83 (f -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 83 (f -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 83 (f -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 83 (f -> ID .)
  ! reduce/reduce conflict for GREATHERTHAN resolved using rule 83 (f -> ID .)
  ! reduce/reduce conflict for LESSTHAN resolved using rule 83 (f -> ID .)
  ! reduce/reduce conflict for GREATHEREQUAL resolved using rule 83 (f -> ID .)
  ! reduce/reduce conflict for LESSEQUAL resolved using rule 83 (f -> ID .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 83 (f -> ID .)
  ! reduce/reduce conflict for SAME resolved using rule 83 (f -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 83 (f -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 83 (f -> ID .)
  ! reduce/reduce conflict for PARENCLOSE resolved using rule 83 (f -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 83 (f -> ID .)
  ! reduce/reduce conflict for BRACECLOSE resolved using rule 83 (f -> ID .)
    MULTIPLY        reduce using rule 83 (f -> ID .)
    DIVIDE          reduce using rule 83 (f -> ID .)
    PLUS            reduce using rule 83 (f -> ID .)
    MINUS           reduce using rule 83 (f -> ID .)
    SEMICOLON       reduce using rule 83 (f -> ID .)
    GREATHERTHAN    reduce using rule 83 (f -> ID .)
    LESSTHAN        reduce using rule 83 (f -> ID .)
    GREATHEREQUAL   reduce using rule 83 (f -> ID .)
    LESSEQUAL       reduce using rule 83 (f -> ID .)
    DIFFERENT       reduce using rule 83 (f -> ID .)
    SAME            reduce using rule 83 (f -> ID .)
    AND             reduce using rule 83 (f -> ID .)
    OR              reduce using rule 83 (f -> ID .)
    PARENCLOSE      reduce using rule 83 (f -> ID .)
    COLON           reduce using rule 83 (f -> ID .)
    BRACECLOSE      reduce using rule 83 (f -> ID .)
    BRACEOPEN       shift and go to state 80
    PARENOPEN       shift and go to state 79

  ! MULTIPLY        [ reduce using rule 88 (variable -> ID .) ]
  ! DIVIDE          [ reduce using rule 88 (variable -> ID .) ]
  ! PLUS            [ reduce using rule 88 (variable -> ID .) ]
  ! MINUS           [ reduce using rule 88 (variable -> ID .) ]
  ! SEMICOLON       [ reduce using rule 88 (variable -> ID .) ]
  ! GREATHERTHAN    [ reduce using rule 88 (variable -> ID .) ]
  ! LESSTHAN        [ reduce using rule 88 (variable -> ID .) ]
  ! GREATHEREQUAL   [ reduce using rule 88 (variable -> ID .) ]
  ! LESSEQUAL       [ reduce using rule 88 (variable -> ID .) ]
  ! DIFFERENT       [ reduce using rule 88 (variable -> ID .) ]
  ! SAME            [ reduce using rule 88 (variable -> ID .) ]
  ! AND             [ reduce using rule 88 (variable -> ID .) ]
  ! OR              [ reduce using rule 88 (variable -> ID .) ]
  ! PARENCLOSE      [ reduce using rule 88 (variable -> ID .) ]
  ! COLON           [ reduce using rule 88 (variable -> ID .) ]
  ! BRACECLOSE      [ reduce using rule 88 (variable -> ID .) ]


state 88

    (84) f -> CTEINT .

    MULTIPLY        reduce using rule 84 (f -> CTEINT .)
    DIVIDE          reduce using rule 84 (f -> CTEINT .)
    PLUS            reduce using rule 84 (f -> CTEINT .)
    MINUS           reduce using rule 84 (f -> CTEINT .)
    SEMICOLON       reduce using rule 84 (f -> CTEINT .)
    GREATHERTHAN    reduce using rule 84 (f -> CTEINT .)
    LESSTHAN        reduce using rule 84 (f -> CTEINT .)
    GREATHEREQUAL   reduce using rule 84 (f -> CTEINT .)
    LESSEQUAL       reduce using rule 84 (f -> CTEINT .)
    DIFFERENT       reduce using rule 84 (f -> CTEINT .)
    SAME            reduce using rule 84 (f -> CTEINT .)
    AND             reduce using rule 84 (f -> CTEINT .)
    OR              reduce using rule 84 (f -> CTEINT .)
    PARENCLOSE      reduce using rule 84 (f -> CTEINT .)
    COLON           reduce using rule 84 (f -> CTEINT .)
    BRACECLOSE      reduce using rule 84 (f -> CTEINT .)


state 89

    (85) f -> CTFLOAT .

    MULTIPLY        reduce using rule 85 (f -> CTFLOAT .)
    DIVIDE          reduce using rule 85 (f -> CTFLOAT .)
    PLUS            reduce using rule 85 (f -> CTFLOAT .)
    MINUS           reduce using rule 85 (f -> CTFLOAT .)
    SEMICOLON       reduce using rule 85 (f -> CTFLOAT .)
    GREATHERTHAN    reduce using rule 85 (f -> CTFLOAT .)
    LESSTHAN        reduce using rule 85 (f -> CTFLOAT .)
    GREATHEREQUAL   reduce using rule 85 (f -> CTFLOAT .)
    LESSEQUAL       reduce using rule 85 (f -> CTFLOAT .)
    DIFFERENT       reduce using rule 85 (f -> CTFLOAT .)
    SAME            reduce using rule 85 (f -> CTFLOAT .)
    AND             reduce using rule 85 (f -> CTFLOAT .)
    OR              reduce using rule 85 (f -> CTFLOAT .)
    PARENCLOSE      reduce using rule 85 (f -> CTFLOAT .)
    COLON           reduce using rule 85 (f -> CTFLOAT .)
    BRACECLOSE      reduce using rule 85 (f -> CTFLOAT .)


state 90

    (86) f -> variable .

    MULTIPLY        reduce using rule 86 (f -> variable .)
    DIVIDE          reduce using rule 86 (f -> variable .)
    PLUS            reduce using rule 86 (f -> variable .)
    MINUS           reduce using rule 86 (f -> variable .)
    SEMICOLON       reduce using rule 86 (f -> variable .)
    GREATHERTHAN    reduce using rule 86 (f -> variable .)
    LESSTHAN        reduce using rule 86 (f -> variable .)
    GREATHEREQUAL   reduce using rule 86 (f -> variable .)
    LESSEQUAL       reduce using rule 86 (f -> variable .)
    DIFFERENT       reduce using rule 86 (f -> variable .)
    SAME            reduce using rule 86 (f -> variable .)
    AND             reduce using rule 86 (f -> variable .)
    OR              reduce using rule 86 (f -> variable .)
    PARENCLOSE      reduce using rule 86 (f -> variable .)
    COLON           reduce using rule 86 (f -> variable .)
    BRACECLOSE      reduce using rule 86 (f -> variable .)


state 91

    (87) f -> call_func .

    MULTIPLY        reduce using rule 87 (f -> call_func .)
    DIVIDE          reduce using rule 87 (f -> call_func .)
    PLUS            reduce using rule 87 (f -> call_func .)
    MINUS           reduce using rule 87 (f -> call_func .)
    SEMICOLON       reduce using rule 87 (f -> call_func .)
    GREATHERTHAN    reduce using rule 87 (f -> call_func .)
    LESSTHAN        reduce using rule 87 (f -> call_func .)
    GREATHEREQUAL   reduce using rule 87 (f -> call_func .)
    LESSEQUAL       reduce using rule 87 (f -> call_func .)
    DIFFERENT       reduce using rule 87 (f -> call_func .)
    SAME            reduce using rule 87 (f -> call_func .)
    AND             reduce using rule 87 (f -> call_func .)
    OR              reduce using rule 87 (f -> call_func .)
    PARENCLOSE      reduce using rule 87 (f -> call_func .)
    COLON           reduce using rule 87 (f -> call_func .)
    BRACECLOSE      reduce using rule 87 (f -> call_func .)


state 92

    (103) while_loop -> WHILE whileMigaja . PARENOPEN exp PARENCLOSE whileEval body whileEnd

    PARENOPEN       shift and go to state 140


state 93

    (104) whileMigaja -> empty .

    PARENOPEN       reduce using rule 104 (whileMigaja -> empty .)


state 94

    (107) for_loop -> FOR PARENOPEN . for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body
    (108) for_assignment -> . variable EQUAL exp
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 78

    for_assignment                 shift and go to state 141
    variable                       shift and go to state 142

state 95

    (110) max -> MAX PARENOPEN . exp PARENCLOSE SEMICOLON
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 143
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 96

    (111) min -> MIN PARENOPEN . exp PARENCLOSE SEMICOLON
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 144
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 97

    (112) sum -> SUM PARENOPEN . exp PARENCLOSE SEMICOLON
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 145
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 98

    (118) normal -> NORMAL PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (113) param_dist -> . variable
    (114) param_dist -> . variable COLON param_dist
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 78

    param_dist                     shift and go to state 146
    variable                       shift and go to state 147

state 99

    (117) uniforme -> UNIFORME PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (113) param_dist -> . variable
    (114) param_dist -> . variable COLON param_dist
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 78

    param_dist                     shift and go to state 148
    variable                       shift and go to state 147

state 100

    (116) poisson -> POISSON PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (113) param_dist -> . variable
    (114) param_dist -> . variable COLON param_dist
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 78

    param_dist                     shift and go to state 149
    variable                       shift and go to state 147

state 101

    (115) binomial -> BINOMIAL PARENOPEN . param_dist PARENCLOSE SEMICOLON
    (113) param_dist -> . variable
    (114) param_dist -> . variable COLON param_dist
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 78

    param_dist                     shift and go to state 150
    variable                       shift and go to state 147

state 102

    (47) dec_variabless -> type dec_mvar . SEMICOLON dec_variabless
    (48) dec_variabless -> type dec_mvar . SEMICOLON

    SEMICOLON       shift and go to state 151


state 103

    (49) dec_mvar -> ID . COLON dec_mvar
    (50) dec_mvar -> ID . BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (51) dec_mvar -> ID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (52) dec_mvar -> ID .
    (53) dec_mvar -> ID . BRACEOPEN CTEINT BRACECLOSE
    (54) dec_mvar -> ID . BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 152
    BRACEOPEN       shift and go to state 153
    SEMICOLON       reduce using rule 52 (dec_mvar -> ID .)


state 104

    (17) dec_func -> FUNCTION type ID PARENOPEN . param PARENCLOSE body
    (19) param -> . type variable
    (20) param -> . type variable COLON param
    (21) param -> . empty
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . CHAR
    (119) empty -> .

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    PARENCLOSE      reduce using rule 119 (empty -> .)

    type                           shift and go to state 154
    param                          shift and go to state 155
    empty                          shift and go to state 156

state 105

    (18) dec_func -> FUNCTION VOID ID PARENOPEN . param PARENCLOSE body
    (19) param -> . type variable
    (20) param -> . type variable COLON param
    (21) param -> . empty
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . CHAR
    (119) empty -> .

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    PARENCLOSE      reduce using rule 119 (empty -> .)

    param                          shift and go to state 157
    type                           shift and go to state 154
    empty                          shift and go to state 156

state 106

    (9) varss -> type mvar SEMICOLON varss .

    MAIN            reduce using rule 9 (varss -> type mvar SEMICOLON varss .)
    FUNCTION        reduce using rule 9 (varss -> type mvar SEMICOLON varss .)


state 107

    (11) mvar -> ID COLON mvar .

    SEMICOLON       reduce using rule 11 (mvar -> ID COLON mvar .)


state 108

    (12) mvar -> ID BRACEOPEN CTEINT . BRACECLOSE COLON mvar
    (13) mvar -> ID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (15) mvar -> ID BRACEOPEN CTEINT . BRACECLOSE
    (16) mvar -> ID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    BRACECLOSE      shift and go to state 158


state 109

    (55) assignment -> variable EQUAL exp . SEMICOLON
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

    SEMICOLON       shift and go to state 159
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130


state 110

    (91) condition -> IF PARENOPEN exp . PARENCLOSE body
    (92) condition -> IF PARENOPEN exp . PARENCLOSE body ELSE body
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

    PARENCLOSE      shift and go to state 160
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130


state 111

    (94) writing -> PRINT PARENOPEN writingg . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 161


state 112

    (95) writingg -> exp .
    (96) writingg -> exp . COLON writingg
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

    PARENCLOSE      reduce using rule 95 (writingg -> exp .)
    COLON           shift and go to state 162
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130


state 113

    (97) writingg -> auxString .
    (98) writingg -> auxString . COLON writingg

    PARENCLOSE      reduce using rule 97 (writingg -> auxString .)
    COLON           shift and go to state 163


state 114

    (99) auxString -> CTESTRING .

    COLON           reduce using rule 99 (auxString -> CTESTRING .)
    PARENCLOSE      reduce using rule 99 (auxString -> CTESTRING .)


state 115

    (100) reading -> READ multivariables SEMICOLON .

    IF              reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    PRINT           reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    READ            reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    ID              reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    PLOT            reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    RETURN          reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    WHILE           reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    FOR             reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    MAX             reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    MIN             reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    SUM             reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    NORMAL          reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    UNIFORME        reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    POISSON         reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    BINOMIAL        reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    INT             reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    FLOAT           reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    CHAR            reduce using rule 100 (reading -> READ multivariables SEMICOLON .)
    BRACKETCLOSE    reduce using rule 100 (reading -> READ multivariables SEMICOLON .)


state 116

    (102) multivariables -> variable COLON . multivariables
    (101) multivariables -> . variable
    (102) multivariables -> . variable COLON multivariables
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 78

    variable                       shift and go to state 77
    multivariables                 shift and go to state 164

state 117

    (56) call_func -> ID PARENOPEN call_funcc . PARENCLOSE

    PARENCLOSE      shift and go to state 165


state 118

    (57) call_funcc -> exp .
    (58) call_funcc -> exp . COLON call_funcc
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

    PARENCLOSE      reduce using rule 57 (call_funcc -> exp .)
    COLON           shift and go to state 166
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130


state 119

    (59) call_funcc -> empty .

    PARENCLOSE      reduce using rule 59 (call_funcc -> empty .)


state 120

    (89) variable -> ID BRACEOPEN exp . BRACECLOSE
    (90) variable -> ID BRACEOPEN exp . BRACECLOSE BRACEOPEN exp BRACECLOSE
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

    BRACECLOSE      shift and go to state 167
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130


state 121

    (60) graph -> PLOT PARENOPEN exp . PARENCLOSE SEMICOLON
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

    PARENCLOSE      shift and go to state 168
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130


state 122

    (109) return -> RETURN exp SEMICOLON .

    IF              reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    PRINT           reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    READ            reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    ID              reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    PLOT            reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    RETURN          reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    WHILE           reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    FOR             reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    MAX             reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    MIN             reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    SUM             reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    NORMAL          reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    UNIFORME        reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    POISSON         reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    BINOMIAL        reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    INT             reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    FLOAT           reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    CHAR            reduce using rule 109 (return -> RETURN exp SEMICOLON .)
    BRACKETCLOSE    reduce using rule 109 (return -> RETURN exp SEMICOLON .)


state 123

    (61) exp -> exp GREATHERTHAN . exp
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 169
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 124

    (62) exp -> exp LESSTHAN . exp
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 170
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 125

    (63) exp -> exp GREATHEREQUAL . exp
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 171
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 126

    (64) exp -> exp LESSEQUAL . exp
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 172
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 127

    (65) exp -> exp DIFFERENT . exp
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 173
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 128

    (66) exp -> exp SAME . exp
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 174
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 129

    (67) exp -> exp AND . exp
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 175
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 130

    (68) exp -> exp OR . exp
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 176
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 131

    (70) m_exp -> t m_expp .

    SEMICOLON       reduce using rule 70 (m_exp -> t m_expp .)
    GREATHERTHAN    reduce using rule 70 (m_exp -> t m_expp .)
    LESSTHAN        reduce using rule 70 (m_exp -> t m_expp .)
    GREATHEREQUAL   reduce using rule 70 (m_exp -> t m_expp .)
    LESSEQUAL       reduce using rule 70 (m_exp -> t m_expp .)
    DIFFERENT       reduce using rule 70 (m_exp -> t m_expp .)
    SAME            reduce using rule 70 (m_exp -> t m_expp .)
    AND             reduce using rule 70 (m_exp -> t m_expp .)
    OR              reduce using rule 70 (m_exp -> t m_expp .)
    PARENCLOSE      reduce using rule 70 (m_exp -> t m_expp .)
    COLON           reduce using rule 70 (m_exp -> t m_expp .)
    BRACECLOSE      reduce using rule 70 (m_exp -> t m_expp .)


state 132

    (71) m_expp -> PLUS . appendPLUS m_exp
    (74) appendPLUS -> . empty
    (119) empty -> .

    PARENOPEN       reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    CTEINT          reduce using rule 119 (empty -> .)
    CTFLOAT         reduce using rule 119 (empty -> .)

    appendPLUS                     shift and go to state 177
    empty                          shift and go to state 178

state 133

    (72) m_expp -> MINUS . appendMINUS m_exp
    (75) appendMINUS -> . empty
    (119) empty -> .

    PARENOPEN       reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    CTEINT          reduce using rule 119 (empty -> .)
    CTFLOAT         reduce using rule 119 (empty -> .)

    appendMINUS                    shift and go to state 179
    empty                          shift and go to state 180

state 134

    (73) m_expp -> empty .

    SEMICOLON       reduce using rule 73 (m_expp -> empty .)
    GREATHERTHAN    reduce using rule 73 (m_expp -> empty .)
    LESSTHAN        reduce using rule 73 (m_expp -> empty .)
    GREATHEREQUAL   reduce using rule 73 (m_expp -> empty .)
    LESSEQUAL       reduce using rule 73 (m_expp -> empty .)
    DIFFERENT       reduce using rule 73 (m_expp -> empty .)
    SAME            reduce using rule 73 (m_expp -> empty .)
    AND             reduce using rule 73 (m_expp -> empty .)
    OR              reduce using rule 73 (m_expp -> empty .)
    PARENCLOSE      reduce using rule 73 (m_expp -> empty .)
    COLON           reduce using rule 73 (m_expp -> empty .)
    BRACECLOSE      reduce using rule 73 (m_expp -> empty .)


state 135

    (78) t -> f termino .

    PLUS            reduce using rule 78 (t -> f termino .)
    MINUS           reduce using rule 78 (t -> f termino .)
    SEMICOLON       reduce using rule 78 (t -> f termino .)
    GREATHERTHAN    reduce using rule 78 (t -> f termino .)
    LESSTHAN        reduce using rule 78 (t -> f termino .)
    GREATHEREQUAL   reduce using rule 78 (t -> f termino .)
    LESSEQUAL       reduce using rule 78 (t -> f termino .)
    DIFFERENT       reduce using rule 78 (t -> f termino .)
    SAME            reduce using rule 78 (t -> f termino .)
    AND             reduce using rule 78 (t -> f termino .)
    OR              reduce using rule 78 (t -> f termino .)
    PARENCLOSE      reduce using rule 78 (t -> f termino .)
    COLON           reduce using rule 78 (t -> f termino .)
    BRACECLOSE      reduce using rule 78 (t -> f termino .)


state 136

    (79) termino -> MULTIPLY . appendMULTIPLY t
    (76) appendMULTIPLY -> . empty
    (119) empty -> .

    PARENOPEN       reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    CTEINT          reduce using rule 119 (empty -> .)
    CTFLOAT         reduce using rule 119 (empty -> .)

    appendMULTIPLY                 shift and go to state 181
    empty                          shift and go to state 182

state 137

    (80) termino -> DIVIDE . appendDIVIDE t
    (77) appendDIVIDE -> . empty
    (119) empty -> .

    PARENOPEN       reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    CTEINT          reduce using rule 119 (empty -> .)
    CTFLOAT         reduce using rule 119 (empty -> .)

    appendDIVIDE                   shift and go to state 183
    empty                          shift and go to state 184

state 138

    (81) termino -> empty .

    PLUS            reduce using rule 81 (termino -> empty .)
    MINUS           reduce using rule 81 (termino -> empty .)
    SEMICOLON       reduce using rule 81 (termino -> empty .)
    GREATHERTHAN    reduce using rule 81 (termino -> empty .)
    LESSTHAN        reduce using rule 81 (termino -> empty .)
    GREATHEREQUAL   reduce using rule 81 (termino -> empty .)
    LESSEQUAL       reduce using rule 81 (termino -> empty .)
    DIFFERENT       reduce using rule 81 (termino -> empty .)
    SAME            reduce using rule 81 (termino -> empty .)
    AND             reduce using rule 81 (termino -> empty .)
    OR              reduce using rule 81 (termino -> empty .)
    PARENCLOSE      reduce using rule 81 (termino -> empty .)
    COLON           reduce using rule 81 (termino -> empty .)
    BRACECLOSE      reduce using rule 81 (termino -> empty .)


state 139

    (82) f -> PARENOPEN exp . PARENCLOSE
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

    PARENCLOSE      shift and go to state 185
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130


state 140

    (103) while_loop -> WHILE whileMigaja PARENOPEN . exp PARENCLOSE whileEval body whileEnd
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 186
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 141

    (107) for_loop -> FOR PARENOPEN for_assignment . SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body

    SEMICOLON       shift and go to state 187


state 142

    (108) for_assignment -> variable . EQUAL exp

    EQUAL           shift and go to state 188


state 143

    (110) max -> MAX PARENOPEN exp . PARENCLOSE SEMICOLON
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

    PARENCLOSE      shift and go to state 189
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130


state 144

    (111) min -> MIN PARENOPEN exp . PARENCLOSE SEMICOLON
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

    PARENCLOSE      shift and go to state 190
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130


state 145

    (112) sum -> SUM PARENOPEN exp . PARENCLOSE SEMICOLON
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

    PARENCLOSE      shift and go to state 191
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130


state 146

    (118) normal -> NORMAL PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 192


state 147

    (113) param_dist -> variable .
    (114) param_dist -> variable . COLON param_dist

    PARENCLOSE      reduce using rule 113 (param_dist -> variable .)
    COLON           shift and go to state 193


state 148

    (117) uniforme -> UNIFORME PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 194


state 149

    (116) poisson -> POISSON PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 195


state 150

    (115) binomial -> BINOMIAL PARENOPEN param_dist . PARENCLOSE SEMICOLON

    PARENCLOSE      shift and go to state 196


state 151

    (47) dec_variabless -> type dec_mvar SEMICOLON . dec_variabless
    (48) dec_variabless -> type dec_mvar SEMICOLON .
    (47) dec_variabless -> . type dec_mvar SEMICOLON dec_variabless
    (48) dec_variabless -> . type dec_mvar SEMICOLON
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . CHAR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    IF              reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .)
    PRINT           reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .)
    READ            reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .)
    ID              reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .)
    PLOT            reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .)
    RETURN          reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .)
    WHILE           reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .)
    FOR             reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .)
    MAX             reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .)
    MIN             reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .)
    SUM             reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .)
    NORMAL          reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .)
    UNIFORME        reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .)
    POISSON         reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .)
    BINOMIAL        reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .)
    BRACKETCLOSE    reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .)
    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19

  ! INT             [ reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .) ]
  ! CHAR            [ reduce using rule 48 (dec_variabless -> type dec_mvar SEMICOLON .) ]

    type                           shift and go to state 65
    dec_variabless                 shift and go to state 197

state 152

    (49) dec_mvar -> ID COLON . dec_mvar
    (49) dec_mvar -> . ID COLON dec_mvar
    (50) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (51) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (52) dec_mvar -> . ID
    (53) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (54) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 103

    dec_mvar                       shift and go to state 198

state 153

    (50) dec_mvar -> ID BRACEOPEN . CTEINT BRACECLOSE COLON dec_mvar
    (51) dec_mvar -> ID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (53) dec_mvar -> ID BRACEOPEN . CTEINT BRACECLOSE
    (54) dec_mvar -> ID BRACEOPEN . CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    CTEINT          shift and go to state 199


state 154

    (19) param -> type . variable
    (20) param -> type . variable COLON param
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 78

    variable                       shift and go to state 200

state 155

    (17) dec_func -> FUNCTION type ID PARENOPEN param . PARENCLOSE body

    PARENCLOSE      shift and go to state 201


state 156

    (21) param -> empty .

    PARENCLOSE      reduce using rule 21 (param -> empty .)


state 157

    (18) dec_func -> FUNCTION VOID ID PARENOPEN param . PARENCLOSE body

    PARENCLOSE      shift and go to state 202


state 158

    (12) mvar -> ID BRACEOPEN CTEINT BRACECLOSE . COLON mvar
    (13) mvar -> ID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (15) mvar -> ID BRACEOPEN CTEINT BRACECLOSE .
    (16) mvar -> ID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 204
    BRACEOPEN       shift and go to state 203
    SEMICOLON       reduce using rule 15 (mvar -> ID BRACEOPEN CTEINT BRACECLOSE .)


state 159

    (55) assignment -> variable EQUAL exp SEMICOLON .

    IF              reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    PRINT           reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    READ            reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    ID              reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    PLOT            reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    RETURN          reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    WHILE           reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    FOR             reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    MAX             reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    MIN             reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    SUM             reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    NORMAL          reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    UNIFORME        reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    POISSON         reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    BINOMIAL        reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    INT             reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    FLOAT           reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    CHAR            reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)
    BRACKETCLOSE    reduce using rule 55 (assignment -> variable EQUAL exp SEMICOLON .)


state 160

    (91) condition -> IF PARENOPEN exp PARENCLOSE . body
    (92) condition -> IF PARENOPEN exp PARENCLOSE . body ELSE body
    (25) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 22

    body                           shift and go to state 205

state 161

    (94) writing -> PRINT PARENOPEN writingg PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 206


state 162

    (96) writingg -> exp COLON . writingg
    (95) writingg -> . exp
    (96) writingg -> . exp COLON writingg
    (97) writingg -> . auxString
    (98) writingg -> . auxString COLON writingg
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (99) auxString -> . CTESTRING
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 114
    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 112
    writingg                       shift and go to state 207
    auxString                      shift and go to state 113
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 163

    (98) writingg -> auxString COLON . writingg
    (95) writingg -> . exp
    (96) writingg -> . exp COLON writingg
    (97) writingg -> . auxString
    (98) writingg -> . auxString COLON writingg
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (99) auxString -> . CTESTRING
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    CTESTRING       shift and go to state 114
    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    auxString                      shift and go to state 113
    writingg                       shift and go to state 208
    exp                            shift and go to state 112
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 164

    (102) multivariables -> variable COLON multivariables .

    SEMICOLON       reduce using rule 102 (multivariables -> variable COLON multivariables .)


state 165

    (56) call_func -> ID PARENOPEN call_funcc PARENCLOSE .

    IF              reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    PRINT           reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    READ            reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    ID              reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    PLOT            reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    RETURN          reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    WHILE           reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    FOR             reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    MAX             reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    MIN             reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    SUM             reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    NORMAL          reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    UNIFORME        reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    POISSON         reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    BINOMIAL        reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    INT             reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    FLOAT           reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    CHAR            reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    BRACKETCLOSE    reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    MULTIPLY        reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    DIVIDE          reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    PLUS            reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    MINUS           reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    SEMICOLON       reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    GREATHERTHAN    reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    LESSTHAN        reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    GREATHEREQUAL   reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    LESSEQUAL       reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    DIFFERENT       reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    SAME            reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    AND             reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    OR              reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    PARENCLOSE      reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    COLON           reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)
    BRACECLOSE      reduce using rule 56 (call_func -> ID PARENOPEN call_funcc PARENCLOSE .)


state 166

    (58) call_funcc -> exp COLON . call_funcc
    (57) call_funcc -> . exp
    (58) call_funcc -> . exp COLON call_funcc
    (59) call_funcc -> . empty
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (119) empty -> .
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENCLOSE      reduce using rule 119 (empty -> .)
    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 118
    call_funcc                     shift and go to state 209
    empty                          shift and go to state 119
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 167

    (89) variable -> ID BRACEOPEN exp BRACECLOSE .
    (90) variable -> ID BRACEOPEN exp BRACECLOSE . BRACEOPEN exp BRACECLOSE

    EQUAL           reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    COLON           reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    SEMICOLON       reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    MULTIPLY        reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    DIVIDE          reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    PLUS            reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    MINUS           reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    GREATHERTHAN    reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    LESSTHAN        reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    GREATHEREQUAL   reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    LESSEQUAL       reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    DIFFERENT       reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    SAME            reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    AND             reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    OR              reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    PARENCLOSE      reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    BRACECLOSE      reduce using rule 89 (variable -> ID BRACEOPEN exp BRACECLOSE .)
    BRACEOPEN       shift and go to state 210


state 168

    (60) graph -> PLOT PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 211


state 169

    (61) exp -> exp GREATHERTHAN exp .
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

  ! shift/reduce conflict for GREATHERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for LESSEQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 61 (exp -> exp GREATHERTHAN exp .)
    PARENCLOSE      reduce using rule 61 (exp -> exp GREATHERTHAN exp .)
    COLON           reduce using rule 61 (exp -> exp GREATHERTHAN exp .)
    BRACECLOSE      reduce using rule 61 (exp -> exp GREATHERTHAN exp .)
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

  ! GREATHERTHAN    [ reduce using rule 61 (exp -> exp GREATHERTHAN exp .) ]
  ! LESSTHAN        [ reduce using rule 61 (exp -> exp GREATHERTHAN exp .) ]
  ! GREATHEREQUAL   [ reduce using rule 61 (exp -> exp GREATHERTHAN exp .) ]
  ! LESSEQUAL       [ reduce using rule 61 (exp -> exp GREATHERTHAN exp .) ]
  ! DIFFERENT       [ reduce using rule 61 (exp -> exp GREATHERTHAN exp .) ]
  ! SAME            [ reduce using rule 61 (exp -> exp GREATHERTHAN exp .) ]
  ! AND             [ reduce using rule 61 (exp -> exp GREATHERTHAN exp .) ]
  ! OR              [ reduce using rule 61 (exp -> exp GREATHERTHAN exp .) ]


state 170

    (62) exp -> exp LESSTHAN exp .
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

  ! shift/reduce conflict for GREATHERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for LESSEQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 62 (exp -> exp LESSTHAN exp .)
    PARENCLOSE      reduce using rule 62 (exp -> exp LESSTHAN exp .)
    COLON           reduce using rule 62 (exp -> exp LESSTHAN exp .)
    BRACECLOSE      reduce using rule 62 (exp -> exp LESSTHAN exp .)
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

  ! GREATHERTHAN    [ reduce using rule 62 (exp -> exp LESSTHAN exp .) ]
  ! LESSTHAN        [ reduce using rule 62 (exp -> exp LESSTHAN exp .) ]
  ! GREATHEREQUAL   [ reduce using rule 62 (exp -> exp LESSTHAN exp .) ]
  ! LESSEQUAL       [ reduce using rule 62 (exp -> exp LESSTHAN exp .) ]
  ! DIFFERENT       [ reduce using rule 62 (exp -> exp LESSTHAN exp .) ]
  ! SAME            [ reduce using rule 62 (exp -> exp LESSTHAN exp .) ]
  ! AND             [ reduce using rule 62 (exp -> exp LESSTHAN exp .) ]
  ! OR              [ reduce using rule 62 (exp -> exp LESSTHAN exp .) ]


state 171

    (63) exp -> exp GREATHEREQUAL exp .
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

  ! shift/reduce conflict for GREATHERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for LESSEQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 63 (exp -> exp GREATHEREQUAL exp .)
    PARENCLOSE      reduce using rule 63 (exp -> exp GREATHEREQUAL exp .)
    COLON           reduce using rule 63 (exp -> exp GREATHEREQUAL exp .)
    BRACECLOSE      reduce using rule 63 (exp -> exp GREATHEREQUAL exp .)
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

  ! GREATHERTHAN    [ reduce using rule 63 (exp -> exp GREATHEREQUAL exp .) ]
  ! LESSTHAN        [ reduce using rule 63 (exp -> exp GREATHEREQUAL exp .) ]
  ! GREATHEREQUAL   [ reduce using rule 63 (exp -> exp GREATHEREQUAL exp .) ]
  ! LESSEQUAL       [ reduce using rule 63 (exp -> exp GREATHEREQUAL exp .) ]
  ! DIFFERENT       [ reduce using rule 63 (exp -> exp GREATHEREQUAL exp .) ]
  ! SAME            [ reduce using rule 63 (exp -> exp GREATHEREQUAL exp .) ]
  ! AND             [ reduce using rule 63 (exp -> exp GREATHEREQUAL exp .) ]
  ! OR              [ reduce using rule 63 (exp -> exp GREATHEREQUAL exp .) ]


state 172

    (64) exp -> exp LESSEQUAL exp .
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

  ! shift/reduce conflict for GREATHERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for LESSEQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 64 (exp -> exp LESSEQUAL exp .)
    PARENCLOSE      reduce using rule 64 (exp -> exp LESSEQUAL exp .)
    COLON           reduce using rule 64 (exp -> exp LESSEQUAL exp .)
    BRACECLOSE      reduce using rule 64 (exp -> exp LESSEQUAL exp .)
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

  ! GREATHERTHAN    [ reduce using rule 64 (exp -> exp LESSEQUAL exp .) ]
  ! LESSTHAN        [ reduce using rule 64 (exp -> exp LESSEQUAL exp .) ]
  ! GREATHEREQUAL   [ reduce using rule 64 (exp -> exp LESSEQUAL exp .) ]
  ! LESSEQUAL       [ reduce using rule 64 (exp -> exp LESSEQUAL exp .) ]
  ! DIFFERENT       [ reduce using rule 64 (exp -> exp LESSEQUAL exp .) ]
  ! SAME            [ reduce using rule 64 (exp -> exp LESSEQUAL exp .) ]
  ! AND             [ reduce using rule 64 (exp -> exp LESSEQUAL exp .) ]
  ! OR              [ reduce using rule 64 (exp -> exp LESSEQUAL exp .) ]


state 173

    (65) exp -> exp DIFFERENT exp .
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

  ! shift/reduce conflict for GREATHERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for LESSEQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 65 (exp -> exp DIFFERENT exp .)
    PARENCLOSE      reduce using rule 65 (exp -> exp DIFFERENT exp .)
    COLON           reduce using rule 65 (exp -> exp DIFFERENT exp .)
    BRACECLOSE      reduce using rule 65 (exp -> exp DIFFERENT exp .)
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

  ! GREATHERTHAN    [ reduce using rule 65 (exp -> exp DIFFERENT exp .) ]
  ! LESSTHAN        [ reduce using rule 65 (exp -> exp DIFFERENT exp .) ]
  ! GREATHEREQUAL   [ reduce using rule 65 (exp -> exp DIFFERENT exp .) ]
  ! LESSEQUAL       [ reduce using rule 65 (exp -> exp DIFFERENT exp .) ]
  ! DIFFERENT       [ reduce using rule 65 (exp -> exp DIFFERENT exp .) ]
  ! SAME            [ reduce using rule 65 (exp -> exp DIFFERENT exp .) ]
  ! AND             [ reduce using rule 65 (exp -> exp DIFFERENT exp .) ]
  ! OR              [ reduce using rule 65 (exp -> exp DIFFERENT exp .) ]


state 174

    (66) exp -> exp SAME exp .
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

  ! shift/reduce conflict for GREATHERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for LESSEQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 66 (exp -> exp SAME exp .)
    PARENCLOSE      reduce using rule 66 (exp -> exp SAME exp .)
    COLON           reduce using rule 66 (exp -> exp SAME exp .)
    BRACECLOSE      reduce using rule 66 (exp -> exp SAME exp .)
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

  ! GREATHERTHAN    [ reduce using rule 66 (exp -> exp SAME exp .) ]
  ! LESSTHAN        [ reduce using rule 66 (exp -> exp SAME exp .) ]
  ! GREATHEREQUAL   [ reduce using rule 66 (exp -> exp SAME exp .) ]
  ! LESSEQUAL       [ reduce using rule 66 (exp -> exp SAME exp .) ]
  ! DIFFERENT       [ reduce using rule 66 (exp -> exp SAME exp .) ]
  ! SAME            [ reduce using rule 66 (exp -> exp SAME exp .) ]
  ! AND             [ reduce using rule 66 (exp -> exp SAME exp .) ]
  ! OR              [ reduce using rule 66 (exp -> exp SAME exp .) ]


state 175

    (67) exp -> exp AND exp .
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

  ! shift/reduce conflict for GREATHERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for LESSEQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 67 (exp -> exp AND exp .)
    PARENCLOSE      reduce using rule 67 (exp -> exp AND exp .)
    COLON           reduce using rule 67 (exp -> exp AND exp .)
    BRACECLOSE      reduce using rule 67 (exp -> exp AND exp .)
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

  ! GREATHERTHAN    [ reduce using rule 67 (exp -> exp AND exp .) ]
  ! LESSTHAN        [ reduce using rule 67 (exp -> exp AND exp .) ]
  ! GREATHEREQUAL   [ reduce using rule 67 (exp -> exp AND exp .) ]
  ! LESSEQUAL       [ reduce using rule 67 (exp -> exp AND exp .) ]
  ! DIFFERENT       [ reduce using rule 67 (exp -> exp AND exp .) ]
  ! SAME            [ reduce using rule 67 (exp -> exp AND exp .) ]
  ! AND             [ reduce using rule 67 (exp -> exp AND exp .) ]
  ! OR              [ reduce using rule 67 (exp -> exp AND exp .) ]


state 176

    (68) exp -> exp OR exp .
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

  ! shift/reduce conflict for GREATHERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATHEREQUAL resolved as shift
  ! shift/reduce conflict for LESSEQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 68 (exp -> exp OR exp .)
    PARENCLOSE      reduce using rule 68 (exp -> exp OR exp .)
    COLON           reduce using rule 68 (exp -> exp OR exp .)
    BRACECLOSE      reduce using rule 68 (exp -> exp OR exp .)
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

  ! GREATHERTHAN    [ reduce using rule 68 (exp -> exp OR exp .) ]
  ! LESSTHAN        [ reduce using rule 68 (exp -> exp OR exp .) ]
  ! GREATHEREQUAL   [ reduce using rule 68 (exp -> exp OR exp .) ]
  ! LESSEQUAL       [ reduce using rule 68 (exp -> exp OR exp .) ]
  ! DIFFERENT       [ reduce using rule 68 (exp -> exp OR exp .) ]
  ! SAME            [ reduce using rule 68 (exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 68 (exp -> exp OR exp .) ]
  ! OR              [ reduce using rule 68 (exp -> exp OR exp .) ]


state 177

    (71) m_expp -> PLUS appendPLUS . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    m_exp                          shift and go to state 212
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 178

    (74) appendPLUS -> empty .

    PARENOPEN       reduce using rule 74 (appendPLUS -> empty .)
    ID              reduce using rule 74 (appendPLUS -> empty .)
    CTEINT          reduce using rule 74 (appendPLUS -> empty .)
    CTFLOAT         reduce using rule 74 (appendPLUS -> empty .)


state 179

    (72) m_expp -> MINUS appendMINUS . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    m_exp                          shift and go to state 213
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 180

    (75) appendMINUS -> empty .

    PARENOPEN       reduce using rule 75 (appendMINUS -> empty .)
    ID              reduce using rule 75 (appendMINUS -> empty .)
    CTEINT          reduce using rule 75 (appendMINUS -> empty .)
    CTFLOAT         reduce using rule 75 (appendMINUS -> empty .)


state 181

    (79) termino -> MULTIPLY appendMULTIPLY . t
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    t                              shift and go to state 214
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 182

    (76) appendMULTIPLY -> empty .

    PARENOPEN       reduce using rule 76 (appendMULTIPLY -> empty .)
    ID              reduce using rule 76 (appendMULTIPLY -> empty .)
    CTEINT          reduce using rule 76 (appendMULTIPLY -> empty .)
    CTFLOAT         reduce using rule 76 (appendMULTIPLY -> empty .)


state 183

    (80) termino -> DIVIDE appendDIVIDE . t
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    t                              shift and go to state 215
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 184

    (77) appendDIVIDE -> empty .

    PARENOPEN       reduce using rule 77 (appendDIVIDE -> empty .)
    ID              reduce using rule 77 (appendDIVIDE -> empty .)
    CTEINT          reduce using rule 77 (appendDIVIDE -> empty .)
    CTFLOAT         reduce using rule 77 (appendDIVIDE -> empty .)


state 185

    (82) f -> PARENOPEN exp PARENCLOSE .

    MULTIPLY        reduce using rule 82 (f -> PARENOPEN exp PARENCLOSE .)
    DIVIDE          reduce using rule 82 (f -> PARENOPEN exp PARENCLOSE .)
    PLUS            reduce using rule 82 (f -> PARENOPEN exp PARENCLOSE .)
    MINUS           reduce using rule 82 (f -> PARENOPEN exp PARENCLOSE .)
    SEMICOLON       reduce using rule 82 (f -> PARENOPEN exp PARENCLOSE .)
    GREATHERTHAN    reduce using rule 82 (f -> PARENOPEN exp PARENCLOSE .)
    LESSTHAN        reduce using rule 82 (f -> PARENOPEN exp PARENCLOSE .)
    GREATHEREQUAL   reduce using rule 82 (f -> PARENOPEN exp PARENCLOSE .)
    LESSEQUAL       reduce using rule 82 (f -> PARENOPEN exp PARENCLOSE .)
    DIFFERENT       reduce using rule 82 (f -> PARENOPEN exp PARENCLOSE .)
    SAME            reduce using rule 82 (f -> PARENOPEN exp PARENCLOSE .)
    AND             reduce using rule 82 (f -> PARENOPEN exp PARENCLOSE .)
    OR              reduce using rule 82 (f -> PARENOPEN exp PARENCLOSE .)
    PARENCLOSE      reduce using rule 82 (f -> PARENOPEN exp PARENCLOSE .)
    COLON           reduce using rule 82 (f -> PARENOPEN exp PARENCLOSE .)
    BRACECLOSE      reduce using rule 82 (f -> PARENOPEN exp PARENCLOSE .)


state 186

    (103) while_loop -> WHILE whileMigaja PARENOPEN exp . PARENCLOSE whileEval body whileEnd
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

    PARENCLOSE      shift and go to state 216
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130


state 187

    (107) for_loop -> FOR PARENOPEN for_assignment SEMICOLON . exp SEMICOLON for_assignment PARENCLOSE body
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 217
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 188

    (108) for_assignment -> variable EQUAL . exp
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    variable                       shift and go to state 90
    exp                            shift and go to state 218
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    call_func                      shift and go to state 91

state 189

    (110) max -> MAX PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 219


state 190

    (111) min -> MIN PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 220


state 191

    (112) sum -> SUM PARENOPEN exp PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 221


state 192

    (118) normal -> NORMAL PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 222


state 193

    (114) param_dist -> variable COLON . param_dist
    (113) param_dist -> . variable
    (114) param_dist -> . variable COLON param_dist
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 78

    variable                       shift and go to state 147
    param_dist                     shift and go to state 223

state 194

    (117) uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 224


state 195

    (116) poisson -> POISSON PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 225


state 196

    (115) binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE . SEMICOLON

    SEMICOLON       shift and go to state 226


state 197

    (47) dec_variabless -> type dec_mvar SEMICOLON dec_variabless .

    IF              reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    PRINT           reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    READ            reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    ID              reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    PLOT            reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    RETURN          reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    WHILE           reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    FOR             reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    MAX             reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    MIN             reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    SUM             reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    NORMAL          reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    UNIFORME        reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    POISSON         reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    BINOMIAL        reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    INT             reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    FLOAT           reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    CHAR            reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)
    BRACKETCLOSE    reduce using rule 47 (dec_variabless -> type dec_mvar SEMICOLON dec_variabless .)


state 198

    (49) dec_mvar -> ID COLON dec_mvar .

    SEMICOLON       reduce using rule 49 (dec_mvar -> ID COLON dec_mvar .)


state 199

    (50) dec_mvar -> ID BRACEOPEN CTEINT . BRACECLOSE COLON dec_mvar
    (51) dec_mvar -> ID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (53) dec_mvar -> ID BRACEOPEN CTEINT . BRACECLOSE
    (54) dec_mvar -> ID BRACEOPEN CTEINT . BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    BRACECLOSE      shift and go to state 227


state 200

    (19) param -> type variable .
    (20) param -> type variable . COLON param

    PARENCLOSE      reduce using rule 19 (param -> type variable .)
    COLON           shift and go to state 228


state 201

    (17) dec_func -> FUNCTION type ID PARENOPEN param PARENCLOSE . body
    (25) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 22

    body                           shift and go to state 229

state 202

    (18) dec_func -> FUNCTION VOID ID PARENOPEN param PARENCLOSE . body
    (25) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 22

    body                           shift and go to state 230

state 203

    (13) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE COLON mvar
    (16) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE

    CTEINT          shift and go to state 231


state 204

    (12) mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON . mvar
    (11) mvar -> . ID COLON mvar
    (12) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (13) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (14) mvar -> . ID
    (15) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (16) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 27

    mvar                           shift and go to state 232

state 205

    (91) condition -> IF PARENOPEN exp PARENCLOSE body .
    (92) condition -> IF PARENOPEN exp PARENCLOSE body . ELSE body

    IF              reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    PRINT           reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    READ            reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    ID              reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    PLOT            reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    RETURN          reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    WHILE           reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    FOR             reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    MAX             reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    MIN             reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    SUM             reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    NORMAL          reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    UNIFORME        reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    POISSON         reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    BINOMIAL        reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    INT             reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    FLOAT           reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    CHAR            reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    BRACKETCLOSE    reduce using rule 91 (condition -> IF PARENOPEN exp PARENCLOSE body .)
    ELSE            shift and go to state 233


state 206

    (94) writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .

    IF              reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    READ            reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    ID              reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    INT             reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 94 (writing -> PRINT PARENOPEN writingg PARENCLOSE SEMICOLON .)


state 207

    (96) writingg -> exp COLON writingg .

    PARENCLOSE      reduce using rule 96 (writingg -> exp COLON writingg .)


state 208

    (98) writingg -> auxString COLON writingg .

    PARENCLOSE      reduce using rule 98 (writingg -> auxString COLON writingg .)


state 209

    (58) call_funcc -> exp COLON call_funcc .

    PARENCLOSE      reduce using rule 58 (call_funcc -> exp COLON call_funcc .)


state 210

    (90) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN . exp BRACECLOSE
    (61) exp -> . exp GREATHERTHAN exp
    (62) exp -> . exp LESSTHAN exp
    (63) exp -> . exp GREATHEREQUAL exp
    (64) exp -> . exp LESSEQUAL exp
    (65) exp -> . exp DIFFERENT exp
    (66) exp -> . exp SAME exp
    (67) exp -> . exp AND exp
    (68) exp -> . exp OR exp
    (69) exp -> . m_exp
    (70) m_exp -> . t m_expp
    (78) t -> . f termino
    (82) f -> . PARENOPEN exp PARENCLOSE
    (83) f -> . ID
    (84) f -> . CTEINT
    (85) f -> . CTFLOAT
    (86) f -> . variable
    (87) f -> . call_func
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE
    (56) call_func -> . ID PARENOPEN call_funcc PARENCLOSE

    PARENOPEN       shift and go to state 86
    ID              shift and go to state 87
    CTEINT          shift and go to state 88
    CTFLOAT         shift and go to state 89

    exp                            shift and go to state 234
    m_exp                          shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    variable                       shift and go to state 90
    call_func                      shift and go to state 91

state 211

    (60) graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 60 (graph -> PLOT PARENOPEN exp PARENCLOSE SEMICOLON .)


state 212

    (71) m_expp -> PLUS appendPLUS m_exp .

    SEMICOLON       reduce using rule 71 (m_expp -> PLUS appendPLUS m_exp .)
    GREATHERTHAN    reduce using rule 71 (m_expp -> PLUS appendPLUS m_exp .)
    LESSTHAN        reduce using rule 71 (m_expp -> PLUS appendPLUS m_exp .)
    GREATHEREQUAL   reduce using rule 71 (m_expp -> PLUS appendPLUS m_exp .)
    LESSEQUAL       reduce using rule 71 (m_expp -> PLUS appendPLUS m_exp .)
    DIFFERENT       reduce using rule 71 (m_expp -> PLUS appendPLUS m_exp .)
    SAME            reduce using rule 71 (m_expp -> PLUS appendPLUS m_exp .)
    AND             reduce using rule 71 (m_expp -> PLUS appendPLUS m_exp .)
    OR              reduce using rule 71 (m_expp -> PLUS appendPLUS m_exp .)
    PARENCLOSE      reduce using rule 71 (m_expp -> PLUS appendPLUS m_exp .)
    COLON           reduce using rule 71 (m_expp -> PLUS appendPLUS m_exp .)
    BRACECLOSE      reduce using rule 71 (m_expp -> PLUS appendPLUS m_exp .)


state 213

    (72) m_expp -> MINUS appendMINUS m_exp .

    SEMICOLON       reduce using rule 72 (m_expp -> MINUS appendMINUS m_exp .)
    GREATHERTHAN    reduce using rule 72 (m_expp -> MINUS appendMINUS m_exp .)
    LESSTHAN        reduce using rule 72 (m_expp -> MINUS appendMINUS m_exp .)
    GREATHEREQUAL   reduce using rule 72 (m_expp -> MINUS appendMINUS m_exp .)
    LESSEQUAL       reduce using rule 72 (m_expp -> MINUS appendMINUS m_exp .)
    DIFFERENT       reduce using rule 72 (m_expp -> MINUS appendMINUS m_exp .)
    SAME            reduce using rule 72 (m_expp -> MINUS appendMINUS m_exp .)
    AND             reduce using rule 72 (m_expp -> MINUS appendMINUS m_exp .)
    OR              reduce using rule 72 (m_expp -> MINUS appendMINUS m_exp .)
    PARENCLOSE      reduce using rule 72 (m_expp -> MINUS appendMINUS m_exp .)
    COLON           reduce using rule 72 (m_expp -> MINUS appendMINUS m_exp .)
    BRACECLOSE      reduce using rule 72 (m_expp -> MINUS appendMINUS m_exp .)


state 214

    (79) termino -> MULTIPLY appendMULTIPLY t .

    PLUS            reduce using rule 79 (termino -> MULTIPLY appendMULTIPLY t .)
    MINUS           reduce using rule 79 (termino -> MULTIPLY appendMULTIPLY t .)
    SEMICOLON       reduce using rule 79 (termino -> MULTIPLY appendMULTIPLY t .)
    GREATHERTHAN    reduce using rule 79 (termino -> MULTIPLY appendMULTIPLY t .)
    LESSTHAN        reduce using rule 79 (termino -> MULTIPLY appendMULTIPLY t .)
    GREATHEREQUAL   reduce using rule 79 (termino -> MULTIPLY appendMULTIPLY t .)
    LESSEQUAL       reduce using rule 79 (termino -> MULTIPLY appendMULTIPLY t .)
    DIFFERENT       reduce using rule 79 (termino -> MULTIPLY appendMULTIPLY t .)
    SAME            reduce using rule 79 (termino -> MULTIPLY appendMULTIPLY t .)
    AND             reduce using rule 79 (termino -> MULTIPLY appendMULTIPLY t .)
    OR              reduce using rule 79 (termino -> MULTIPLY appendMULTIPLY t .)
    PARENCLOSE      reduce using rule 79 (termino -> MULTIPLY appendMULTIPLY t .)
    COLON           reduce using rule 79 (termino -> MULTIPLY appendMULTIPLY t .)
    BRACECLOSE      reduce using rule 79 (termino -> MULTIPLY appendMULTIPLY t .)


state 215

    (80) termino -> DIVIDE appendDIVIDE t .

    PLUS            reduce using rule 80 (termino -> DIVIDE appendDIVIDE t .)
    MINUS           reduce using rule 80 (termino -> DIVIDE appendDIVIDE t .)
    SEMICOLON       reduce using rule 80 (termino -> DIVIDE appendDIVIDE t .)
    GREATHERTHAN    reduce using rule 80 (termino -> DIVIDE appendDIVIDE t .)
    LESSTHAN        reduce using rule 80 (termino -> DIVIDE appendDIVIDE t .)
    GREATHEREQUAL   reduce using rule 80 (termino -> DIVIDE appendDIVIDE t .)
    LESSEQUAL       reduce using rule 80 (termino -> DIVIDE appendDIVIDE t .)
    DIFFERENT       reduce using rule 80 (termino -> DIVIDE appendDIVIDE t .)
    SAME            reduce using rule 80 (termino -> DIVIDE appendDIVIDE t .)
    AND             reduce using rule 80 (termino -> DIVIDE appendDIVIDE t .)
    OR              reduce using rule 80 (termino -> DIVIDE appendDIVIDE t .)
    PARENCLOSE      reduce using rule 80 (termino -> DIVIDE appendDIVIDE t .)
    COLON           reduce using rule 80 (termino -> DIVIDE appendDIVIDE t .)
    BRACECLOSE      reduce using rule 80 (termino -> DIVIDE appendDIVIDE t .)


state 216

    (103) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE . whileEval body whileEnd
    (105) whileEval -> . empty
    (119) empty -> .

    BRACKETOPEN     reduce using rule 119 (empty -> .)

    whileEval                      shift and go to state 235
    empty                          shift and go to state 236

state 217

    (107) for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp . SEMICOLON for_assignment PARENCLOSE body
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

    SEMICOLON       shift and go to state 237
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130


state 218

    (108) for_assignment -> variable EQUAL exp .
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

    SEMICOLON       reduce using rule 108 (for_assignment -> variable EQUAL exp .)
    PARENCLOSE      reduce using rule 108 (for_assignment -> variable EQUAL exp .)
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130


state 219

    (110) max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 110 (max -> MAX PARENOPEN exp PARENCLOSE SEMICOLON .)


state 220

    (111) min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 111 (min -> MIN PARENOPEN exp PARENCLOSE SEMICOLON .)


state 221

    (112) sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .

    IF              reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    READ            reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    ID              reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    INT             reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 112 (sum -> SUM PARENOPEN exp PARENCLOSE SEMICOLON .)


state 222

    (118) normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 118 (normal -> NORMAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 223

    (114) param_dist -> variable COLON param_dist .

    PARENCLOSE      reduce using rule 114 (param_dist -> variable COLON param_dist .)


state 224

    (117) uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 117 (uniforme -> UNIFORME PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 225

    (116) poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 116 (poisson -> POISSON PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 226

    (115) binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .

    IF              reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PRINT           reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    READ            reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    ID              reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    PLOT            reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    RETURN          reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    WHILE           reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FOR             reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MAX             reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    MIN             reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    SUM             reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    NORMAL          reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    UNIFORME        reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    POISSON         reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BINOMIAL        reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    INT             reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    FLOAT           reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    CHAR            reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)
    BRACKETCLOSE    reduce using rule 115 (binomial -> BINOMIAL PARENOPEN param_dist PARENCLOSE SEMICOLON .)


state 227

    (50) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE . COLON dec_mvar
    (51) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (53) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE .
    (54) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE . BRACEOPEN CTEINT BRACECLOSE

    COLON           shift and go to state 239
    BRACEOPEN       shift and go to state 238
    SEMICOLON       reduce using rule 53 (dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE .)


state 228

    (20) param -> type variable COLON . param
    (19) param -> . type variable
    (20) param -> . type variable COLON param
    (21) param -> . empty
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . CHAR
    (119) empty -> .

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    CHAR            shift and go to state 19
    PARENCLOSE      reduce using rule 119 (empty -> .)

    type                           shift and go to state 154
    param                          shift and go to state 240
    empty                          shift and go to state 156

state 229

    (17) dec_func -> FUNCTION type ID PARENOPEN param PARENCLOSE body .

    FUNCTION        reduce using rule 17 (dec_func -> FUNCTION type ID PARENOPEN param PARENCLOSE body .)
    MAIN            reduce using rule 17 (dec_func -> FUNCTION type ID PARENOPEN param PARENCLOSE body .)


state 230

    (18) dec_func -> FUNCTION VOID ID PARENOPEN param PARENCLOSE body .

    FUNCTION        reduce using rule 18 (dec_func -> FUNCTION VOID ID PARENOPEN param PARENCLOSE body .)
    MAIN            reduce using rule 18 (dec_func -> FUNCTION VOID ID PARENOPEN param PARENCLOSE body .)


state 231

    (13) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE COLON mvar
    (16) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE

    BRACECLOSE      shift and go to state 241


state 232

    (12) mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON mvar .

    SEMICOLON       reduce using rule 12 (mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON mvar .)


state 233

    (92) condition -> IF PARENOPEN exp PARENCLOSE body ELSE . body
    (25) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 22

    body                           shift and go to state 242

state 234

    (90) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp . BRACECLOSE
    (61) exp -> exp . GREATHERTHAN exp
    (62) exp -> exp . LESSTHAN exp
    (63) exp -> exp . GREATHEREQUAL exp
    (64) exp -> exp . LESSEQUAL exp
    (65) exp -> exp . DIFFERENT exp
    (66) exp -> exp . SAME exp
    (67) exp -> exp . AND exp
    (68) exp -> exp . OR exp

    BRACECLOSE      shift and go to state 243
    GREATHERTHAN    shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATHEREQUAL   shift and go to state 125
    LESSEQUAL       shift and go to state 126
    DIFFERENT       shift and go to state 127
    SAME            shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130


state 235

    (103) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval . body whileEnd
    (25) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 22

    body                           shift and go to state 244

state 236

    (105) whileEval -> empty .

    BRACKETOPEN     reduce using rule 105 (whileEval -> empty .)


state 237

    (107) for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON . for_assignment PARENCLOSE body
    (108) for_assignment -> . variable EQUAL exp
    (88) variable -> . ID
    (89) variable -> . ID BRACEOPEN exp BRACECLOSE
    (90) variable -> . ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE

    ID              shift and go to state 78

    for_assignment                 shift and go to state 245
    variable                       shift and go to state 142

state 238

    (51) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE COLON dec_mvar
    (54) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN . CTEINT BRACECLOSE

    CTEINT          shift and go to state 246


state 239

    (50) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON . dec_mvar
    (49) dec_mvar -> . ID COLON dec_mvar
    (50) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (51) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (52) dec_mvar -> . ID
    (53) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (54) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 103

    dec_mvar                       shift and go to state 247

state 240

    (20) param -> type variable COLON param .

    PARENCLOSE      reduce using rule 20 (param -> type variable COLON param .)


state 241

    (13) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE . COLON mvar
    (16) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .

    COLON           shift and go to state 248
    SEMICOLON       reduce using rule 16 (mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .)


state 242

    (92) condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .

    IF              reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    PRINT           reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    READ            reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    ID              reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    PLOT            reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    RETURN          reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    WHILE           reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    FOR             reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    MAX             reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    MIN             reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    SUM             reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    NORMAL          reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    UNIFORME        reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    POISSON         reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    BINOMIAL        reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    INT             reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    FLOAT           reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    CHAR            reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)
    BRACKETCLOSE    reduce using rule 92 (condition -> IF PARENOPEN exp PARENCLOSE body ELSE body .)


state 243

    (90) variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .

    EQUAL           reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    COLON           reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    SEMICOLON       reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    MULTIPLY        reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    DIVIDE          reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    PLUS            reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    MINUS           reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    GREATHERTHAN    reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    LESSTHAN        reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    GREATHEREQUAL   reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    LESSEQUAL       reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    DIFFERENT       reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    SAME            reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    AND             reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    OR              reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    PARENCLOSE      reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)
    BRACECLOSE      reduce using rule 90 (variable -> ID BRACEOPEN exp BRACECLOSE BRACEOPEN exp BRACECLOSE .)


state 244

    (103) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body . whileEnd
    (106) whileEnd -> . empty
    (119) empty -> .

    IF              reduce using rule 119 (empty -> .)
    PRINT           reduce using rule 119 (empty -> .)
    READ            reduce using rule 119 (empty -> .)
    ID              reduce using rule 119 (empty -> .)
    PLOT            reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)
    WHILE           reduce using rule 119 (empty -> .)
    FOR             reduce using rule 119 (empty -> .)
    MAX             reduce using rule 119 (empty -> .)
    MIN             reduce using rule 119 (empty -> .)
    SUM             reduce using rule 119 (empty -> .)
    NORMAL          reduce using rule 119 (empty -> .)
    UNIFORME        reduce using rule 119 (empty -> .)
    POISSON         reduce using rule 119 (empty -> .)
    BINOMIAL        reduce using rule 119 (empty -> .)
    INT             reduce using rule 119 (empty -> .)
    FLOAT           reduce using rule 119 (empty -> .)
    CHAR            reduce using rule 119 (empty -> .)
    BRACKETCLOSE    reduce using rule 119 (empty -> .)

    whileEnd                       shift and go to state 249
    empty                          shift and go to state 250

state 245

    (107) for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment . PARENCLOSE body

    PARENCLOSE      shift and go to state 251


state 246

    (51) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE COLON dec_mvar
    (54) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT . BRACECLOSE

    BRACECLOSE      shift and go to state 252


state 247

    (50) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .

    SEMICOLON       reduce using rule 50 (dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .)


state 248

    (13) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON . mvar
    (11) mvar -> . ID COLON mvar
    (12) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (13) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar
    (14) mvar -> . ID
    (15) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (16) mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 27

    mvar                           shift and go to state 253

state 249

    (103) while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .

    IF              reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    PRINT           reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    READ            reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    ID              reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    PLOT            reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    RETURN          reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    WHILE           reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    FOR             reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    MAX             reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    MIN             reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    SUM             reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    NORMAL          reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    UNIFORME        reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    POISSON         reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    BINOMIAL        reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    INT             reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    FLOAT           reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    CHAR            reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)
    BRACKETCLOSE    reduce using rule 103 (while_loop -> WHILE whileMigaja PARENOPEN exp PARENCLOSE whileEval body whileEnd .)


state 250

    (106) whileEnd -> empty .

    IF              reduce using rule 106 (whileEnd -> empty .)
    PRINT           reduce using rule 106 (whileEnd -> empty .)
    READ            reduce using rule 106 (whileEnd -> empty .)
    ID              reduce using rule 106 (whileEnd -> empty .)
    PLOT            reduce using rule 106 (whileEnd -> empty .)
    RETURN          reduce using rule 106 (whileEnd -> empty .)
    WHILE           reduce using rule 106 (whileEnd -> empty .)
    FOR             reduce using rule 106 (whileEnd -> empty .)
    MAX             reduce using rule 106 (whileEnd -> empty .)
    MIN             reduce using rule 106 (whileEnd -> empty .)
    SUM             reduce using rule 106 (whileEnd -> empty .)
    NORMAL          reduce using rule 106 (whileEnd -> empty .)
    UNIFORME        reduce using rule 106 (whileEnd -> empty .)
    POISSON         reduce using rule 106 (whileEnd -> empty .)
    BINOMIAL        reduce using rule 106 (whileEnd -> empty .)
    INT             reduce using rule 106 (whileEnd -> empty .)
    FLOAT           reduce using rule 106 (whileEnd -> empty .)
    CHAR            reduce using rule 106 (whileEnd -> empty .)
    BRACKETCLOSE    reduce using rule 106 (whileEnd -> empty .)


state 251

    (107) for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE . body
    (25) body -> . BRACKETOPEN bodyy BRACKETCLOSE

    BRACKETOPEN     shift and go to state 22

    body                           shift and go to state 254

state 252

    (51) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE . COLON dec_mvar
    (54) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .

    COLON           shift and go to state 255
    SEMICOLON       reduce using rule 54 (dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE .)


state 253

    (13) mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar .

    SEMICOLON       reduce using rule 13 (mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON mvar .)


state 254

    (107) for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .

    IF              reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    PRINT           reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    READ            reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    ID              reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    PLOT            reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    RETURN          reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    WHILE           reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    FOR             reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    MAX             reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    MIN             reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    SUM             reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    NORMAL          reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    UNIFORME        reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    POISSON         reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    BINOMIAL        reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    INT             reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    FLOAT           reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    CHAR            reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)
    BRACKETCLOSE    reduce using rule 107 (for_loop -> FOR PARENOPEN for_assignment SEMICOLON exp SEMICOLON for_assignment PARENCLOSE body .)


state 255

    (51) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON . dec_mvar
    (49) dec_mvar -> . ID COLON dec_mvar
    (50) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (51) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar
    (52) dec_mvar -> . ID
    (53) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE
    (54) dec_mvar -> . ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE

    ID              shift and go to state 103

    dec_mvar                       shift and go to state 256

state 256

    (51) dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .

    SEMICOLON       reduce using rule 51 (dec_mvar -> ID BRACEOPEN CTEINT BRACECLOSE BRACEOPEN CTEINT BRACECLOSE COLON dec_mvar .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 151 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 151 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 151 resolved as shift
WARNING: shift/reduce conflict for GREATHERTHAN in state 169 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 169 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 169 resolved as shift
WARNING: shift/reduce conflict for LESSEQUAL in state 169 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 169 resolved as shift
WARNING: shift/reduce conflict for SAME in state 169 resolved as shift
WARNING: shift/reduce conflict for AND in state 169 resolved as shift
WARNING: shift/reduce conflict for OR in state 169 resolved as shift
WARNING: shift/reduce conflict for GREATHERTHAN in state 170 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 170 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 170 resolved as shift
WARNING: shift/reduce conflict for LESSEQUAL in state 170 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 170 resolved as shift
WARNING: shift/reduce conflict for SAME in state 170 resolved as shift
WARNING: shift/reduce conflict for AND in state 170 resolved as shift
WARNING: shift/reduce conflict for OR in state 170 resolved as shift
WARNING: shift/reduce conflict for GREATHERTHAN in state 171 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 171 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 171 resolved as shift
WARNING: shift/reduce conflict for LESSEQUAL in state 171 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 171 resolved as shift
WARNING: shift/reduce conflict for SAME in state 171 resolved as shift
WARNING: shift/reduce conflict for AND in state 171 resolved as shift
WARNING: shift/reduce conflict for OR in state 171 resolved as shift
WARNING: shift/reduce conflict for GREATHERTHAN in state 172 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 172 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 172 resolved as shift
WARNING: shift/reduce conflict for LESSEQUAL in state 172 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 172 resolved as shift
WARNING: shift/reduce conflict for SAME in state 172 resolved as shift
WARNING: shift/reduce conflict for AND in state 172 resolved as shift
WARNING: shift/reduce conflict for OR in state 172 resolved as shift
WARNING: shift/reduce conflict for GREATHERTHAN in state 173 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 173 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 173 resolved as shift
WARNING: shift/reduce conflict for LESSEQUAL in state 173 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 173 resolved as shift
WARNING: shift/reduce conflict for SAME in state 173 resolved as shift
WARNING: shift/reduce conflict for AND in state 173 resolved as shift
WARNING: shift/reduce conflict for OR in state 173 resolved as shift
WARNING: shift/reduce conflict for GREATHERTHAN in state 174 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 174 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 174 resolved as shift
WARNING: shift/reduce conflict for LESSEQUAL in state 174 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 174 resolved as shift
WARNING: shift/reduce conflict for SAME in state 174 resolved as shift
WARNING: shift/reduce conflict for AND in state 174 resolved as shift
WARNING: shift/reduce conflict for OR in state 174 resolved as shift
WARNING: shift/reduce conflict for GREATHERTHAN in state 175 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 175 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 175 resolved as shift
WARNING: shift/reduce conflict for LESSEQUAL in state 175 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 175 resolved as shift
WARNING: shift/reduce conflict for SAME in state 175 resolved as shift
WARNING: shift/reduce conflict for AND in state 175 resolved as shift
WARNING: shift/reduce conflict for OR in state 175 resolved as shift
WARNING: shift/reduce conflict for GREATHERTHAN in state 176 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 176 resolved as shift
WARNING: shift/reduce conflict for GREATHEREQUAL in state 176 resolved as shift
WARNING: shift/reduce conflict for LESSEQUAL in state 176 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 176 resolved as shift
WARNING: shift/reduce conflict for SAME in state 176 resolved as shift
WARNING: shift/reduce conflict for AND in state 176 resolved as shift
WARNING: shift/reduce conflict for OR in state 176 resolved as shift
WARNING: reduce/reduce conflict in state 29 resolved using rule (bodyy -> statement)
WARNING: rejected rule (empty -> <empty>) in state 29
WARNING: reduce/reduce conflict in state 87 resolved using rule (f -> ID)
WARNING: rejected rule (variable -> ID) in state 87
